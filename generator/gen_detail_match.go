package generator

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"sort"
	"strings"
	"text/template"

	"github.com/kyle-hy/es2go/utils"
)

// 生成对text字段检索的代码

// PreDetailMatchCond 使用go代码预处理渲染需要的一些逻辑，template脚本出来调试困难
func PreDetailMatchCond(mappingPath string, esInfo *EsModelInfo) []*FuncTplData {
	funcDatas := []*FuncTplData{}

	// 尝试加载自定义生成配置
	genCfg := LoadCustomGenConfig(mappingPath)
	maxCombine := MaxCombine
	if genCfg.MaxCombine > 0 {
		maxCombine = genCfg.MaxCombine
	}

	// 根据配置文件自定义字段分组进行随机组合
	cmbFields := combineCustom(esInfo.Fields, genCfg.Combine, maxCombine)
	if len(cmbFields) == 0 { // 不存在自定义字段的配置，则全字段随机
		cmbFields = utils.Combinations(esInfo.Fields, maxCombine)
	}

	// 构造渲染模板所需的数据
	for _, cfs := range cmbFields {
		ftd := &FuncTplData{
			Name:    getDetailMatchFuncName(esInfo.StructName, cfs),
			Comment: getDetailMatchFuncComment(esInfo.StructComment, cfs),
			Params:  getDetailMatchFuncParams(cfs),
			Query:   getDetailMatchMatchQuery(cfs, genCfg.TermInShould),
		}
		funcDatas = append(funcDatas, ftd)
	}

	return funcDatas
}

// combineCustom 根据指定列表随机组合数组的元素
// list 字段分组，相当于将宽表拆成多个少字段的表，减少combine组合数
func combineCustom(items []*FieldInfo, list [][]string, maxCombine int) [][]*FieldInfo {
	var all [][]*FieldInfo
	keyDict := map[string]int{}
	if maxCombine <= 0 {
		maxCombine = MaxCombine
	}
	// 过滤出字段
	for _, names := range list {
		fields := []*FieldInfo{}
		for _, n := range names {
			for _, i := range items {
				if i.EsFieldPath == n {
					fields = append(fields, i)
				}
			}
		}
		cmbs := utils.Combinations(fields, maxCombine)

		// 过滤掉重复的组合
		for _, cmb := range cmbs {
			key := getFieldKey(cmb)
			if _, ok := keyDict[key]; ok {
				// 已存在组合，跳过
				continue
			} else {
				keyDict[key] = 1
				all = append(all, cmb)
			}
		}
	}
	return all
}

func getFieldKey(fields []*FieldInfo) string {
	ks := make([]string, len(fields))
	for _, f := range fields {
		ks = append(ks, f.EsFieldPath)
	}
	sort.Strings(ks)
	return strings.Join(ks, "")
}

// getDetailMatchFuncName 获取函数名称
func getDetailMatchFuncName(structName string, fields []*FieldInfo) string {
	fn := "Match" + structName + "By"
	for _, f := range fields {
		fn += f.FieldName
	}
	return fn
}

// getDetailMatchFuncComment 获取函数注释
func getDetailMatchFuncComment(structComment string, fields []*FieldInfo) string {
	// 函数注释
	cmt := "对"
	for _, f := range fields {
		cmt += f.FieldComment + "、"
	}
	cmt = strings.TrimSuffix(cmt, "、")
	cmt += "进行检索(等于)查询" + structComment + "的详细数据列表和总数量"

	// 参数注释
	for _, f := range fields {
		cmt += "\n// " + utils.ToFirstLower(f.FieldName) + " " + f.FieldType + " " + f.FieldComment
	}

	return cmt
}

// getDetailMatchFuncParams 获取函数参数列表
func getDetailMatchFuncParams(fields []*FieldInfo) string {
	fp := ""
	for _, f := range fields {
		fp += utils.ToFirstLower(f.FieldName) + " " + f.FieldType + ", "
	}
	fp = strings.TrimSuffix(fp, ", ")
	return fp
}

// getDetailMatchMatchQuery 获取函数的查询条件
func getDetailMatchMatchQuery(fields []*FieldInfo, termInShould bool) string {
	// 精确条件默认放到filter中
	preciseOpt := "eq.WithFilter"
	if termInShould {
		preciseOpt = "eq.WithShould"
	}

	// match部分参数
	matchCnt := 0
	mq := "matches := []eq.Map{\n"
	for _, f := range fields {
		if f.EsFieldType == "text" {
			matchCnt++
			mq += fmt.Sprintf("		eq.Match(\"%s\", %s),\n", f.EsFieldPath, utils.ToFirstLower(f.FieldName))
		}
	}
	mq += "	}\n"

	// match部分参数
	termCnt := 0
	tq := "terms := []eq.Map{\n"
	for _, f := range fields {
		if f.EsFieldType != "text" {
			termCnt++
			tq += fmt.Sprintf("		eq.Term(\"%s\", %s),\n", f.EsFieldPath, utils.ToFirstLower(f.FieldName))
		}
	}
	tq += "	}\n"

	// 拼接match和term条件
	fq := ""
	if matchCnt > 0 {
		fq += mq
	}
	if termCnt > 0 {
		fq += tq
	}

	// 组合bool条件
	fq += "	esQuery := &eq.ESQuery{Query: eq.Bool("
	if matchCnt > 0 {
		fq += "eq.WithMust(matches)"
	}
	if termCnt > 0 {
		if matchCnt > 0 {
			fq += fmt.Sprintf(", %s(terms)", preciseOpt)
		} else {
			fq += fmt.Sprintf("%s(terms)", preciseOpt)
		}
	}

	fq += ")}"

	return fq
}

// GenEsDetailMatch 生成es检索详情
func GenEsDetailMatch(mappingPath, outputPath string, esInfo *EsModelInfo) error {
	// 预处理渲染所需的内容
	funcData := PreDetailMatchCond(mappingPath, esInfo)
	detailData := DetailTplData{
		PackageName:   esInfo.PackageName,
		StructName:    esInfo.StructName,
		StructComment: esInfo.StructComment,
		IndexName:     esInfo.IndexName,
		FuncDatas:     funcData,
	}

	// 渲染
	tmpl, err := template.New("structDatail").Parse(DetailTpl + DetailListTpl)
	var buf bytes.Buffer
	err = tmpl.Execute(&buf, detailData)
	if err != nil {
		fmt.Println(err)
		return err
	}

	// 写入文件
	outputPath = strings.Replace(outputPath, ".go", "_detail_match.go", -1)
	err = os.WriteFile(outputPath, buf.Bytes(), 0644)
	if err != nil {
		return fmt.Errorf("Failed to write output file %s: %v", outputPath, err)
	}

	// 调用go格式化工具格式化代码
	cmd := exec.Command("goimports", "-w", outputPath)
	cmd.Run()

	return nil
}

// DetailTpl 检索详情代码模板
const DetailTpl = `// Code generated by es2go. DO NOT EDIT.

package {{.PackageName}}

import (
	"time"
	"github.com/elastic/go-elasticsearch/v8"
	eq "github.com/kyle-hy/esquery"
)

{{$in := .}}
{{range $in.FuncDatas}}
// {{.Name}} {{.Comment}}
func {{.Name}}(es *elasticsearch.Client, {{.Params}}) (*eq.Data, *eq.Query, error) {
	{{.Query}}
	return queryBooksList(es, esQuery)
}
{{end}}
`

// DetailListTpl 检索详情列表通用代码模板
const DetailListTpl = `
// 根据query条件查询{{$in.IndexName}}详细数据列表和总数量
func query{{$in.StructName}}List (es *elasticsearch.Client, esQuery *eq.ESQuery) (*eq.Data, *eq.Query, error) {
	l, t, err := eq.QueryList[{{$in.StructName}}](es, "{{$in.IndexName}}", esQuery)
	if err != nil {
		return nil, nil, err
	}

	data := &eq.Data{Detail: l, Total: t}
	qinfo := &eq.Query{Index: "{{$in.IndexName}}", DSL: esQuery}
	return data, qinfo, nil
}
`
