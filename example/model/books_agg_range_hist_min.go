// Code generated by es2go. DO NOT EDIT.

package model

import (
	"time"

	"github.com/elastic/go-elasticsearch/v8"
	eq "github.com/kyle-hy/esquery"
)

// MinPriceInHistPriceOfBooksByPageCountGte 根据页数大于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGte(es *elasticsearch.Client, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGt 根据页数大于检索books表并按价格区间分桶统计价格的最小值
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGt(es *elasticsearch.Client, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLt 根据页数小于检索books表并按价格区间分桶统计价格的最小值
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLt(es *elasticsearch.Client, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLte 根据页数小于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLte(es *elasticsearch.Client, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLte 根据页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGte 根据价格大于等于检索books表并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGte(es *elasticsearch.Client, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGt 根据价格大于检索books表并按页数区间分桶统计页数的最小值
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGt(es *elasticsearch.Client, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLt 根据价格小于检索books表并按页数区间分桶统计页数的最小值
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLt(es *elasticsearch.Client, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLte 根据价格小于等于检索books表并按页数区间分桶统计页数的最小值
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLte(es *elasticsearch.Client, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLte 根据价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLte(es *elasticsearch.Client, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGte 根据发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGt 根据发布日期大于检索books表并按页数区间分桶统计页数的最小值
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGt(es *elasticsearch.Client, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLt 根据发布日期小于检索books表并按页数区间分桶统计页数的最小值
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLt(es *elasticsearch.Client, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLte 根据发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLte(es *elasticsearch.Client, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLte 根据发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLte(es *elasticsearch.Client, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGte 根据发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGt 根据发布日期大于检索books表并按页数区间分桶统计价格的最小值
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGt(es *elasticsearch.Client, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLt 根据发布日期小于检索books表并按页数区间分桶统计价格的最小值
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLt(es *elasticsearch.Client, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLte 根据发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLte(es *elasticsearch.Client, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLte 根据发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLte(es *elasticsearch.Client, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGte 根据发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGt 根据发布日期大于检索books表并按价格区间分桶统计页数的最小值
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGt(es *elasticsearch.Client, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLt 根据发布日期小于检索books表并按价格区间分桶统计页数的最小值
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLt(es *elasticsearch.Client, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLte 根据发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLte(es *elasticsearch.Client, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLte 根据发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLte(es *elasticsearch.Client, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGte 根据发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGt 根据发布日期大于检索books表并按价格区间分桶统计价格的最小值
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGt(es *elasticsearch.Client, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLt 根据发布日期小于检索books表并按价格区间分桶统计价格的最小值
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLt(es *elasticsearch.Client, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLte 根据发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLte(es *elasticsearch.Client, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLte 根据发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLte(es *elasticsearch.Client, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteAllText 根据全文本、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteAllText(es *elasticsearch.Client, allText string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtAllText 根据全文本、页数大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtAllText(es *elasticsearch.Client, allText string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtAllText 根据全文本、页数小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtAllText(es *elasticsearch.Client, allText string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteAllText 根据全文本、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteAllText(es *elasticsearch.Client, allText string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteAllText 根据全文本、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteAllText 根据全文本、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteAllText(es *elasticsearch.Client, allText string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtAllText 根据全文本、价格大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtAllText(es *elasticsearch.Client, allText string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtAllText 根据全文本、价格小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtAllText(es *elasticsearch.Client, allText string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteAllText 根据全文本、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteAllText(es *elasticsearch.Client, allText string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteAllText 根据全文本、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteAllText(es *elasticsearch.Client, allText string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteAllText 根据全文本、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteAllText(es *elasticsearch.Client, allText string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtAllText 根据全文本、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtAllText(es *elasticsearch.Client, allText string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtAllText 根据全文本、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtAllText(es *elasticsearch.Client, allText string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteAllText 根据全文本、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteAllText(es *elasticsearch.Client, allText string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAllText 根据全文本、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteAllText 根据全文本、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteAllText(es *elasticsearch.Client, allText string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtAllText 根据全文本、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtAllText(es *elasticsearch.Client, allText string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtAllText 根据全文本、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtAllText(es *elasticsearch.Client, allText string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteAllText 根据全文本、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteAllText(es *elasticsearch.Client, allText string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteAllText 根据全文本、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteAllText 根据全文本、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteAllText(es *elasticsearch.Client, allText string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtAllText 根据全文本、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtAllText(es *elasticsearch.Client, allText string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtAllText 根据全文本、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtAllText(es *elasticsearch.Client, allText string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteAllText 根据全文本、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteAllText(es *elasticsearch.Client, allText string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteAllText 根据全文本、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteAllText 根据全文本、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteAllText(es *elasticsearch.Client, allText string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtAllText 根据全文本、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtAllText(es *elasticsearch.Client, allText string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtAllText 根据全文本、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtAllText(es *elasticsearch.Client, allText string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteAllText 根据全文本、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteAllText(es *elasticsearch.Client, allText string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteAllText 根据全文本、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteAuthor 根据作者、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteAuthor(es *elasticsearch.Client, author string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtAuthor 根据作者、页数大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtAuthor(es *elasticsearch.Client, author string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtAuthor 根据作者、页数小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtAuthor(es *elasticsearch.Client, author string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteAuthor 根据作者、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteAuthor(es *elasticsearch.Client, author string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteAuthor 根据作者、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteAuthor 根据作者、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteAuthor(es *elasticsearch.Client, author string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtAuthor 根据作者、价格大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtAuthor(es *elasticsearch.Client, author string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtAuthor 根据作者、价格小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtAuthor(es *elasticsearch.Client, author string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteAuthor 根据作者、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteAuthor(es *elasticsearch.Client, author string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteAuthor 根据作者、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteAuthor(es *elasticsearch.Client, author string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteAuthor 根据作者、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteAuthor(es *elasticsearch.Client, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtAuthor 根据作者、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtAuthor(es *elasticsearch.Client, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtAuthor 根据作者、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtAuthor(es *elasticsearch.Client, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteAuthor 根据作者、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteAuthor(es *elasticsearch.Client, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthor 根据作者、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteAuthor 根据作者、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteAuthor(es *elasticsearch.Client, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtAuthor 根据作者、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtAuthor(es *elasticsearch.Client, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtAuthor 根据作者、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtAuthor(es *elasticsearch.Client, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteAuthor 根据作者、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteAuthor(es *elasticsearch.Client, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteAuthor 根据作者、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteAuthor 根据作者、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteAuthor(es *elasticsearch.Client, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtAuthor 根据作者、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtAuthor(es *elasticsearch.Client, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtAuthor 根据作者、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtAuthor(es *elasticsearch.Client, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteAuthor 根据作者、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteAuthor(es *elasticsearch.Client, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteAuthor 根据作者、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteAuthor 根据作者、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteAuthor(es *elasticsearch.Client, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtAuthor 根据作者、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtAuthor(es *elasticsearch.Client, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtAuthor 根据作者、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtAuthor(es *elasticsearch.Client, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteAuthor 根据作者、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteAuthor(es *elasticsearch.Client, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteAuthor 根据作者、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteClass 根据类别、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteClass(es *elasticsearch.Client, class string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtClass 根据类别、页数大于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtClass(es *elasticsearch.Client, class string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtClass 根据类别、页数小于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtClass(es *elasticsearch.Client, class string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteClass 根据类别、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteClass(es *elasticsearch.Client, class string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteClass 根据类别、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteClass 根据类别、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteClass(es *elasticsearch.Client, class string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtClass 根据类别、价格大于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtClass(es *elasticsearch.Client, class string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtClass 根据类别、价格小于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtClass(es *elasticsearch.Client, class string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteClass 根据类别、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteClass(es *elasticsearch.Client, class string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteClass 根据类别、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteClass(es *elasticsearch.Client, class string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteClass 根据类别、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteClass(es *elasticsearch.Client, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtClass 根据类别、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtClass(es *elasticsearch.Client, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtClass 根据类别、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtClass(es *elasticsearch.Client, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteClass 根据类别、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteClass(es *elasticsearch.Client, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteClass 根据类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteClass(es *elasticsearch.Client, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteClass 根据类别、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteClass(es *elasticsearch.Client, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtClass 根据类别、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtClass(es *elasticsearch.Client, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtClass 根据类别、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtClass(es *elasticsearch.Client, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteClass 根据类别、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteClass(es *elasticsearch.Client, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteClass 根据类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteClass(es *elasticsearch.Client, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteClass 根据类别、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteClass(es *elasticsearch.Client, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtClass 根据类别、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtClass(es *elasticsearch.Client, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtClass 根据类别、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtClass(es *elasticsearch.Client, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteClass 根据类别、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteClass(es *elasticsearch.Client, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteClass 根据类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteClass(es *elasticsearch.Client, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteClass 根据类别、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteClass(es *elasticsearch.Client, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtClass 根据类别、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtClass(es *elasticsearch.Client, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtClass 根据类别、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtClass(es *elasticsearch.Client, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteClass 根据类别、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteClass(es *elasticsearch.Client, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteClass 根据类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteClass(es *elasticsearch.Client, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteClass2 根据子类别、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtClass2 根据子类别、页数大于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtClass2 根据子类别、页数小于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteClass2 根据子类别、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteClass2 根据子类别、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteClass2 根据子类别、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteClass2(es *elasticsearch.Client, class2 string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtClass2 根据子类别、价格大于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtClass2(es *elasticsearch.Client, class2 string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtClass2 根据子类别、价格小于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtClass2(es *elasticsearch.Client, class2 string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteClass2 根据子类别、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteClass2(es *elasticsearch.Client, class2 string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteClass2 根据子类别、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteClass2 根据子类别、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteClass2(es *elasticsearch.Client, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtClass2 根据子类别、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtClass2(es *elasticsearch.Client, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtClass2 根据子类别、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtClass2(es *elasticsearch.Client, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteClass2 根据子类别、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteClass2(es *elasticsearch.Client, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteClass2 根据子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteClass2 根据子类别、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteClass2(es *elasticsearch.Client, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtClass2 根据子类别、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtClass2(es *elasticsearch.Client, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtClass2 根据子类别、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtClass2(es *elasticsearch.Client, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteClass2 根据子类别、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteClass2(es *elasticsearch.Client, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteClass2 根据子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteClass2 根据子类别、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteClass2(es *elasticsearch.Client, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtClass2 根据子类别、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtClass2(es *elasticsearch.Client, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtClass2 根据子类别、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtClass2(es *elasticsearch.Client, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteClass2 根据子类别、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteClass2(es *elasticsearch.Client, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteClass2 根据子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteClass2 根据子类别、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteClass2(es *elasticsearch.Client, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtClass2 根据子类别、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtClass2(es *elasticsearch.Client, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtClass2 根据子类别、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtClass2(es *elasticsearch.Client, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteClass2 根据子类别、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteClass2(es *elasticsearch.Client, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteClass2 根据子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteName 根据书名、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteName(es *elasticsearch.Client, name string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtName 根据书名、页数大于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtName(es *elasticsearch.Client, name string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtName 根据书名、页数小于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtName(es *elasticsearch.Client, name string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteName 根据书名、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteName(es *elasticsearch.Client, name string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteName 根据书名、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteName 根据书名、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteName(es *elasticsearch.Client, name string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtName 根据书名、价格大于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtName(es *elasticsearch.Client, name string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtName 根据书名、价格小于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtName(es *elasticsearch.Client, name string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteName 根据书名、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteName(es *elasticsearch.Client, name string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteName 根据书名、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteName(es *elasticsearch.Client, name string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteName 根据书名、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteName(es *elasticsearch.Client, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtName 根据书名、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtName(es *elasticsearch.Client, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtName 根据书名、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtName(es *elasticsearch.Client, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteName 根据书名、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteName(es *elasticsearch.Client, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteName 根据书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteName(es *elasticsearch.Client, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteName 根据书名、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteName(es *elasticsearch.Client, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtName 根据书名、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtName(es *elasticsearch.Client, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtName 根据书名、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtName(es *elasticsearch.Client, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteName 根据书名、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteName(es *elasticsearch.Client, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteName 根据书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteName(es *elasticsearch.Client, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteName 根据书名、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteName(es *elasticsearch.Client, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtName 根据书名、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtName(es *elasticsearch.Client, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtName 根据书名、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtName(es *elasticsearch.Client, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteName 根据书名、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteName(es *elasticsearch.Client, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteName 根据书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteName(es *elasticsearch.Client, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteName 根据书名、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteName(es *elasticsearch.Client, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtName 根据书名、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtName(es *elasticsearch.Client, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtName 根据书名、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtName(es *elasticsearch.Client, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteName 根据书名、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteName(es *elasticsearch.Client, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteName 根据书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteName(es *elasticsearch.Client, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGte 根据页数大于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGte(es *elasticsearch.Client, pageCountGte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGt 根据页数大于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGt(es *elasticsearch.Client, pageCountGte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLt 根据页数大于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLt(es *elasticsearch.Client, pageCountGte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLte 根据页数大于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLte(es *elasticsearch.Client, pageCountGte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLte 根据页数大于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLte(es *elasticsearch.Client, pageCountGte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGte 根据页数大于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGte(es *elasticsearch.Client, pageCountGt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGt 根据页数大于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGt(es *elasticsearch.Client, pageCountGt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLt 根据页数大于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLt(es *elasticsearch.Client, pageCountGt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLte 根据页数大于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLte(es *elasticsearch.Client, pageCountGt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLte 根据页数大于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLte(es *elasticsearch.Client, pageCountGt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGte 根据页数小于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGte(es *elasticsearch.Client, pageCountLt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGt 根据页数小于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGt(es *elasticsearch.Client, pageCountLt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLt 根据页数小于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLt(es *elasticsearch.Client, pageCountLt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLte 根据页数小于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLte(es *elasticsearch.Client, pageCountLt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLte 根据页数小于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLte(es *elasticsearch.Client, pageCountLt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGte 根据页数小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGte(es *elasticsearch.Client, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGt 根据页数小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGt(es *elasticsearch.Client, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLt 根据页数小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLt(es *elasticsearch.Client, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLte 根据页数小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLte(es *elasticsearch.Client, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLte 根据页数小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLte(es *elasticsearch.Client, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGte 根据页数大于等于和小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGt 根据页数大于等于和小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGt(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLt 根据页数大于等于和小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLt(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLte 根据页数大于等于和小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLte 根据页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteSeq 根据编号、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteSeq(es *elasticsearch.Client, seq string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtSeq 根据编号、页数大于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtSeq(es *elasticsearch.Client, seq string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtSeq 根据编号、页数小于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtSeq(es *elasticsearch.Client, seq string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteSeq 根据编号、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteSeq(es *elasticsearch.Client, seq string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteSeq 根据编号、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGte 根据价格大于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGte(es *elasticsearch.Client, priceGte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGt 根据价格大于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGt(es *elasticsearch.Client, priceGte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLt 根据价格大于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLt(es *elasticsearch.Client, priceGte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLte 根据价格大于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLte(es *elasticsearch.Client, priceGte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLte 根据价格大于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLte(es *elasticsearch.Client, priceGte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGte 根据价格大于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGte(es *elasticsearch.Client, priceGt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGt 根据价格大于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGt(es *elasticsearch.Client, priceGt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLt 根据价格大于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLt(es *elasticsearch.Client, priceGt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLte 根据价格大于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLte(es *elasticsearch.Client, priceGt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLte 根据价格大于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLte(es *elasticsearch.Client, priceGt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGte 根据价格小于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGte(es *elasticsearch.Client, priceLt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGt 根据价格小于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGt(es *elasticsearch.Client, priceLt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLt 根据价格小于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLt(es *elasticsearch.Client, priceLt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLte 根据价格小于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLte(es *elasticsearch.Client, priceLt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLte 根据价格小于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLte(es *elasticsearch.Client, priceLt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGte 根据价格小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGte(es *elasticsearch.Client, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGt 根据价格小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGt(es *elasticsearch.Client, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLt 根据价格小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLt(es *elasticsearch.Client, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLte 根据价格小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLte(es *elasticsearch.Client, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLte 根据价格小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLte(es *elasticsearch.Client, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGte 根据价格大于等于和小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGt 根据价格大于等于和小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGt(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLt 根据价格大于等于和小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLt(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLte 根据价格大于等于和小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLte 根据价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteSeq 根据编号、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteSeq(es *elasticsearch.Client, seq string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtSeq 根据编号、价格大于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtSeq(es *elasticsearch.Client, seq string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtSeq 根据编号、价格小于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtSeq(es *elasticsearch.Client, seq string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteSeq 根据编号、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteSeq(es *elasticsearch.Client, seq string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteSeq 根据编号、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteSeq(es *elasticsearch.Client, seq string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteSeq 根据编号、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteSeq(es *elasticsearch.Client, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtSeq 根据编号、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtSeq(es *elasticsearch.Client, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtSeq 根据编号、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtSeq(es *elasticsearch.Client, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteSeq 根据编号、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteSeq(es *elasticsearch.Client, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteSeq 根据编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteSeq 根据编号、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteSeq(es *elasticsearch.Client, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtSeq 根据编号、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtSeq(es *elasticsearch.Client, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtSeq 根据编号、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtSeq(es *elasticsearch.Client, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteSeq 根据编号、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteSeq(es *elasticsearch.Client, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteSeq 根据编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteSeq 根据编号、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteSeq(es *elasticsearch.Client, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtSeq 根据编号、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtSeq(es *elasticsearch.Client, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtSeq 根据编号、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtSeq(es *elasticsearch.Client, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteSeq 根据编号、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteSeq(es *elasticsearch.Client, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteSeq 根据编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteSeq 根据编号、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteSeq(es *elasticsearch.Client, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtSeq 根据编号、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtSeq(es *elasticsearch.Client, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtSeq 根据编号、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtSeq(es *elasticsearch.Client, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteSeq 根据编号、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteSeq(es *elasticsearch.Client, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteSeq 根据编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteAllTextAuthor 根据全文本、作者、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtAllTextAuthor 根据全文本、作者、页数大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtAllTextAuthor 根据全文本、作者、页数小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteAllTextAuthor 根据全文本、作者、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteAllTextAuthor 根据全文本、作者、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteAllTextAuthor 根据全文本、作者、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteAllTextAuthor(es *elasticsearch.Client, allText, author string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtAllTextAuthor 根据全文本、作者、价格大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtAllTextAuthor(es *elasticsearch.Client, allText, author string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtAllTextAuthor 根据全文本、作者、价格小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtAllTextAuthor(es *elasticsearch.Client, allText, author string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteAllTextAuthor 根据全文本、作者、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteAllTextAuthor(es *elasticsearch.Client, allText, author string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteAllTextAuthor 根据全文本、作者、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteAllTextAuthor 根据全文本、作者、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtAllTextAuthor 根据全文本、作者、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtAllTextAuthor 根据全文本、作者、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteAllTextAuthor 根据全文本、作者、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextAuthor 根据全文本、作者、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteAllTextAuthor 根据全文本、作者、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtAllTextAuthor 根据全文本、作者、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtAllTextAuthor 根据全文本、作者、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteAllTextAuthor 根据全文本、作者、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextAuthor 根据全文本、作者、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteAllTextAuthor 根据全文本、作者、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtAllTextAuthor 根据全文本、作者、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtAllTextAuthor 根据全文本、作者、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteAllTextAuthor 根据全文本、作者、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextAuthor 根据全文本、作者、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteAllTextAuthor 根据全文本、作者、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtAllTextAuthor 根据全文本、作者、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtAllTextAuthor 根据全文本、作者、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteAllTextAuthor 根据全文本、作者、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteAllTextAuthor 根据全文本、作者、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteAllTextClass 根据全文本、类别、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteAllTextClass(es *elasticsearch.Client, allText, class string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtAllTextClass 根据全文本、类别、页数大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtAllTextClass(es *elasticsearch.Client, allText, class string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtAllTextClass 根据全文本、类别、页数小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtAllTextClass(es *elasticsearch.Client, allText, class string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteAllTextClass 根据全文本、类别、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteAllTextClass(es *elasticsearch.Client, allText, class string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteAllTextClass 根据全文本、类别、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteAllTextClass(es *elasticsearch.Client, allText, class string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteAllTextClass 根据全文本、类别、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteAllTextClass(es *elasticsearch.Client, allText, class string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtAllTextClass 根据全文本、类别、价格大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtAllTextClass(es *elasticsearch.Client, allText, class string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtAllTextClass 根据全文本、类别、价格小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtAllTextClass(es *elasticsearch.Client, allText, class string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteAllTextClass 根据全文本、类别、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteAllTextClass(es *elasticsearch.Client, allText, class string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteAllTextClass 根据全文本、类别、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteAllTextClass(es *elasticsearch.Client, allText, class string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteAllTextClass 根据全文本、类别、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtAllTextClass 根据全文本、类别、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtAllTextClass 根据全文本、类别、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteAllTextClass 根据全文本、类别、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextClass 根据全文本、类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteAllTextClass 根据全文本、类别、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtAllTextClass 根据全文本、类别、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtAllTextClass 根据全文本、类别、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteAllTextClass 根据全文本、类别、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextClass 根据全文本、类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteAllTextClass 根据全文本、类别、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtAllTextClass 根据全文本、类别、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtAllTextClass 根据全文本、类别、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteAllTextClass 根据全文本、类别、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextClass 根据全文本、类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteAllTextClass 根据全文本、类别、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtAllTextClass 根据全文本、类别、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtAllTextClass 根据全文本、类别、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteAllTextClass 根据全文本、类别、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteAllTextClass 根据全文本、类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteAllTextClass2 根据全文本、子类别、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtAllTextClass2 根据全文本、子类别、页数大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtAllTextClass2 根据全文本、子类别、页数小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteAllTextClass2 根据全文本、子类别、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteAllTextClass2 根据全文本、子类别、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteAllTextClass2 根据全文本、子类别、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtAllTextClass2 根据全文本、子类别、价格大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtAllTextClass2 根据全文本、子类别、价格小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteAllTextClass2 根据全文本、子类别、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteAllTextClass2 根据全文本、子类别、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteAllTextClass2 根据全文本、子类别、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtAllTextClass2 根据全文本、子类别、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtAllTextClass2 根据全文本、子类别、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteAllTextClass2 根据全文本、子类别、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextClass2 根据全文本、子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteAllTextClass2 根据全文本、子类别、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtAllTextClass2 根据全文本、子类别、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtAllTextClass2 根据全文本、子类别、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteAllTextClass2 根据全文本、子类别、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextClass2 根据全文本、子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteAllTextClass2 根据全文本、子类别、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtAllTextClass2 根据全文本、子类别、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtAllTextClass2 根据全文本、子类别、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteAllTextClass2 根据全文本、子类别、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextClass2 根据全文本、子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteAllTextClass2 根据全文本、子类别、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtAllTextClass2 根据全文本、子类别、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtAllTextClass2 根据全文本、子类别、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteAllTextClass2 根据全文本、子类别、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteAllTextClass2 根据全文本、子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteAllTextName 根据全文本、书名、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteAllTextName(es *elasticsearch.Client, allText, name string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtAllTextName 根据全文本、书名、页数大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtAllTextName(es *elasticsearch.Client, allText, name string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtAllTextName 根据全文本、书名、页数小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtAllTextName(es *elasticsearch.Client, allText, name string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteAllTextName 根据全文本、书名、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteAllTextName(es *elasticsearch.Client, allText, name string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteAllTextName 根据全文本、书名、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteAllTextName(es *elasticsearch.Client, allText, name string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteAllTextName 根据全文本、书名、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteAllTextName(es *elasticsearch.Client, allText, name string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtAllTextName 根据全文本、书名、价格大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtAllTextName(es *elasticsearch.Client, allText, name string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtAllTextName 根据全文本、书名、价格小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtAllTextName(es *elasticsearch.Client, allText, name string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteAllTextName 根据全文本、书名、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteAllTextName(es *elasticsearch.Client, allText, name string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteAllTextName 根据全文本、书名、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteAllTextName(es *elasticsearch.Client, allText, name string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteAllTextName 根据全文本、书名、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtAllTextName 根据全文本、书名、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtAllTextName 根据全文本、书名、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteAllTextName 根据全文本、书名、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextName 根据全文本、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteAllTextName 根据全文本、书名、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtAllTextName 根据全文本、书名、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtAllTextName 根据全文本、书名、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteAllTextName 根据全文本、书名、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextName 根据全文本、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteAllTextName 根据全文本、书名、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtAllTextName 根据全文本、书名、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtAllTextName 根据全文本、书名、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteAllTextName 根据全文本、书名、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextName 根据全文本、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteAllTextName 根据全文本、书名、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtAllTextName 根据全文本、书名、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtAllTextName 根据全文本、书名、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteAllTextName 根据全文本、书名、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteAllTextName 根据全文本、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteAllText 根据全文本、页数大于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGtAllText 根据全文本、页数大于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLtAllText 根据全文本、页数大于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLteAllText 根据全文本、页数大于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteAllText 根据全文本、页数大于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteAllText 根据全文本、页数大于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGtAllText 根据全文本、页数大于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLtAllText 根据全文本、页数大于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLteAllText 根据全文本、页数大于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteAllText 根据全文本、页数大于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteAllText 根据全文本、页数小于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGtAllText 根据全文本、页数小于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLtAllText 根据全文本、页数小于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLteAllText 根据全文本、页数小于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteAllText 根据全文本、页数小于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteAllText 根据全文本、页数小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGtAllText 根据全文本、页数小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLtAllText 根据全文本、页数小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLteAllText 根据全文本、页数小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteAllText 根据全文本、页数小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteAllText 根据全文本、页数大于等于和小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtAllText 根据全文本、页数大于等于和小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtAllText 根据全文本、页数大于等于和小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteAllText 根据全文本、页数大于等于和小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteAllText 根据全文本、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteAllTextSeq 根据全文本、编号、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtAllTextSeq 根据全文本、编号、页数大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtAllTextSeq 根据全文本、编号、页数小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteAllTextSeq 根据全文本、编号、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteAllTextSeq 根据全文本、编号、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteAllText 根据全文本、价格大于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtAllText 根据全文本、价格大于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtAllText 根据全文本、价格大于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteAllText 根据全文本、价格大于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteAllText 根据全文本、价格大于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteAllText 根据全文本、价格大于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtAllText 根据全文本、价格大于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtAllText 根据全文本、价格大于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteAllText 根据全文本、价格大于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteAllText 根据全文本、价格大于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteAllText 根据全文本、价格小于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtAllText 根据全文本、价格小于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtAllText 根据全文本、价格小于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteAllText 根据全文本、价格小于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteAllText 根据全文本、价格小于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteAllText 根据全文本、价格小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtAllText 根据全文本、价格小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtAllText 根据全文本、价格小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteAllText 根据全文本、价格小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteAllText 根据全文本、价格小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteAllText 根据全文本、价格大于等于和小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtAllText 根据全文本、价格大于等于和小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtAllText 根据全文本、价格大于等于和小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteAllText 根据全文本、价格大于等于和小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteAllText 根据全文本、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteAllTextSeq 根据全文本、编号、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteAllTextSeq(es *elasticsearch.Client, allText, seq string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtAllTextSeq 根据全文本、编号、价格大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtAllTextSeq(es *elasticsearch.Client, allText, seq string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtAllTextSeq 根据全文本、编号、价格小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtAllTextSeq(es *elasticsearch.Client, allText, seq string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteAllTextSeq 根据全文本、编号、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteAllTextSeq(es *elasticsearch.Client, allText, seq string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteAllTextSeq 根据全文本、编号、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteAllTextSeq 根据全文本、编号、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtAllTextSeq 根据全文本、编号、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtAllTextSeq 根据全文本、编号、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteAllTextSeq 根据全文本、编号、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextSeq 根据全文本、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteAllTextSeq 根据全文本、编号、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtAllTextSeq 根据全文本、编号、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtAllTextSeq 根据全文本、编号、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteAllTextSeq 根据全文本、编号、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextSeq 根据全文本、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteAllTextSeq 根据全文本、编号、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtAllTextSeq 根据全文本、编号、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtAllTextSeq 根据全文本、编号、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteAllTextSeq 根据全文本、编号、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextSeq 根据全文本、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteAllTextSeq 根据全文本、编号、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtAllTextSeq 根据全文本、编号、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtAllTextSeq 根据全文本、编号、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteAllTextSeq 根据全文本、编号、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteAllTextSeq 根据全文本、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteAuthorClass 根据作者、类别、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class string 类别
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteAuthorClass(es *elasticsearch.Client, author, class string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtAuthorClass 根据作者、类别、页数大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class string 类别
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtAuthorClass(es *elasticsearch.Client, author, class string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtAuthorClass 根据作者、类别、页数小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class string 类别
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtAuthorClass(es *elasticsearch.Client, author, class string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteAuthorClass 根据作者、类别、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class string 类别
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteAuthorClass(es *elasticsearch.Client, author, class string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteAuthorClass 根据作者、类别、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteAuthorClass(es *elasticsearch.Client, author, class string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteAuthorClass 根据作者、类别、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class string 类别
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteAuthorClass(es *elasticsearch.Client, author, class string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtAuthorClass 根据作者、类别、价格大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class string 类别
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtAuthorClass(es *elasticsearch.Client, author, class string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtAuthorClass 根据作者、类别、价格小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class string 类别
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtAuthorClass(es *elasticsearch.Client, author, class string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteAuthorClass 根据作者、类别、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class string 类别
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteAuthorClass(es *elasticsearch.Client, author, class string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteAuthorClass 根据作者、类别、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteAuthorClass(es *elasticsearch.Client, author, class string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteAuthorClass 根据作者、类别、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtAuthorClass 根据作者、类别、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtAuthorClass 根据作者、类别、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteAuthorClass 根据作者、类别、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorClass 根据作者、类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteAuthorClass 根据作者、类别、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtAuthorClass 根据作者、类别、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtAuthorClass 根据作者、类别、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteAuthorClass 根据作者、类别、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorClass 根据作者、类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteAuthorClass 根据作者、类别、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtAuthorClass 根据作者、类别、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtAuthorClass 根据作者、类别、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteAuthorClass 根据作者、类别、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorClass 根据作者、类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteAuthorClass 根据作者、类别、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtAuthorClass 根据作者、类别、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtAuthorClass 根据作者、类别、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteAuthorClass 根据作者、类别、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteAuthorClass 根据作者、类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteAuthorClass2 根据作者、子类别、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtAuthorClass2 根据作者、子类别、页数大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtAuthorClass2 根据作者、子类别、页数小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteAuthorClass2 根据作者、子类别、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteAuthorClass2 根据作者、子类别、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteAuthorClass2 根据作者、子类别、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteAuthorClass2(es *elasticsearch.Client, author, class2 string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtAuthorClass2 根据作者、子类别、价格大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtAuthorClass2(es *elasticsearch.Client, author, class2 string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtAuthorClass2 根据作者、子类别、价格小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtAuthorClass2(es *elasticsearch.Client, author, class2 string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteAuthorClass2 根据作者、子类别、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteAuthorClass2(es *elasticsearch.Client, author, class2 string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteAuthorClass2 根据作者、子类别、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteAuthorClass2 根据作者、子类别、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtAuthorClass2 根据作者、子类别、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtAuthorClass2 根据作者、子类别、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteAuthorClass2 根据作者、子类别、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorClass2 根据作者、子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteAuthorClass2 根据作者、子类别、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtAuthorClass2 根据作者、子类别、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtAuthorClass2 根据作者、子类别、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteAuthorClass2 根据作者、子类别、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorClass2 根据作者、子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteAuthorClass2 根据作者、子类别、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtAuthorClass2 根据作者、子类别、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtAuthorClass2 根据作者、子类别、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteAuthorClass2 根据作者、子类别、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorClass2 根据作者、子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteAuthorClass2 根据作者、子类别、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtAuthorClass2 根据作者、子类别、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtAuthorClass2 根据作者、子类别、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteAuthorClass2 根据作者、子类别、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteAuthorClass2 根据作者、子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteAuthorName 根据作者、书名、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// name string 书名
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteAuthorName(es *elasticsearch.Client, author, name string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtAuthorName 根据作者、书名、页数大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// name string 书名
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtAuthorName(es *elasticsearch.Client, author, name string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtAuthorName 根据作者、书名、页数小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// name string 书名
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtAuthorName(es *elasticsearch.Client, author, name string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteAuthorName 根据作者、书名、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// name string 书名
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteAuthorName(es *elasticsearch.Client, author, name string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteAuthorName 根据作者、书名、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteAuthorName(es *elasticsearch.Client, author, name string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteAuthorName 根据作者、书名、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// name string 书名
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteAuthorName(es *elasticsearch.Client, author, name string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtAuthorName 根据作者、书名、价格大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// name string 书名
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtAuthorName(es *elasticsearch.Client, author, name string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtAuthorName 根据作者、书名、价格小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// name string 书名
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtAuthorName(es *elasticsearch.Client, author, name string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteAuthorName 根据作者、书名、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// name string 书名
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteAuthorName(es *elasticsearch.Client, author, name string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteAuthorName 根据作者、书名、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteAuthorName(es *elasticsearch.Client, author, name string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteAuthorName 根据作者、书名、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtAuthorName 根据作者、书名、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtAuthorName(es *elasticsearch.Client, author, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtAuthorName 根据作者、书名、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtAuthorName(es *elasticsearch.Client, author, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteAuthorName 根据作者、书名、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorName 根据作者、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteAuthorName 根据作者、书名、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtAuthorName 根据作者、书名、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtAuthorName(es *elasticsearch.Client, author, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtAuthorName 根据作者、书名、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtAuthorName(es *elasticsearch.Client, author, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteAuthorName 根据作者、书名、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorName 根据作者、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteAuthorName 根据作者、书名、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtAuthorName 根据作者、书名、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtAuthorName(es *elasticsearch.Client, author, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtAuthorName 根据作者、书名、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtAuthorName(es *elasticsearch.Client, author, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteAuthorName 根据作者、书名、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorName 根据作者、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteAuthorName 根据作者、书名、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtAuthorName 根据作者、书名、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtAuthorName(es *elasticsearch.Client, author, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtAuthorName 根据作者、书名、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtAuthorName(es *elasticsearch.Client, author, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteAuthorName 根据作者、书名、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteAuthorName 根据作者、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteAuthor 根据作者、页数大于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGtAuthor 根据作者、页数大于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLtAuthor 根据作者、页数大于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLteAuthor 根据作者、页数大于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteAuthor 根据作者、页数大于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteAuthor 根据作者、页数大于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGtAuthor 根据作者、页数大于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLtAuthor 根据作者、页数大于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLteAuthor 根据作者、页数大于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteAuthor 根据作者、页数大于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteAuthor 根据作者、页数小于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGtAuthor 根据作者、页数小于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLtAuthor 根据作者、页数小于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLteAuthor 根据作者、页数小于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteAuthor 根据作者、页数小于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteAuthor 根据作者、页数小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGtAuthor 根据作者、页数小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLtAuthor 根据作者、页数小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLteAuthor 根据作者、页数小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteAuthor 根据作者、页数小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteAuthor 根据作者、页数大于等于和小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtAuthor 根据作者、页数大于等于和小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtAuthor 根据作者、页数大于等于和小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteAuthor 根据作者、页数大于等于和小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteAuthor 根据作者、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteAuthorSeq 根据作者、编号、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtAuthorSeq 根据作者、编号、页数大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtAuthorSeq 根据作者、编号、页数小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteAuthorSeq 根据作者、编号、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteAuthorSeq 根据作者、编号、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteAuthor 根据作者、价格大于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtAuthor 根据作者、价格大于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtAuthor 根据作者、价格大于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteAuthor 根据作者、价格大于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteAuthor 根据作者、价格大于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteAuthor 根据作者、价格大于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtAuthor 根据作者、价格大于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtAuthor 根据作者、价格大于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteAuthor 根据作者、价格大于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteAuthor 根据作者、价格大于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteAuthor 根据作者、价格小于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtAuthor 根据作者、价格小于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtAuthor 根据作者、价格小于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteAuthor 根据作者、价格小于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteAuthor 根据作者、价格小于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteAuthor 根据作者、价格小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtAuthor 根据作者、价格小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtAuthor 根据作者、价格小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteAuthor 根据作者、价格小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteAuthor 根据作者、价格小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteAuthor 根据作者、价格大于等于和小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtAuthor 根据作者、价格大于等于和小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtAuthor 根据作者、价格大于等于和小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteAuthor 根据作者、价格大于等于和小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteAuthor 根据作者、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteAuthorSeq 根据作者、编号、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteAuthorSeq(es *elasticsearch.Client, author, seq string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtAuthorSeq 根据作者、编号、价格大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtAuthorSeq(es *elasticsearch.Client, author, seq string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtAuthorSeq 根据作者、编号、价格小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtAuthorSeq(es *elasticsearch.Client, author, seq string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteAuthorSeq 根据作者、编号、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteAuthorSeq(es *elasticsearch.Client, author, seq string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteAuthorSeq 根据作者、编号、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteAuthorSeq 根据作者、编号、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtAuthorSeq 根据作者、编号、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtAuthorSeq 根据作者、编号、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteAuthorSeq 根据作者、编号、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorSeq 根据作者、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteAuthorSeq 根据作者、编号、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtAuthorSeq 根据作者、编号、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtAuthorSeq 根据作者、编号、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteAuthorSeq 根据作者、编号、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorSeq 根据作者、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteAuthorSeq 根据作者、编号、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtAuthorSeq 根据作者、编号、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtAuthorSeq 根据作者、编号、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteAuthorSeq 根据作者、编号、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorSeq 根据作者、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteAuthorSeq 根据作者、编号、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtAuthorSeq 根据作者、编号、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtAuthorSeq 根据作者、编号、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteAuthorSeq 根据作者、编号、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteAuthorSeq 根据作者、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteClassClass2 根据类别、子类别、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteClassClass2(es *elasticsearch.Client, class, class2 string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtClassClass2 根据类别、子类别、页数大于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtClassClass2(es *elasticsearch.Client, class, class2 string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtClassClass2 根据类别、子类别、页数小于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtClassClass2(es *elasticsearch.Client, class, class2 string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteClassClass2 根据类别、子类别、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteClassClass2(es *elasticsearch.Client, class, class2 string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteClassClass2 根据类别、子类别、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteClassClass2(es *elasticsearch.Client, class, class2 string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteClassClass2 根据类别、子类别、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteClassClass2(es *elasticsearch.Client, class, class2 string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtClassClass2 根据类别、子类别、价格大于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtClassClass2(es *elasticsearch.Client, class, class2 string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtClassClass2 根据类别、子类别、价格小于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtClassClass2(es *elasticsearch.Client, class, class2 string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteClassClass2 根据类别、子类别、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteClassClass2(es *elasticsearch.Client, class, class2 string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteClassClass2 根据类别、子类别、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteClassClass2(es *elasticsearch.Client, class, class2 string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteClassClass2 根据类别、子类别、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtClassClass2 根据类别、子类别、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtClassClass2 根据类别、子类别、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteClassClass2 根据类别、子类别、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteClassClass2 根据类别、子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteClassClass2 根据类别、子类别、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtClassClass2 根据类别、子类别、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtClassClass2 根据类别、子类别、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteClassClass2 根据类别、子类别、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteClassClass2 根据类别、子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteClassClass2 根据类别、子类别、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtClassClass2 根据类别、子类别、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtClassClass2 根据类别、子类别、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteClassClass2 根据类别、子类别、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteClassClass2 根据类别、子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteClassClass2 根据类别、子类别、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtClassClass2 根据类别、子类别、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtClassClass2 根据类别、子类别、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteClassClass2 根据类别、子类别、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteClassClass2 根据类别、子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteClassName 根据类别、书名、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// name string 书名
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteClassName(es *elasticsearch.Client, class, name string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtClassName 根据类别、书名、页数大于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// name string 书名
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtClassName(es *elasticsearch.Client, class, name string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtClassName 根据类别、书名、页数小于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// name string 书名
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtClassName(es *elasticsearch.Client, class, name string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteClassName 根据类别、书名、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// name string 书名
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteClassName(es *elasticsearch.Client, class, name string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteClassName 根据类别、书名、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteClassName(es *elasticsearch.Client, class, name string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteClassName 根据类别、书名、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// name string 书名
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteClassName(es *elasticsearch.Client, class, name string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtClassName 根据类别、书名、价格大于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// name string 书名
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtClassName(es *elasticsearch.Client, class, name string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtClassName 根据类别、书名、价格小于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// name string 书名
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtClassName(es *elasticsearch.Client, class, name string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteClassName 根据类别、书名、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// name string 书名
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteClassName(es *elasticsearch.Client, class, name string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteClassName 根据类别、书名、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteClassName(es *elasticsearch.Client, class, name string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteClassName 根据类别、书名、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteClassName(es *elasticsearch.Client, class, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtClassName 根据类别、书名、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtClassName(es *elasticsearch.Client, class, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtClassName 根据类别、书名、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtClassName(es *elasticsearch.Client, class, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteClassName 根据类别、书名、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteClassName(es *elasticsearch.Client, class, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteClassName 根据类别、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteClassName(es *elasticsearch.Client, class, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteClassName 根据类别、书名、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteClassName(es *elasticsearch.Client, class, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtClassName 根据类别、书名、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtClassName(es *elasticsearch.Client, class, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtClassName 根据类别、书名、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtClassName(es *elasticsearch.Client, class, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteClassName 根据类别、书名、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteClassName(es *elasticsearch.Client, class, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteClassName 根据类别、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteClassName(es *elasticsearch.Client, class, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteClassName 根据类别、书名、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteClassName(es *elasticsearch.Client, class, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtClassName 根据类别、书名、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtClassName(es *elasticsearch.Client, class, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtClassName 根据类别、书名、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtClassName(es *elasticsearch.Client, class, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteClassName 根据类别、书名、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteClassName(es *elasticsearch.Client, class, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteClassName 根据类别、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteClassName(es *elasticsearch.Client, class, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteClassName 根据类别、书名、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteClassName(es *elasticsearch.Client, class, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtClassName 根据类别、书名、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtClassName(es *elasticsearch.Client, class, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtClassName 根据类别、书名、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtClassName(es *elasticsearch.Client, class, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteClassName 根据类别、书名、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteClassName(es *elasticsearch.Client, class, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteClassName 根据类别、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteClassName(es *elasticsearch.Client, class, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteClass 根据类别、页数大于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGtClass 根据类别、页数大于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLtClass 根据类别、页数大于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLteClass 根据类别、页数大于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteClass 根据类别、页数大于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteClass 根据类别、页数大于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGtClass 根据类别、页数大于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLtClass 根据类别、页数大于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLteClass 根据类别、页数大于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteClass 根据类别、页数大于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteClass 根据类别、页数小于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGtClass 根据类别、页数小于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLtClass 根据类别、页数小于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLteClass 根据类别、页数小于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteClass 根据类别、页数小于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteClass 根据类别、页数小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGtClass 根据类别、页数小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLtClass 根据类别、页数小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLteClass 根据类别、页数小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteClass 根据类别、页数小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteClass 根据类别、页数大于等于和小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtClass 根据类别、页数大于等于和小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtClass 根据类别、页数大于等于和小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteClass 根据类别、页数大于等于和小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteClass 根据类别、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteClassSeq 根据类别、编号、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteClassSeq(es *elasticsearch.Client, class, seq string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtClassSeq 根据类别、编号、页数大于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtClassSeq(es *elasticsearch.Client, class, seq string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtClassSeq 根据类别、编号、页数小于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtClassSeq(es *elasticsearch.Client, class, seq string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteClassSeq 根据类别、编号、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteClassSeq(es *elasticsearch.Client, class, seq string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteClassSeq 根据类别、编号、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteClassSeq(es *elasticsearch.Client, class, seq string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteClass 根据类别、价格大于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtClass 根据类别、价格大于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtClass 根据类别、价格大于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteClass 根据类别、价格大于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteClass 根据类别、价格大于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteClass 根据类别、价格大于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtClass 根据类别、价格大于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtClass 根据类别、价格大于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteClass 根据类别、价格大于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteClass 根据类别、价格大于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteClass 根据类别、价格小于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtClass 根据类别、价格小于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtClass 根据类别、价格小于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteClass 根据类别、价格小于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteClass 根据类别、价格小于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteClass 根据类别、价格小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtClass 根据类别、价格小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtClass 根据类别、价格小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteClass 根据类别、价格小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteClass 根据类别、价格小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteClass 根据类别、价格大于等于和小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtClass 根据类别、价格大于等于和小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtClass 根据类别、价格大于等于和小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteClass 根据类别、价格大于等于和小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteClass 根据类别、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteClassSeq 根据类别、编号、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteClassSeq(es *elasticsearch.Client, class, seq string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtClassSeq 根据类别、编号、价格大于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtClassSeq(es *elasticsearch.Client, class, seq string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtClassSeq 根据类别、编号、价格小于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtClassSeq(es *elasticsearch.Client, class, seq string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteClassSeq 根据类别、编号、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteClassSeq(es *elasticsearch.Client, class, seq string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteClassSeq 根据类别、编号、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteClassSeq(es *elasticsearch.Client, class, seq string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteClassSeq 根据类别、编号、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtClassSeq 根据类别、编号、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtClassSeq 根据类别、编号、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteClassSeq 根据类别、编号、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteClassSeq 根据类别、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteClassSeq 根据类别、编号、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtClassSeq 根据类别、编号、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtClassSeq 根据类别、编号、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteClassSeq 根据类别、编号、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteClassSeq 根据类别、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteClassSeq 根据类别、编号、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtClassSeq 根据类别、编号、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtClassSeq 根据类别、编号、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteClassSeq 根据类别、编号、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteClassSeq 根据类别、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteClassSeq 根据类别、编号、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtClassSeq 根据类别、编号、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtClassSeq 根据类别、编号、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteClassSeq 根据类别、编号、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteClassSeq 根据类别、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteClass2Name 根据子类别、书名、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteClass2Name(es *elasticsearch.Client, class2, name string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtClass2Name 根据子类别、书名、页数大于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtClass2Name(es *elasticsearch.Client, class2, name string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtClass2Name 根据子类别、书名、页数小于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtClass2Name(es *elasticsearch.Client, class2, name string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteClass2Name 根据子类别、书名、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteClass2Name(es *elasticsearch.Client, class2, name string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteClass2Name 根据子类别、书名、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteClass2Name(es *elasticsearch.Client, class2, name string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteClass2Name 根据子类别、书名、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteClass2Name(es *elasticsearch.Client, class2, name string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtClass2Name 根据子类别、书名、价格大于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtClass2Name(es *elasticsearch.Client, class2, name string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtClass2Name 根据子类别、书名、价格小于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtClass2Name(es *elasticsearch.Client, class2, name string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteClass2Name 根据子类别、书名、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteClass2Name(es *elasticsearch.Client, class2, name string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteClass2Name 根据子类别、书名、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteClass2Name(es *elasticsearch.Client, class2, name string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteClass2Name 根据子类别、书名、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtClass2Name 根据子类别、书名、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtClass2Name 根据子类别、书名、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteClass2Name 根据子类别、书名、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteClass2Name 根据子类别、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteClass2Name 根据子类别、书名、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtClass2Name 根据子类别、书名、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtClass2Name 根据子类别、书名、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteClass2Name 根据子类别、书名、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteClass2Name 根据子类别、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteClass2Name 根据子类别、书名、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtClass2Name 根据子类别、书名、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtClass2Name 根据子类别、书名、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteClass2Name 根据子类别、书名、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteClass2Name 根据子类别、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteClass2Name 根据子类别、书名、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtClass2Name 根据子类别、书名、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtClass2Name 根据子类别、书名、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteClass2Name 根据子类别、书名、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteClass2Name 根据子类别、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteClass2 根据子类别、页数大于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGtClass2 根据子类别、页数大于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLtClass2 根据子类别、页数大于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLteClass2 根据子类别、页数大于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteClass2 根据子类别、页数大于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteClass2 根据子类别、页数大于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGtClass2 根据子类别、页数大于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLtClass2 根据子类别、页数大于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLteClass2 根据子类别、页数大于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteClass2 根据子类别、页数大于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteClass2 根据子类别、页数小于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGtClass2 根据子类别、页数小于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLtClass2 根据子类别、页数小于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLteClass2 根据子类别、页数小于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteClass2 根据子类别、页数小于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteClass2 根据子类别、页数小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGtClass2 根据子类别、页数小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLtClass2 根据子类别、页数小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLteClass2 根据子类别、页数小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteClass2 根据子类别、页数小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteClass2 根据子类别、页数大于等于和小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtClass2 根据子类别、页数大于等于和小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtClass2 根据子类别、页数大于等于和小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteClass2 根据子类别、页数大于等于和小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteClass2 根据子类别、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteClass2Seq 根据子类别、编号、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtClass2Seq 根据子类别、编号、页数大于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtClass2Seq 根据子类别、编号、页数小于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteClass2Seq 根据子类别、编号、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteClass2Seq 根据子类别、编号、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteClass2 根据子类别、价格大于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtClass2 根据子类别、价格大于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtClass2 根据子类别、价格大于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteClass2 根据子类别、价格大于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteClass2 根据子类别、价格大于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteClass2 根据子类别、价格大于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtClass2 根据子类别、价格大于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtClass2 根据子类别、价格大于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteClass2 根据子类别、价格大于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteClass2 根据子类别、价格大于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteClass2 根据子类别、价格小于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtClass2 根据子类别、价格小于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtClass2 根据子类别、价格小于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteClass2 根据子类别、价格小于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteClass2 根据子类别、价格小于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteClass2 根据子类别、价格小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtClass2 根据子类别、价格小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtClass2 根据子类别、价格小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteClass2 根据子类别、价格小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteClass2 根据子类别、价格小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteClass2 根据子类别、价格大于等于和小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtClass2 根据子类别、价格大于等于和小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtClass2 根据子类别、价格大于等于和小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteClass2 根据子类别、价格大于等于和小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteClass2 根据子类别、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteClass2Seq 根据子类别、编号、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteClass2Seq(es *elasticsearch.Client, class2, seq string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtClass2Seq 根据子类别、编号、价格大于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtClass2Seq(es *elasticsearch.Client, class2, seq string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtClass2Seq 根据子类别、编号、价格小于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtClass2Seq(es *elasticsearch.Client, class2, seq string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteClass2Seq 根据子类别、编号、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteClass2Seq(es *elasticsearch.Client, class2, seq string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteClass2Seq 根据子类别、编号、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteClass2Seq 根据子类别、编号、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtClass2Seq 根据子类别、编号、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtClass2Seq 根据子类别、编号、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteClass2Seq 根据子类别、编号、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteClass2Seq 根据子类别、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteClass2Seq 根据子类别、编号、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtClass2Seq 根据子类别、编号、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtClass2Seq 根据子类别、编号、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteClass2Seq 根据子类别、编号、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteClass2Seq 根据子类别、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteClass2Seq 根据子类别、编号、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtClass2Seq 根据子类别、编号、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtClass2Seq 根据子类别、编号、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteClass2Seq 根据子类别、编号、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteClass2Seq 根据子类别、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteClass2Seq 根据子类别、编号、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtClass2Seq 根据子类别、编号、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtClass2Seq 根据子类别、编号、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteClass2Seq 根据子类别、编号、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteClass2Seq 根据子类别、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteName 根据书名、页数大于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGtName 根据书名、页数大于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGtName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLtName 根据书名、页数大于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLtName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLteName 根据书名、页数大于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLteName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteName 根据书名、页数大于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteName 根据书名、页数大于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGtName 根据书名、页数大于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGtName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLtName 根据书名、页数大于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLtName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLteName 根据书名、页数大于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLteName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteName 根据书名、页数大于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteName 根据书名、页数小于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGtName 根据书名、页数小于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGtName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLtName 根据书名、页数小于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLtName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLteName 根据书名、页数小于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLteName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteName 根据书名、页数小于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteName 根据书名、页数小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGtName 根据书名、页数小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGtName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLtName 根据书名、页数小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLtName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLteName 根据书名、页数小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLteName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteName 根据书名、页数小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteName 根据书名、页数大于等于和小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtName 根据书名、页数大于等于和小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtName 根据书名、页数大于等于和小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteName 根据书名、页数大于等于和小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteName 根据书名、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteNameSeq 根据书名、编号、页数大于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteNameSeq(es *elasticsearch.Client, name, seq string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtNameSeq 根据书名、编号、页数大于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtNameSeq(es *elasticsearch.Client, name, seq string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtNameSeq 根据书名、编号、页数小于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtNameSeq(es *elasticsearch.Client, name, seq string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteNameSeq 根据书名、编号、页数小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteNameSeq(es *elasticsearch.Client, name, seq string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteNameSeq 根据书名、编号、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteNameSeq(es *elasticsearch.Client, name, seq string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteName 根据书名、价格大于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteName(es *elasticsearch.Client, name string, priceGte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtName 根据书名、价格大于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtName(es *elasticsearch.Client, name string, priceGte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtName 根据书名、价格大于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtName(es *elasticsearch.Client, name string, priceGte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteName 根据书名、价格大于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteName(es *elasticsearch.Client, name string, priceGte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteName 根据书名、价格大于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteName(es *elasticsearch.Client, name string, priceGte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteName 根据书名、价格大于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteName(es *elasticsearch.Client, name string, priceGt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtName 根据书名、价格大于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtName(es *elasticsearch.Client, name string, priceGt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtName 根据书名、价格大于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtName(es *elasticsearch.Client, name string, priceGt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteName 根据书名、价格大于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteName(es *elasticsearch.Client, name string, priceGt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteName 根据书名、价格大于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteName(es *elasticsearch.Client, name string, priceGt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteName 根据书名、价格小于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteName(es *elasticsearch.Client, name string, priceLt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtName 根据书名、价格小于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtName(es *elasticsearch.Client, name string, priceLt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtName 根据书名、价格小于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtName(es *elasticsearch.Client, name string, priceLt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteName 根据书名、价格小于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteName(es *elasticsearch.Client, name string, priceLt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteName 根据书名、价格小于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteName(es *elasticsearch.Client, name string, priceLt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteName 根据书名、价格小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteName(es *elasticsearch.Client, name string, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtName 根据书名、价格小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtName(es *elasticsearch.Client, name string, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtName 根据书名、价格小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtName(es *elasticsearch.Client, name string, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteName 根据书名、价格小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteName(es *elasticsearch.Client, name string, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteName 根据书名、价格小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteName(es *elasticsearch.Client, name string, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteName 根据书名、价格大于等于和小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtName 根据书名、价格大于等于和小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtName 根据书名、价格大于等于和小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteName 根据书名、价格大于等于和小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteName 根据书名、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteNameSeq 根据书名、编号、价格大于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteNameSeq(es *elasticsearch.Client, name, seq string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtNameSeq 根据书名、编号、价格大于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtNameSeq(es *elasticsearch.Client, name, seq string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtNameSeq 根据书名、编号、价格小于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtNameSeq(es *elasticsearch.Client, name, seq string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteNameSeq 根据书名、编号、价格小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteNameSeq(es *elasticsearch.Client, name, seq string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteNameSeq 根据书名、编号、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteNameSeq(es *elasticsearch.Client, name, seq string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteNameSeq 根据书名、编号、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGtNameSeq 根据书名、编号、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLtNameSeq 根据书名、编号、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateLteNameSeq 根据书名、编号、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByReleaseDateGteLteNameSeq 根据书名、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByReleaseDateGteLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteNameSeq 根据书名、编号、发布日期大于等于检索books表并按页数区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGtNameSeq 根据书名、编号、发布日期大于检索books表并按页数区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLtNameSeq 根据书名、编号、发布日期小于检索books表并按页数区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateLteNameSeq 根据书名、编号、发布日期小于等于检索books表并按页数区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfBooksByReleaseDateGteLteNameSeq 根据书名、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfBooksByReleaseDateGteLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteNameSeq 根据书名、编号、发布日期大于等于检索books表并按价格区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGtNameSeq 根据书名、编号、发布日期大于检索books表并按价格区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLtNameSeq 根据书名、编号、发布日期小于检索books表并按价格区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateLteNameSeq 根据书名、编号、发布日期小于等于检索books表并按价格区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfBooksByReleaseDateGteLteNameSeq 根据书名、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfBooksByReleaseDateGteLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteNameSeq 根据书名、编号、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGtNameSeq 根据书名、编号、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLtNameSeq 根据书名、编号、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateLteNameSeq 根据书名、编号、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByReleaseDateGteLteNameSeq 根据书名、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByReleaseDateGteLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteSeq 根据编号、页数大于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGtSeq 根据编号、页数大于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLtSeq 根据编号、页数大于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLteSeq 根据编号、页数大于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteSeq 根据编号、页数大于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteSeq 根据编号、页数大于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGtSeq 根据编号、页数大于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLtSeq 根据编号、页数大于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLteSeq 根据编号、页数大于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteSeq 根据编号、页数大于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteSeq 根据编号、页数小于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGtSeq 根据编号、页数小于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLtSeq 根据编号、页数小于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLteSeq 根据编号、页数小于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteSeq 根据编号、页数小于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteSeq 根据编号、页数小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGtSeq 根据编号、页数小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLtSeq 根据编号、页数小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLteSeq 根据编号、页数小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteSeq 根据编号、页数小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteSeq 根据编号、页数大于等于和小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtSeq 根据编号、页数大于等于和小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtSeq 根据编号、页数大于等于和小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteSeq 根据编号、页数大于等于和小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteSeq 根据编号、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteSeq 根据编号、价格大于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtSeq 根据编号、价格大于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtSeq 根据编号、价格大于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteSeq 根据编号、价格大于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteSeq 根据编号、价格大于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteSeq 根据编号、价格大于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtSeq 根据编号、价格大于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtSeq 根据编号、价格大于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteSeq 根据编号、价格大于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteSeq 根据编号、价格大于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteSeq 根据编号、价格小于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtSeq 根据编号、价格小于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtSeq 根据编号、价格小于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteSeq 根据编号、价格小于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteSeq 根据编号、价格小于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteSeq 根据编号、价格小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtSeq 根据编号、价格小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtSeq 根据编号、价格小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteSeq 根据编号、价格小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteSeq 根据编号、价格小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteSeq 根据编号、价格大于等于和小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtSeq 根据编号、价格大于等于和小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtSeq 根据编号、价格大于等于和小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteSeq 根据编号、价格大于等于和小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteSeq 根据编号、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}
