// Code generated by es2go. DO NOT EDIT.

package model

import (
	"fmt"

	"github.com/elastic/go-elasticsearch/v8"
	eq "github.com/kyle-hy/esquery"
)

// MinPageCountInHistPageCountOfDayBooksByReleaseDateGte 根据发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByReleaseDateGte 根据发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByReleaseDateGte 根据发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByReleaseDateGte 根据发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAuthorReleaseDateGte 根据作者、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByAuthorReleaseDateGte 根据作者、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByAuthorReleaseDateGte 根据作者、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAuthorReleaseDateGte 根据作者、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClassReleaseDateGte 根据类别、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByClassReleaseDateGte 根据类别、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// class string 类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByClassReleaseDateGte 根据类别、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// class string 类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClassReleaseDateGte 根据类别、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByNameReleaseDateGte 根据书名、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByNameReleaseDateGte 根据书名、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByNameReleaseDateGte 根据书名、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByNameReleaseDateGte 根据书名、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByPageCountGteReleaseDateGte 根据页数大于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByPageCountGteReleaseDateGte(es *elasticsearch.Client, pageCountGte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByPageCountGtReleaseDateGte 根据页数大于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByPageCountGtReleaseDateGte(es *elasticsearch.Client, pageCountGt int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByPageCountLtReleaseDateGte 根据页数小于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByPageCountLtReleaseDateGte(es *elasticsearch.Client, pageCountLt int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByPageCountLteReleaseDateGte 根据页数小于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByPageCountLteReleaseDateGte(es *elasticsearch.Client, pageCountLte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByPageCountGteLteReleaseDateGte 根据页数大于等于和小于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByPageCountGteLteReleaseDateGte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByPriceGteReleaseDateGte 根据价格大于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByPriceGteReleaseDateGte(es *elasticsearch.Client, priceGte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByPriceGtReleaseDateGte 根据价格大于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByPriceGtReleaseDateGte(es *elasticsearch.Client, priceGt float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByPriceLtReleaseDateGte 根据价格小于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByPriceLtReleaseDateGte(es *elasticsearch.Client, priceLt float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByPriceLteReleaseDateGte 根据价格小于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByPriceLteReleaseDateGte(es *elasticsearch.Client, priceLte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByPriceGteLteReleaseDateGte 根据价格大于等于和小于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByPriceGteLteReleaseDateGte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksBySeqReleaseDateGte 根据编号、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksBySeqReleaseDateGte 根据编号、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksBySeqReleaseDateGte 根据编号、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksBySeqReleaseDateGte 根据编号、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAllTextPageCountGteReleaseDateGte 根据全文本、页数大于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAllTextPageCountGteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAllTextPageCountGtReleaseDateGte 根据全文本、页数大于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAllTextPageCountGtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAllTextPageCountLtReleaseDateGte 根据全文本、页数小于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAllTextPageCountLtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAllTextPageCountLteReleaseDateGte 根据全文本、页数小于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAllTextPageCountLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAllTextPageCountGteLteReleaseDateGte 根据全文本、页数大于等于和小于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAllTextPageCountGteLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAllTextPriceGteReleaseDateGte 根据全文本、价格大于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAllTextPriceGteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAllTextPriceGtReleaseDateGte 根据全文本、价格大于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAllTextPriceGtReleaseDateGte(es *elasticsearch.Client, allText string, priceGt float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAllTextPriceLtReleaseDateGte 根据全文本、价格小于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAllTextPriceLtReleaseDateGte(es *elasticsearch.Client, allText string, priceLt float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAllTextPriceLteReleaseDateGte 根据全文本、价格小于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAllTextPriceLteReleaseDateGte(es *elasticsearch.Client, allText string, priceLte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAllTextPriceGteLteReleaseDateGte 根据全文本、价格大于等于和小于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAllTextPriceGteLteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAuthorPageCountGteReleaseDateGte 根据作者、页数大于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAuthorPageCountGteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAuthorPageCountGtReleaseDateGte 根据作者、页数大于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAuthorPageCountGtReleaseDateGte(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAuthorPageCountLtReleaseDateGte 根据作者、页数小于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAuthorPageCountLtReleaseDateGte(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAuthorPageCountLteReleaseDateGte 根据作者、页数小于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAuthorPageCountLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAuthorPageCountGteLteReleaseDateGte 根据作者、页数大于等于和小于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAuthorPageCountGteLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAuthorPriceGteReleaseDateGte 根据作者、价格大于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAuthorPriceGteReleaseDateGte(es *elasticsearch.Client, author string, priceGte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAuthorPriceGtReleaseDateGte 根据作者、价格大于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAuthorPriceGtReleaseDateGte(es *elasticsearch.Client, author string, priceGt float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAuthorPriceLtReleaseDateGte 根据作者、价格小于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAuthorPriceLtReleaseDateGte(es *elasticsearch.Client, author string, priceLt float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAuthorPriceLteReleaseDateGte 根据作者、价格小于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAuthorPriceLteReleaseDateGte(es *elasticsearch.Client, author string, priceLte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAuthorPriceGteLteReleaseDateGte 根据作者、价格大于等于和小于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAuthorPriceGteLteReleaseDateGte(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClassPageCountGteReleaseDateGte 根据类别、页数大于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClassPageCountGteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClassPageCountGtReleaseDateGte 根据类别、页数大于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClassPageCountGtReleaseDateGte(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClassPageCountLtReleaseDateGte 根据类别、页数小于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClassPageCountLtReleaseDateGte(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClassPageCountLteReleaseDateGte 根据类别、页数小于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClassPageCountLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClassPageCountGteLteReleaseDateGte 根据类别、页数大于等于和小于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClassPageCountGteLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClassPriceGteReleaseDateGte 根据类别、价格大于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClassPriceGteReleaseDateGte(es *elasticsearch.Client, class string, priceGte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClassPriceGtReleaseDateGte 根据类别、价格大于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClassPriceGtReleaseDateGte(es *elasticsearch.Client, class string, priceGt float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClassPriceLtReleaseDateGte 根据类别、价格小于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClassPriceLtReleaseDateGte(es *elasticsearch.Client, class string, priceLt float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClassPriceLteReleaseDateGte 根据类别、价格小于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClassPriceLteReleaseDateGte(es *elasticsearch.Client, class string, priceLte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClassPriceGteLteReleaseDateGte 根据类别、价格大于等于和小于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClassPriceGteLteReleaseDateGte(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClass2PageCountGteReleaseDateGte 根据子类别、页数大于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClass2PageCountGteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClass2PageCountGtReleaseDateGte 根据子类别、页数大于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClass2PageCountGtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClass2PageCountLtReleaseDateGte 根据子类别、页数小于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClass2PageCountLtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClass2PageCountLteReleaseDateGte 根据子类别、页数小于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClass2PageCountLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClass2PageCountGteLteReleaseDateGte 根据子类别、页数大于等于和小于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClass2PageCountGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClass2PriceGteReleaseDateGte 根据子类别、价格大于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClass2PriceGteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClass2PriceGtReleaseDateGte 根据子类别、价格大于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClass2PriceGtReleaseDateGte(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClass2PriceLtReleaseDateGte 根据子类别、价格小于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClass2PriceLtReleaseDateGte(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClass2PriceLteReleaseDateGte 根据子类别、价格小于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClass2PriceLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClass2PriceGteLteReleaseDateGte 根据子类别、价格大于等于和小于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClass2PriceGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByNamePageCountGteReleaseDateGte 根据书名、页数大于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByNamePageCountGteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByNamePageCountGtReleaseDateGte 根据书名、页数大于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByNamePageCountGtReleaseDateGte(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByNamePageCountLtReleaseDateGte 根据书名、页数小于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByNamePageCountLtReleaseDateGte(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByNamePageCountLteReleaseDateGte 根据书名、页数小于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByNamePageCountLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByNamePageCountGteLteReleaseDateGte 根据书名、页数大于等于和小于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByNamePageCountGteLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByNamePriceGteReleaseDateGte 根据书名、价格大于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByNamePriceGteReleaseDateGte(es *elasticsearch.Client, name string, priceGte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByNamePriceGtReleaseDateGte 根据书名、价格大于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByNamePriceGtReleaseDateGte(es *elasticsearch.Client, name string, priceGt float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByNamePriceLtReleaseDateGte 根据书名、价格小于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByNamePriceLtReleaseDateGte(es *elasticsearch.Client, name string, priceLt float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByNamePriceLteReleaseDateGte 根据书名、价格小于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByNamePriceLteReleaseDateGte(es *elasticsearch.Client, name string, priceLte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByNamePriceGteLteReleaseDateGte 根据书名、价格大于等于和小于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByNamePriceGteLteReleaseDateGte(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfDayBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几天检索books表，并按页数区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfDayBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfDayBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几天检索books表，并按价格区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfDayBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksBySeqPageCountGteReleaseDateGte 根据编号、页数大于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksBySeqPageCountGteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksBySeqPageCountGtReleaseDateGte 根据编号、页数大于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksBySeqPageCountGtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksBySeqPageCountLtReleaseDateGte 根据编号、页数小于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksBySeqPageCountLtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksBySeqPageCountLteReleaseDateGte 根据编号、页数小于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksBySeqPageCountLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfDayBooksBySeqPageCountGteLteReleaseDateGte 根据编号、页数大于等于和小于等于、发布日期为近几天检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfDayBooksBySeqPageCountGteLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksBySeqPriceGteReleaseDateGte 根据编号、价格大于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksBySeqPriceGteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksBySeqPriceGtReleaseDateGte 根据编号、价格大于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksBySeqPriceGtReleaseDateGte(es *elasticsearch.Client, seq string, priceGt float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksBySeqPriceLtReleaseDateGte 根据编号、价格小于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksBySeqPriceLtReleaseDateGte(es *elasticsearch.Client, seq string, priceLt float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksBySeqPriceLteReleaseDateGte 根据编号、价格小于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksBySeqPriceLteReleaseDateGte(es *elasticsearch.Client, seq string, priceLte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfDayBooksBySeqPriceGteLteReleaseDateGte 根据编号、价格大于等于和小于等于、发布日期为近几天检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfDayBooksBySeqPriceGteLteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateNDay int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}
