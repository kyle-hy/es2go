// Code generated by es2go. DO NOT EDIT.

package model

import (
	"fmt"

	"github.com/elastic/go-elasticsearch/v8"
	eq "github.com/kyle-hy/esquery"
)

// MinPageCountInHistPageCountOfYearBooksByReleaseDateGte 根据发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByReleaseDateGte 根据发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByReleaseDateGte 根据发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByReleaseDateGte 根据发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAuthorReleaseDateGte 根据作者、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByAuthorReleaseDateGte 根据作者、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByAuthorReleaseDateGte 根据作者、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAuthorReleaseDateGte 根据作者、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClassReleaseDateGte 根据类别、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByClassReleaseDateGte 根据类别、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// class string 类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByClassReleaseDateGte 根据类别、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// class string 类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClassReleaseDateGte 根据类别、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByNameReleaseDateGte 根据书名、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByNameReleaseDateGte 根据书名、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByNameReleaseDateGte 根据书名、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByNameReleaseDateGte 根据书名、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByPageCountGteReleaseDateGte 根据页数大于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByPageCountGteReleaseDateGte(es *elasticsearch.Client, pageCountGte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByPageCountGtReleaseDateGte 根据页数大于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// pageCountGt int64 页数大于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByPageCountGtReleaseDateGte(es *elasticsearch.Client, pageCountGt int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByPageCountLtReleaseDateGte 根据页数小于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// pageCountLt int64 页数小于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByPageCountLtReleaseDateGte(es *elasticsearch.Client, pageCountLt int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByPageCountLteReleaseDateGte 根据页数小于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// pageCountLte int64 页数小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByPageCountLteReleaseDateGte(es *elasticsearch.Client, pageCountLte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByPageCountGteLteReleaseDateGte 根据页数大于等于和小于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByPageCountGteLteReleaseDateGte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByPriceGteReleaseDateGte 根据价格大于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByPriceGteReleaseDateGte(es *elasticsearch.Client, priceGte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByPriceGtReleaseDateGte 根据价格大于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// priceGt float64 价格大于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByPriceGtReleaseDateGte(es *elasticsearch.Client, priceGt float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByPriceLtReleaseDateGte 根据价格小于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// priceLt float64 价格小于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByPriceLtReleaseDateGte(es *elasticsearch.Client, priceLt float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByPriceLteReleaseDateGte 根据价格小于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// priceLte float64 价格小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByPriceLteReleaseDateGte(es *elasticsearch.Client, priceLte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByPriceGteLteReleaseDateGte 根据价格大于等于和小于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByPriceGteLteReleaseDateGte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksBySeqReleaseDateGte 根据编号、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksBySeqReleaseDateGte 根据编号、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksBySeqReleaseDateGte 根据编号、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksBySeqReleaseDateGte 根据编号、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAllTextPageCountGteReleaseDateGte 根据全文本、页数大于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAllTextPageCountGteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAllTextPageCountGtReleaseDateGte 根据全文本、页数大于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAllTextPageCountGtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAllTextPageCountLtReleaseDateGte 根据全文本、页数小于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAllTextPageCountLtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAllTextPageCountLteReleaseDateGte 根据全文本、页数小于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAllTextPageCountLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAllTextPageCountGteLteReleaseDateGte 根据全文本、页数大于等于和小于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAllTextPageCountGteLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAllTextPriceGteReleaseDateGte 根据全文本、价格大于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAllTextPriceGteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAllTextPriceGtReleaseDateGte 根据全文本、价格大于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAllTextPriceGtReleaseDateGte(es *elasticsearch.Client, allText string, priceGt float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAllTextPriceLtReleaseDateGte 根据全文本、价格小于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAllTextPriceLtReleaseDateGte(es *elasticsearch.Client, allText string, priceLt float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAllTextPriceLteReleaseDateGte 根据全文本、价格小于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAllTextPriceLteReleaseDateGte(es *elasticsearch.Client, allText string, priceLte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAllTextPriceGteLteReleaseDateGte 根据全文本、价格大于等于和小于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAllTextPriceGteLteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAuthorPageCountGteReleaseDateGte 根据作者、页数大于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAuthorPageCountGteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAuthorPageCountGtReleaseDateGte 根据作者、页数大于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAuthorPageCountGtReleaseDateGte(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAuthorPageCountLtReleaseDateGte 根据作者、页数小于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAuthorPageCountLtReleaseDateGte(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAuthorPageCountLteReleaseDateGte 根据作者、页数小于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAuthorPageCountLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAuthorPageCountGteLteReleaseDateGte 根据作者、页数大于等于和小于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAuthorPageCountGteLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAuthorPriceGteReleaseDateGte 根据作者、价格大于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAuthorPriceGteReleaseDateGte(es *elasticsearch.Client, author string, priceGte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAuthorPriceGtReleaseDateGte 根据作者、价格大于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceGt float64 价格大于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAuthorPriceGtReleaseDateGte(es *elasticsearch.Client, author string, priceGt float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAuthorPriceLtReleaseDateGte 根据作者、价格小于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceLt float64 价格小于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAuthorPriceLtReleaseDateGte(es *elasticsearch.Client, author string, priceLt float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAuthorPriceLteReleaseDateGte 根据作者、价格小于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAuthorPriceLteReleaseDateGte(es *elasticsearch.Client, author string, priceLte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAuthorPriceGteLteReleaseDateGte 根据作者、价格大于等于和小于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAuthorPriceGteLteReleaseDateGte(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClassPageCountGteReleaseDateGte 根据类别、页数大于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClassPageCountGteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClassPageCountGtReleaseDateGte 根据类别、页数大于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClassPageCountGtReleaseDateGte(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClassPageCountLtReleaseDateGte 根据类别、页数小于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClassPageCountLtReleaseDateGte(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClassPageCountLteReleaseDateGte 根据类别、页数小于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClassPageCountLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClassPageCountGteLteReleaseDateGte 根据类别、页数大于等于和小于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClassPageCountGteLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClassPriceGteReleaseDateGte 根据类别、价格大于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClassPriceGteReleaseDateGte(es *elasticsearch.Client, class string, priceGte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClassPriceGtReleaseDateGte 根据类别、价格大于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceGt float64 价格大于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClassPriceGtReleaseDateGte(es *elasticsearch.Client, class string, priceGt float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClassPriceLtReleaseDateGte 根据类别、价格小于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceLt float64 价格小于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClassPriceLtReleaseDateGte(es *elasticsearch.Client, class string, priceLt float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClassPriceLteReleaseDateGte 根据类别、价格小于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClassPriceLteReleaseDateGte(es *elasticsearch.Client, class string, priceLte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClassPriceGteLteReleaseDateGte 根据类别、价格大于等于和小于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClassPriceGteLteReleaseDateGte(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClass2PageCountGteReleaseDateGte 根据子类别、页数大于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClass2PageCountGteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClass2PageCountGtReleaseDateGte 根据子类别、页数大于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClass2PageCountGtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClass2PageCountLtReleaseDateGte 根据子类别、页数小于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClass2PageCountLtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClass2PageCountLteReleaseDateGte 根据子类别、页数小于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClass2PageCountLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClass2PageCountGteLteReleaseDateGte 根据子类别、页数大于等于和小于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClass2PageCountGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClass2PriceGteReleaseDateGte 根据子类别、价格大于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClass2PriceGteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClass2PriceGtReleaseDateGte 根据子类别、价格大于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClass2PriceGtReleaseDateGte(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClass2PriceLtReleaseDateGte 根据子类别、价格小于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClass2PriceLtReleaseDateGte(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClass2PriceLteReleaseDateGte 根据子类别、价格小于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClass2PriceLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClass2PriceGteLteReleaseDateGte 根据子类别、价格大于等于和小于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClass2PriceGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByNamePageCountGteReleaseDateGte 根据书名、页数大于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByNamePageCountGteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByNamePageCountGtReleaseDateGte 根据书名、页数大于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByNamePageCountGtReleaseDateGte(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByNamePageCountLtReleaseDateGte 根据书名、页数小于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByNamePageCountLtReleaseDateGte(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByNamePageCountLteReleaseDateGte 根据书名、页数小于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByNamePageCountLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByNamePageCountGteLteReleaseDateGte 根据书名、页数大于等于和小于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByNamePageCountGteLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByNamePriceGteReleaseDateGte 根据书名、价格大于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByNamePriceGteReleaseDateGte(es *elasticsearch.Client, name string, priceGte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByNamePriceGtReleaseDateGte 根据书名、价格大于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceGt float64 价格大于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByNamePriceGtReleaseDateGte(es *elasticsearch.Client, name string, priceGt float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByNamePriceLtReleaseDateGte 根据书名、价格小于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceLt float64 价格小于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByNamePriceLtReleaseDateGte(es *elasticsearch.Client, name string, priceLt float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByNamePriceLteReleaseDateGte 根据书名、价格小于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByNamePriceLteReleaseDateGte(es *elasticsearch.Client, name string, priceLte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByNamePriceGteLteReleaseDateGte 根据书名、价格大于等于和小于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByNamePriceGteLteReleaseDateGte(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfYearBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几年检索books表，并按页数区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfYearBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfYearBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几年检索books表，并按价格区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfYearBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksBySeqPageCountGteReleaseDateGte 根据编号、页数大于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksBySeqPageCountGteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksBySeqPageCountGtReleaseDateGte 根据编号、页数大于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksBySeqPageCountGtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksBySeqPageCountLtReleaseDateGte 根据编号、页数小于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksBySeqPageCountLtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksBySeqPageCountLteReleaseDateGte 根据编号、页数小于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksBySeqPageCountLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfYearBooksBySeqPageCountGteLteReleaseDateGte 根据编号、页数大于等于和小于等于、发布日期为近几年检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfYearBooksBySeqPageCountGteLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksBySeqPriceGteReleaseDateGte 根据编号、价格大于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksBySeqPriceGteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksBySeqPriceGtReleaseDateGte 根据编号、价格大于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGt float64 价格大于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksBySeqPriceGtReleaseDateGte(es *elasticsearch.Client, seq string, priceGt float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksBySeqPriceLtReleaseDateGte 根据编号、价格小于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLt float64 价格小于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksBySeqPriceLtReleaseDateGte(es *elasticsearch.Client, seq string, priceLt float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksBySeqPriceLteReleaseDateGte 根据编号、价格小于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksBySeqPriceLteReleaseDateGte(es *elasticsearch.Client, seq string, priceLte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfYearBooksBySeqPriceGteLteReleaseDateGte 根据编号、价格大于等于和小于等于、发布日期为近几年检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNYear int 发布日期为近几年
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfYearBooksBySeqPriceGteLteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateNYear int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dy/y", releaseDateNYear), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}
