// Code generated by es2go. DO NOT EDIT.

package model

import (
	"fmt"

	"github.com/elastic/go-elasticsearch/v8"
	eq "github.com/kyle-hy/esquery"
)

// MinPageCountInMinuteHistOfDayBooksByReleaseDateGte 根据发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByReleaseDateGte 根据发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByReleaseDateGte 根据发布日期为近几天检索books表并分桶统计每小时页数的最小值
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByReleaseDateGte 根据发布日期为近几天检索books表并分桶统计每小时价格的最小值
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByReleaseDateGte 根据发布日期为近几天检索books表并分桶统计每天页数的最小值
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByReleaseDateGte 根据发布日期为近几天检索books表并分桶统计每天价格的最小值
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// allText string 全文本
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// allText string 全文本
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几天检索books表并分桶统计每天页数的最小值
// allText string 全文本
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几天检索books表并分桶统计每天价格的最小值
// allText string 全文本
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAuthorReleaseDateGte 根据作者、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// author string 作者
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAuthorReleaseDateGte 根据作者、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// author string 作者
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAuthorReleaseDateGte 根据作者、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// author string 作者
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAuthorReleaseDateGte 根据作者、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// author string 作者
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAuthorReleaseDateGte 根据作者、发布日期为近几天检索books表并分桶统计每天页数的最小值
// author string 作者
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAuthorReleaseDateGte 根据作者、发布日期为近几天检索books表并分桶统计每天价格的最小值
// author string 作者
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClassReleaseDateGte 根据类别、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClassReleaseDateGte 根据类别、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClassReleaseDateGte 根据类别、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClassReleaseDateGte 根据类别、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClassReleaseDateGte 根据类别、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClassReleaseDateGte 根据类别、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByNameReleaseDateGte 根据书名、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByNameReleaseDateGte 根据书名、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByNameReleaseDateGte 根据书名、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByNameReleaseDateGte 根据书名、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByNameReleaseDateGte 根据书名、发布日期为近几天检索books表并分桶统计每天页数的最小值
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByNameReleaseDateGte 根据书名、发布日期为近几天检索books表并分桶统计每天价格的最小值
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByPageCountGteReleaseDateGte 根据页数大于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByPageCountGteReleaseDateGte(es *elasticsearch.Client, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByPageCountGtReleaseDateGte 根据页数大于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByPageCountGtReleaseDateGte(es *elasticsearch.Client, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByPageCountLtReleaseDateGte 根据页数小于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByPageCountLtReleaseDateGte(es *elasticsearch.Client, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByPageCountLteReleaseDateGte 根据页数小于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByPageCountLteReleaseDateGte(es *elasticsearch.Client, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByPageCountGteLteReleaseDateGte 根据页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByPageCountGteLteReleaseDateGte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByPageCountGteReleaseDateGte 根据页数大于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByPageCountGteReleaseDateGte(es *elasticsearch.Client, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByPageCountGtReleaseDateGte 根据页数大于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByPageCountGtReleaseDateGte(es *elasticsearch.Client, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByPageCountLtReleaseDateGte 根据页数小于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByPageCountLtReleaseDateGte(es *elasticsearch.Client, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByPageCountLteReleaseDateGte 根据页数小于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByPageCountLteReleaseDateGte(es *elasticsearch.Client, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByPageCountGteLteReleaseDateGte 根据页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByPageCountGteLteReleaseDateGte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByPageCountGteReleaseDateGte 根据页数大于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByPageCountGteReleaseDateGte(es *elasticsearch.Client, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByPageCountGtReleaseDateGte 根据页数大于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByPageCountGtReleaseDateGte(es *elasticsearch.Client, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByPageCountLtReleaseDateGte 根据页数小于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByPageCountLtReleaseDateGte(es *elasticsearch.Client, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByPageCountLteReleaseDateGte 根据页数小于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByPageCountLteReleaseDateGte(es *elasticsearch.Client, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByPageCountGteLteReleaseDateGte 根据页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByPageCountGteLteReleaseDateGte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByPriceGteReleaseDateGte 根据价格大于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByPriceGteReleaseDateGte(es *elasticsearch.Client, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByPriceGtReleaseDateGte 根据价格大于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByPriceGtReleaseDateGte(es *elasticsearch.Client, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByPriceLtReleaseDateGte 根据价格小于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByPriceLtReleaseDateGte(es *elasticsearch.Client, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByPriceLteReleaseDateGte 根据价格小于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByPriceLteReleaseDateGte(es *elasticsearch.Client, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByPriceGteLteReleaseDateGte 根据价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByPriceGteLteReleaseDateGte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByPriceGteReleaseDateGte 根据价格大于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByPriceGteReleaseDateGte(es *elasticsearch.Client, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByPriceGtReleaseDateGte 根据价格大于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByPriceGtReleaseDateGte(es *elasticsearch.Client, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByPriceLtReleaseDateGte 根据价格小于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByPriceLtReleaseDateGte(es *elasticsearch.Client, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByPriceLteReleaseDateGte 根据价格小于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByPriceLteReleaseDateGte(es *elasticsearch.Client, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByPriceGteLteReleaseDateGte 根据价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByPriceGteLteReleaseDateGte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByPriceGteReleaseDateGte 根据价格大于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByPriceGteReleaseDateGte(es *elasticsearch.Client, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByPriceGtReleaseDateGte 根据价格大于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByPriceGtReleaseDateGte(es *elasticsearch.Client, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByPriceLtReleaseDateGte 根据价格小于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByPriceLtReleaseDateGte(es *elasticsearch.Client, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByPriceLteReleaseDateGte 根据价格小于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByPriceLteReleaseDateGte(es *elasticsearch.Client, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByPriceGteLteReleaseDateGte 根据价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByPriceGteLteReleaseDateGte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksBySeqReleaseDateGte 根据编号、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksBySeqReleaseDateGte 根据编号、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksBySeqReleaseDateGte 根据编号、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksBySeqReleaseDateGte 根据编号、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksBySeqReleaseDateGte 根据编号、发布日期为近几天检索books表并分桶统计每天页数的最小值
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksBySeqReleaseDateGte 根据编号、发布日期为近几天检索books表并分桶统计每天价格的最小值
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// allText string 全文本
// author string 作者
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// allText string 全文本
// author string 作者
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// author string 作者
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// author string 作者
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几天检索books表并分桶统计每天页数的最小值
// allText string 全文本
// author string 作者
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几天检索books表并分桶统计每天价格的最小值
// allText string 全文本
// author string 作者
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// allText string 全文本
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// allText string 全文本
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几天检索books表并分桶统计每天页数的最小值
// allText string 全文本
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几天检索books表并分桶统计每天价格的最小值
// allText string 全文本
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几天检索books表并分桶统计每天页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几天检索books表并分桶统计每天价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// allText string 全文本
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// allText string 全文本
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几天检索books表并分桶统计每天页数的最小值
// allText string 全文本
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几天检索books表并分桶统计每天价格的最小值
// allText string 全文本
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAllTextPageCountGteReleaseDateGte 根据全文本、页数大于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAllTextPageCountGteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAllTextPageCountGtReleaseDateGte 根据全文本、页数大于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAllTextPageCountGtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAllTextPageCountLtReleaseDateGte 根据全文本、页数小于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAllTextPageCountLtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAllTextPageCountLteReleaseDateGte 根据全文本、页数小于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAllTextPageCountLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAllTextPageCountGteLteReleaseDateGte 根据全文本、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAllTextPageCountGteLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAllTextPageCountGteReleaseDateGte 根据全文本、页数大于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAllTextPageCountGteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAllTextPageCountGtReleaseDateGte 根据全文本、页数大于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAllTextPageCountGtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAllTextPageCountLtReleaseDateGte 根据全文本、页数小于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAllTextPageCountLtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAllTextPageCountLteReleaseDateGte 根据全文本、页数小于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAllTextPageCountLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAllTextPageCountGteLteReleaseDateGte 根据全文本、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAllTextPageCountGteLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAllTextPageCountGteReleaseDateGte 根据全文本、页数大于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAllTextPageCountGteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAllTextPageCountGtReleaseDateGte 根据全文本、页数大于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAllTextPageCountGtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAllTextPageCountLtReleaseDateGte 根据全文本、页数小于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAllTextPageCountLtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAllTextPageCountLteReleaseDateGte 根据全文本、页数小于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAllTextPageCountLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAllTextPageCountGteLteReleaseDateGte 根据全文本、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAllTextPageCountGteLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAllTextPriceGteReleaseDateGte 根据全文本、价格大于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAllTextPriceGteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAllTextPriceGtReleaseDateGte 根据全文本、价格大于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAllTextPriceGtReleaseDateGte(es *elasticsearch.Client, allText string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAllTextPriceLtReleaseDateGte 根据全文本、价格小于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAllTextPriceLtReleaseDateGte(es *elasticsearch.Client, allText string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAllTextPriceLteReleaseDateGte 根据全文本、价格小于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAllTextPriceLteReleaseDateGte(es *elasticsearch.Client, allText string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAllTextPriceGteLteReleaseDateGte 根据全文本、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAllTextPriceGteLteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAllTextPriceGteReleaseDateGte 根据全文本、价格大于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAllTextPriceGteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAllTextPriceGtReleaseDateGte 根据全文本、价格大于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAllTextPriceGtReleaseDateGte(es *elasticsearch.Client, allText string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAllTextPriceLtReleaseDateGte 根据全文本、价格小于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAllTextPriceLtReleaseDateGte(es *elasticsearch.Client, allText string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAllTextPriceLteReleaseDateGte 根据全文本、价格小于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAllTextPriceLteReleaseDateGte(es *elasticsearch.Client, allText string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAllTextPriceGteLteReleaseDateGte 根据全文本、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAllTextPriceGteLteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAllTextPriceGteReleaseDateGte 根据全文本、价格大于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAllTextPriceGteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAllTextPriceGtReleaseDateGte 根据全文本、价格大于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAllTextPriceGtReleaseDateGte(es *elasticsearch.Client, allText string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAllTextPriceLtReleaseDateGte 根据全文本、价格小于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAllTextPriceLtReleaseDateGte(es *elasticsearch.Client, allText string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAllTextPriceLteReleaseDateGte 根据全文本、价格小于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAllTextPriceLteReleaseDateGte(es *elasticsearch.Client, allText string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAllTextPriceGteLteReleaseDateGte 根据全文本、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAllTextPriceGteLteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几天检索books表并分桶统计每天页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几天检索books表并分桶统计每天价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// author string 作者
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// author string 作者
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// author string 作者
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// author string 作者
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几天检索books表并分桶统计每天页数的最小值
// author string 作者
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几天检索books表并分桶统计每天价格的最小值
// author string 作者
// class string 类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几天检索books表并分桶统计每天页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几天检索books表并分桶统计每天价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// author string 作者
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// author string 作者
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// author string 作者
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// author string 作者
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几天检索books表并分桶统计每天页数的最小值
// author string 作者
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几天检索books表并分桶统计每天价格的最小值
// author string 作者
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAuthorPageCountGteReleaseDateGte 根据作者、页数大于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAuthorPageCountGteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAuthorPageCountGtReleaseDateGte 根据作者、页数大于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAuthorPageCountGtReleaseDateGte(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAuthorPageCountLtReleaseDateGte 根据作者、页数小于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAuthorPageCountLtReleaseDateGte(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAuthorPageCountLteReleaseDateGte 根据作者、页数小于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAuthorPageCountLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAuthorPageCountGteLteReleaseDateGte 根据作者、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAuthorPageCountGteLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAuthorPageCountGteReleaseDateGte 根据作者、页数大于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAuthorPageCountGteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAuthorPageCountGtReleaseDateGte 根据作者、页数大于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAuthorPageCountGtReleaseDateGte(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAuthorPageCountLtReleaseDateGte 根据作者、页数小于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAuthorPageCountLtReleaseDateGte(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAuthorPageCountLteReleaseDateGte 根据作者、页数小于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAuthorPageCountLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAuthorPageCountGteLteReleaseDateGte 根据作者、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAuthorPageCountGteLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAuthorPageCountGteReleaseDateGte 根据作者、页数大于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAuthorPageCountGteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAuthorPageCountGtReleaseDateGte 根据作者、页数大于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAuthorPageCountGtReleaseDateGte(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAuthorPageCountLtReleaseDateGte 根据作者、页数小于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAuthorPageCountLtReleaseDateGte(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAuthorPageCountLteReleaseDateGte 根据作者、页数小于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAuthorPageCountLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAuthorPageCountGteLteReleaseDateGte 根据作者、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAuthorPageCountGteLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAuthorPriceGteReleaseDateGte 根据作者、价格大于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAuthorPriceGteReleaseDateGte(es *elasticsearch.Client, author string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAuthorPriceGtReleaseDateGte 根据作者、价格大于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// author string 作者
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAuthorPriceGtReleaseDateGte(es *elasticsearch.Client, author string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAuthorPriceLtReleaseDateGte 根据作者、价格小于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// author string 作者
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAuthorPriceLtReleaseDateGte(es *elasticsearch.Client, author string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAuthorPriceLteReleaseDateGte 根据作者、价格小于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAuthorPriceLteReleaseDateGte(es *elasticsearch.Client, author string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAuthorPriceGteLteReleaseDateGte 根据作者、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAuthorPriceGteLteReleaseDateGte(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAuthorPriceGteReleaseDateGte 根据作者、价格大于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAuthorPriceGteReleaseDateGte(es *elasticsearch.Client, author string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAuthorPriceGtReleaseDateGte 根据作者、价格大于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// author string 作者
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAuthorPriceGtReleaseDateGte(es *elasticsearch.Client, author string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAuthorPriceLtReleaseDateGte 根据作者、价格小于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// author string 作者
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAuthorPriceLtReleaseDateGte(es *elasticsearch.Client, author string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAuthorPriceLteReleaseDateGte 根据作者、价格小于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAuthorPriceLteReleaseDateGte(es *elasticsearch.Client, author string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAuthorPriceGteLteReleaseDateGte 根据作者、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAuthorPriceGteLteReleaseDateGte(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAuthorPriceGteReleaseDateGte 根据作者、价格大于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAuthorPriceGteReleaseDateGte(es *elasticsearch.Client, author string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAuthorPriceGtReleaseDateGte 根据作者、价格大于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// author string 作者
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAuthorPriceGtReleaseDateGte(es *elasticsearch.Client, author string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAuthorPriceLtReleaseDateGte 根据作者、价格小于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// author string 作者
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAuthorPriceLtReleaseDateGte(es *elasticsearch.Client, author string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAuthorPriceLteReleaseDateGte 根据作者、价格小于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAuthorPriceLteReleaseDateGte(es *elasticsearch.Client, author string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAuthorPriceGteLteReleaseDateGte 根据作者、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAuthorPriceGteLteReleaseDateGte(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// author string 作者
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// author string 作者
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// author string 作者
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// author string 作者
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几天检索books表并分桶统计每天页数的最小值
// author string 作者
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几天检索books表并分桶统计每天价格的最小值
// author string 作者
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class string 类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class string 类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class string 类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class string 类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class string 类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class string 类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClassPageCountGteReleaseDateGte 根据类别、页数大于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClassPageCountGteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClassPageCountGtReleaseDateGte 根据类别、页数大于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClassPageCountGtReleaseDateGte(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClassPageCountLtReleaseDateGte 根据类别、页数小于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClassPageCountLtReleaseDateGte(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClassPageCountLteReleaseDateGte 根据类别、页数小于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClassPageCountLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClassPageCountGteLteReleaseDateGte 根据类别、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClassPageCountGteLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClassPageCountGteReleaseDateGte 根据类别、页数大于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClassPageCountGteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClassPageCountGtReleaseDateGte 根据类别、页数大于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClassPageCountGtReleaseDateGte(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClassPageCountLtReleaseDateGte 根据类别、页数小于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClassPageCountLtReleaseDateGte(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClassPageCountLteReleaseDateGte 根据类别、页数小于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClassPageCountLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClassPageCountGteLteReleaseDateGte 根据类别、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClassPageCountGteLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClassPageCountGteReleaseDateGte 根据类别、页数大于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClassPageCountGteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClassPageCountGtReleaseDateGte 根据类别、页数大于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClassPageCountGtReleaseDateGte(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClassPageCountLtReleaseDateGte 根据类别、页数小于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClassPageCountLtReleaseDateGte(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClassPageCountLteReleaseDateGte 根据类别、页数小于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClassPageCountLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClassPageCountGteLteReleaseDateGte 根据类别、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClassPageCountGteLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClassPriceGteReleaseDateGte 根据类别、价格大于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClassPriceGteReleaseDateGte(es *elasticsearch.Client, class string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClassPriceGtReleaseDateGte 根据类别、价格大于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class string 类别
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClassPriceGtReleaseDateGte(es *elasticsearch.Client, class string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClassPriceLtReleaseDateGte 根据类别、价格小于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class string 类别
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClassPriceLtReleaseDateGte(es *elasticsearch.Client, class string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClassPriceLteReleaseDateGte 根据类别、价格小于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClassPriceLteReleaseDateGte(es *elasticsearch.Client, class string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClassPriceGteLteReleaseDateGte 根据类别、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClassPriceGteLteReleaseDateGte(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClassPriceGteReleaseDateGte 根据类别、价格大于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClassPriceGteReleaseDateGte(es *elasticsearch.Client, class string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClassPriceGtReleaseDateGte 根据类别、价格大于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class string 类别
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClassPriceGtReleaseDateGte(es *elasticsearch.Client, class string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClassPriceLtReleaseDateGte 根据类别、价格小于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class string 类别
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClassPriceLtReleaseDateGte(es *elasticsearch.Client, class string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClassPriceLteReleaseDateGte 根据类别、价格小于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClassPriceLteReleaseDateGte(es *elasticsearch.Client, class string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClassPriceGteLteReleaseDateGte 根据类别、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClassPriceGteLteReleaseDateGte(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClassPriceGteReleaseDateGte 根据类别、价格大于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClassPriceGteReleaseDateGte(es *elasticsearch.Client, class string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClassPriceGtReleaseDateGte 根据类别、价格大于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class string 类别
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClassPriceGtReleaseDateGte(es *elasticsearch.Client, class string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClassPriceLtReleaseDateGte 根据类别、价格小于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class string 类别
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClassPriceLtReleaseDateGte(es *elasticsearch.Client, class string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClassPriceLteReleaseDateGte 根据类别、价格小于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClassPriceLteReleaseDateGte(es *elasticsearch.Client, class string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClassPriceGteLteReleaseDateGte 根据类别、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClassPriceGteLteReleaseDateGte(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class string 类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class string 类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class string 类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class string 类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class string 类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class string 类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClass2PageCountGteReleaseDateGte 根据子类别、页数大于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClass2PageCountGteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClass2PageCountGtReleaseDateGte 根据子类别、页数大于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClass2PageCountGtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClass2PageCountLtReleaseDateGte 根据子类别、页数小于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClass2PageCountLtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClass2PageCountLteReleaseDateGte 根据子类别、页数小于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClass2PageCountLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClass2PageCountGteLteReleaseDateGte 根据子类别、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClass2PageCountGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClass2PageCountGteReleaseDateGte 根据子类别、页数大于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClass2PageCountGteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClass2PageCountGtReleaseDateGte 根据子类别、页数大于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClass2PageCountGtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClass2PageCountLtReleaseDateGte 根据子类别、页数小于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClass2PageCountLtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClass2PageCountLteReleaseDateGte 根据子类别、页数小于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClass2PageCountLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClass2PageCountGteLteReleaseDateGte 根据子类别、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClass2PageCountGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClass2PageCountGteReleaseDateGte 根据子类别、页数大于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClass2PageCountGteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClass2PageCountGtReleaseDateGte 根据子类别、页数大于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClass2PageCountGtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClass2PageCountLtReleaseDateGte 根据子类别、页数小于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClass2PageCountLtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClass2PageCountLteReleaseDateGte 根据子类别、页数小于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClass2PageCountLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClass2PageCountGteLteReleaseDateGte 根据子类别、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClass2PageCountGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClass2PriceGteReleaseDateGte 根据子类别、价格大于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClass2PriceGteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClass2PriceGtReleaseDateGte 根据子类别、价格大于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClass2PriceGtReleaseDateGte(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClass2PriceLtReleaseDateGte 根据子类别、价格小于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClass2PriceLtReleaseDateGte(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClass2PriceLteReleaseDateGte 根据子类别、价格小于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClass2PriceLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClass2PriceGteLteReleaseDateGte 根据子类别、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClass2PriceGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClass2PriceGteReleaseDateGte 根据子类别、价格大于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClass2PriceGteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClass2PriceGtReleaseDateGte 根据子类别、价格大于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClass2PriceGtReleaseDateGte(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClass2PriceLtReleaseDateGte 根据子类别、价格小于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClass2PriceLtReleaseDateGte(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClass2PriceLteReleaseDateGte 根据子类别、价格小于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClass2PriceLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClass2PriceGteLteReleaseDateGte 根据子类别、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClass2PriceGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClass2PriceGteReleaseDateGte 根据子类别、价格大于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClass2PriceGteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClass2PriceGtReleaseDateGte 根据子类别、价格大于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClass2PriceGtReleaseDateGte(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClass2PriceLtReleaseDateGte 根据子类别、价格小于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClass2PriceLtReleaseDateGte(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClass2PriceLteReleaseDateGte 根据子类别、价格小于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClass2PriceLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClass2PriceGteLteReleaseDateGte 根据子类别、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClass2PriceGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几天检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几天检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByNamePageCountGteReleaseDateGte 根据书名、页数大于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByNamePageCountGteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByNamePageCountGtReleaseDateGte 根据书名、页数大于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByNamePageCountGtReleaseDateGte(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByNamePageCountLtReleaseDateGte 根据书名、页数小于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByNamePageCountLtReleaseDateGte(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByNamePageCountLteReleaseDateGte 根据书名、页数小于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByNamePageCountLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByNamePageCountGteLteReleaseDateGte 根据书名、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByNamePageCountGteLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByNamePageCountGteReleaseDateGte 根据书名、页数大于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByNamePageCountGteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByNamePageCountGtReleaseDateGte 根据书名、页数大于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByNamePageCountGtReleaseDateGte(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByNamePageCountLtReleaseDateGte 根据书名、页数小于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByNamePageCountLtReleaseDateGte(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByNamePageCountLteReleaseDateGte 根据书名、页数小于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByNamePageCountLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByNamePageCountGteLteReleaseDateGte 根据书名、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByNamePageCountGteLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByNamePageCountGteReleaseDateGte 根据书名、页数大于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByNamePageCountGteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByNamePageCountGtReleaseDateGte 根据书名、页数大于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByNamePageCountGtReleaseDateGte(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByNamePageCountLtReleaseDateGte 根据书名、页数小于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByNamePageCountLtReleaseDateGte(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByNamePageCountLteReleaseDateGte 根据书名、页数小于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByNamePageCountLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByNamePageCountGteLteReleaseDateGte 根据书名、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByNamePageCountGteLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByNamePriceGteReleaseDateGte 根据书名、价格大于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByNamePriceGteReleaseDateGte(es *elasticsearch.Client, name string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByNamePriceGtReleaseDateGte 根据书名、价格大于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// name string 书名
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByNamePriceGtReleaseDateGte(es *elasticsearch.Client, name string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByNamePriceLtReleaseDateGte 根据书名、价格小于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// name string 书名
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByNamePriceLtReleaseDateGte(es *elasticsearch.Client, name string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByNamePriceLteReleaseDateGte 根据书名、价格小于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByNamePriceLteReleaseDateGte(es *elasticsearch.Client, name string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByNamePriceGteLteReleaseDateGte 根据书名、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByNamePriceGteLteReleaseDateGte(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByNamePriceGteReleaseDateGte 根据书名、价格大于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByNamePriceGteReleaseDateGte(es *elasticsearch.Client, name string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByNamePriceGtReleaseDateGte 根据书名、价格大于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// name string 书名
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByNamePriceGtReleaseDateGte(es *elasticsearch.Client, name string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByNamePriceLtReleaseDateGte 根据书名、价格小于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// name string 书名
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByNamePriceLtReleaseDateGte(es *elasticsearch.Client, name string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByNamePriceLteReleaseDateGte 根据书名、价格小于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByNamePriceLteReleaseDateGte(es *elasticsearch.Client, name string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByNamePriceGteLteReleaseDateGte 根据书名、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByNamePriceGteLteReleaseDateGte(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByNamePriceGteReleaseDateGte 根据书名、价格大于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByNamePriceGteReleaseDateGte(es *elasticsearch.Client, name string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByNamePriceGtReleaseDateGte 根据书名、价格大于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// name string 书名
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByNamePriceGtReleaseDateGte(es *elasticsearch.Client, name string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByNamePriceLtReleaseDateGte 根据书名、价格小于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// name string 书名
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByNamePriceLtReleaseDateGte(es *elasticsearch.Client, name string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByNamePriceLteReleaseDateGte 根据书名、价格小于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByNamePriceLteReleaseDateGte(es *elasticsearch.Client, name string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByNamePriceGteLteReleaseDateGte 根据书名、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByNamePriceGteLteReleaseDateGte(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// name string 书名
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// name string 书名
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// name string 书名
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// name string 书名
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几天检索books表并分桶统计每天页数的最小值
// name string 书名
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几天检索books表并分桶统计每天价格的最小值
// name string 书名
// seq string 编号
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksBySeqPageCountGteReleaseDateGte 根据编号、页数大于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksBySeqPageCountGteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksBySeqPageCountGtReleaseDateGte 根据编号、页数大于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksBySeqPageCountGtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksBySeqPageCountLtReleaseDateGte 根据编号、页数小于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksBySeqPageCountLtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksBySeqPageCountLteReleaseDateGte 根据编号、页数小于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksBySeqPageCountLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInMinuteHistOfDayBooksBySeqPageCountGteLteReleaseDateGte 根据编号、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每分钟价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInMinuteHistOfDayBooksBySeqPageCountGteLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksBySeqPageCountGteReleaseDateGte 根据编号、页数大于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksBySeqPageCountGteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksBySeqPageCountGtReleaseDateGte 根据编号、页数大于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksBySeqPageCountGtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksBySeqPageCountLtReleaseDateGte 根据编号、页数小于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksBySeqPageCountLtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksBySeqPageCountLteReleaseDateGte 根据编号、页数小于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksBySeqPageCountLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfDayBooksBySeqPageCountGteLteReleaseDateGte 根据编号、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每小时价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInHourHistOfDayBooksBySeqPageCountGteLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksBySeqPageCountGteReleaseDateGte 根据编号、页数大于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksBySeqPageCountGteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksBySeqPageCountGtReleaseDateGte 根据编号、页数大于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksBySeqPageCountGtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksBySeqPageCountLtReleaseDateGte 根据编号、页数小于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksBySeqPageCountLtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksBySeqPageCountLteReleaseDateGte 根据编号、页数小于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksBySeqPageCountLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfDayBooksBySeqPageCountGteLteReleaseDateGte 根据编号、页数大于等于和小于等于、发布日期为近几天检索books表并分桶统计每天价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNDay int 发布日期为近几天
func MinPriceInDayHistOfDayBooksBySeqPageCountGteLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksBySeqPriceGteReleaseDateGte 根据编号、价格大于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksBySeqPriceGteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksBySeqPriceGtReleaseDateGte 根据编号、价格大于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// seq string 编号
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksBySeqPriceGtReleaseDateGte(es *elasticsearch.Client, seq string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksBySeqPriceLtReleaseDateGte 根据编号、价格小于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// seq string 编号
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksBySeqPriceLtReleaseDateGte(es *elasticsearch.Client, seq string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksBySeqPriceLteReleaseDateGte 根据编号、价格小于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksBySeqPriceLteReleaseDateGte(es *elasticsearch.Client, seq string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInMinuteHistOfDayBooksBySeqPriceGteLteReleaseDateGte 根据编号、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每分钟页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInMinuteHistOfDayBooksBySeqPriceGteLteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("minute"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksBySeqPriceGteReleaseDateGte 根据编号、价格大于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksBySeqPriceGteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksBySeqPriceGtReleaseDateGte 根据编号、价格大于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// seq string 编号
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksBySeqPriceGtReleaseDateGte(es *elasticsearch.Client, seq string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksBySeqPriceLtReleaseDateGte 根据编号、价格小于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// seq string 编号
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksBySeqPriceLtReleaseDateGte(es *elasticsearch.Client, seq string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksBySeqPriceLteReleaseDateGte 根据编号、价格小于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksBySeqPriceLteReleaseDateGte(es *elasticsearch.Client, seq string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfDayBooksBySeqPriceGteLteReleaseDateGte 根据编号、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每小时页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInHourHistOfDayBooksBySeqPriceGteLteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksBySeqPriceGteReleaseDateGte 根据编号、价格大于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksBySeqPriceGteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksBySeqPriceGtReleaseDateGte 根据编号、价格大于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// seq string 编号
// priceGt float64 价格大于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksBySeqPriceGtReleaseDateGte(es *elasticsearch.Client, seq string, priceGt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksBySeqPriceLtReleaseDateGte 根据编号、价格小于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// seq string 编号
// priceLt float64 价格小于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksBySeqPriceLtReleaseDateGte(es *elasticsearch.Client, seq string, priceLt float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksBySeqPriceLteReleaseDateGte 根据编号、价格小于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksBySeqPriceLteReleaseDateGte(es *elasticsearch.Client, seq string, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfDayBooksBySeqPriceGteLteReleaseDateGte 根据编号、价格大于等于和小于等于、发布日期为近几天检索books表并分桶统计每天页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNDay int 发布日期为近几天
func MinPageCountInDayHistOfDayBooksBySeqPriceGteLteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateNDay int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dd/d", releaseDateNDay), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}
