// Code generated by es2go. DO NOT EDIT.
// gen_agg_recent_date_hist_stats.go

package model

import (
	"fmt"

	"github.com/elastic/go-elasticsearch/v8"
	eq "github.com/kyle-hy/esquery"
)

// MinPageCountInHourHistOfWeekBooksByReleaseDateGte 根据发布日期为近几周检索books表并分桶统计每小时页数的最小值
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByReleaseDateGte 根据发布日期为近几周检索books表并分桶统计每小时价格的最小值
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByReleaseDateGte 根据发布日期为近几周检索books表并分桶统计每天页数的最小值
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByReleaseDateGte 根据发布日期为近几周检索books表并分桶统计每天价格的最小值
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByReleaseDateGte 根据发布日期为近几周检索books表并分桶统计每周页数的最小值
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByReleaseDateGte 根据发布日期为近几周检索books表并分桶统计每周价格的最小值
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几周检索books表并分桶统计每天页数的最小值
// allText string 全文本
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几周检索books表并分桶统计每天价格的最小值
// allText string 全文本
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几周检索books表并分桶统计每周页数的最小值
// allText string 全文本
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几周检索books表并分桶统计每周价格的最小值
// allText string 全文本
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAuthorReleaseDateGte 根据作者、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// author string 作者
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAuthorReleaseDateGte 根据作者、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// author string 作者
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAuthorReleaseDateGte 根据作者、发布日期为近几周检索books表并分桶统计每天页数的最小值
// author string 作者
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAuthorReleaseDateGte 根据作者、发布日期为近几周检索books表并分桶统计每天价格的最小值
// author string 作者
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAuthorReleaseDateGte 根据作者、发布日期为近几周检索books表并分桶统计每周页数的最小值
// author string 作者
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAuthorReleaseDateGte 根据作者、发布日期为近几周检索books表并分桶统计每周价格的最小值
// author string 作者
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClassReleaseDateGte 根据类别、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClassReleaseDateGte 根据类别、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClassReleaseDateGte 根据类别、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClassReleaseDateGte 根据类别、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClassReleaseDateGte 根据类别、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClassReleaseDateGte 根据类别、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByNameReleaseDateGte 根据书名、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByNameReleaseDateGte 根据书名、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByNameReleaseDateGte 根据书名、发布日期为近几周检索books表并分桶统计每天页数的最小值
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByNameReleaseDateGte 根据书名、发布日期为近几周检索books表并分桶统计每天价格的最小值
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByNameReleaseDateGte 根据书名、发布日期为近几周检索books表并分桶统计每周页数的最小值
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByNameReleaseDateGte 根据书名、发布日期为近几周检索books表并分桶统计每周价格的最小值
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByPageCountGteReleaseDateGte 根据页数大于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByPageCountGteReleaseDateGte(es *elasticsearch.Client, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByPageCountGtReleaseDateGte 根据页数大于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByPageCountGtReleaseDateGte(es *elasticsearch.Client, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByPageCountLtReleaseDateGte 根据页数小于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByPageCountLtReleaseDateGte(es *elasticsearch.Client, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByPageCountLteReleaseDateGte 根据页数小于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByPageCountLteReleaseDateGte(es *elasticsearch.Client, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByPageCountGteLteReleaseDateGte 根据页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByPageCountGteLteReleaseDateGte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByPageCountGteReleaseDateGte 根据页数大于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByPageCountGteReleaseDateGte(es *elasticsearch.Client, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByPageCountGtReleaseDateGte 根据页数大于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByPageCountGtReleaseDateGte(es *elasticsearch.Client, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByPageCountLtReleaseDateGte 根据页数小于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByPageCountLtReleaseDateGte(es *elasticsearch.Client, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByPageCountLteReleaseDateGte 根据页数小于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByPageCountLteReleaseDateGte(es *elasticsearch.Client, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByPageCountGteLteReleaseDateGte 根据页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByPageCountGteLteReleaseDateGte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByPageCountGteReleaseDateGte 根据页数大于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByPageCountGteReleaseDateGte(es *elasticsearch.Client, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByPageCountGtReleaseDateGte 根据页数大于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByPageCountGtReleaseDateGte(es *elasticsearch.Client, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByPageCountLtReleaseDateGte 根据页数小于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByPageCountLtReleaseDateGte(es *elasticsearch.Client, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByPageCountLteReleaseDateGte 根据页数小于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByPageCountLteReleaseDateGte(es *elasticsearch.Client, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByPageCountGteLteReleaseDateGte 根据页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByPageCountGteLteReleaseDateGte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByPriceGteReleaseDateGte 根据价格大于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByPriceGteReleaseDateGte(es *elasticsearch.Client, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByPriceGtReleaseDateGte 根据价格大于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByPriceGtReleaseDateGte(es *elasticsearch.Client, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByPriceLtReleaseDateGte 根据价格小于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByPriceLtReleaseDateGte(es *elasticsearch.Client, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByPriceLteReleaseDateGte 根据价格小于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByPriceLteReleaseDateGte(es *elasticsearch.Client, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByPriceGteLteReleaseDateGte 根据价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByPriceGteLteReleaseDateGte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByPriceGteReleaseDateGte 根据价格大于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByPriceGteReleaseDateGte(es *elasticsearch.Client, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByPriceGtReleaseDateGte 根据价格大于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByPriceGtReleaseDateGte(es *elasticsearch.Client, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByPriceLtReleaseDateGte 根据价格小于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByPriceLtReleaseDateGte(es *elasticsearch.Client, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByPriceLteReleaseDateGte 根据价格小于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByPriceLteReleaseDateGte(es *elasticsearch.Client, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByPriceGteLteReleaseDateGte 根据价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByPriceGteLteReleaseDateGte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByPriceGteReleaseDateGte 根据价格大于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByPriceGteReleaseDateGte(es *elasticsearch.Client, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByPriceGtReleaseDateGte 根据价格大于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByPriceGtReleaseDateGte(es *elasticsearch.Client, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByPriceLtReleaseDateGte 根据价格小于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByPriceLtReleaseDateGte(es *elasticsearch.Client, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByPriceLteReleaseDateGte 根据价格小于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByPriceLteReleaseDateGte(es *elasticsearch.Client, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByPriceGteLteReleaseDateGte 根据价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByPriceGteLteReleaseDateGte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksBySeqReleaseDateGte 根据编号、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksBySeqReleaseDateGte 根据编号、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksBySeqReleaseDateGte 根据编号、发布日期为近几周检索books表并分桶统计每天页数的最小值
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksBySeqReleaseDateGte 根据编号、发布日期为近几周检索books表并分桶统计每天价格的最小值
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksBySeqReleaseDateGte 根据编号、发布日期为近几周检索books表并分桶统计每周页数的最小值
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksBySeqReleaseDateGte 根据编号、发布日期为近几周检索books表并分桶统计每周价格的最小值
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// author string 作者
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// author string 作者
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几周检索books表并分桶统计每天页数的最小值
// allText string 全文本
// author string 作者
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几周检索books表并分桶统计每天价格的最小值
// allText string 全文本
// author string 作者
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几周检索books表并分桶统计每周页数的最小值
// allText string 全文本
// author string 作者
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几周检索books表并分桶统计每周价格的最小值
// allText string 全文本
// author string 作者
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几周检索books表并分桶统计每天页数的最小值
// allText string 全文本
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几周检索books表并分桶统计每天价格的最小值
// allText string 全文本
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几周检索books表并分桶统计每周页数的最小值
// allText string 全文本
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几周检索books表并分桶统计每周价格的最小值
// allText string 全文本
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几周检索books表并分桶统计每天页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几周检索books表并分桶统计每天价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几周检索books表并分桶统计每周页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几周检索books表并分桶统计每周价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几周检索books表并分桶统计每天页数的最小值
// allText string 全文本
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几周检索books表并分桶统计每天价格的最小值
// allText string 全文本
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几周检索books表并分桶统计每周页数的最小值
// allText string 全文本
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几周检索books表并分桶统计每周价格的最小值
// allText string 全文本
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAllTextPageCountGteReleaseDateGte 根据全文本、页数大于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAllTextPageCountGteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAllTextPageCountGtReleaseDateGte 根据全文本、页数大于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAllTextPageCountGtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAllTextPageCountLtReleaseDateGte 根据全文本、页数小于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAllTextPageCountLtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAllTextPageCountLteReleaseDateGte 根据全文本、页数小于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAllTextPageCountLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAllTextPageCountGteLteReleaseDateGte 根据全文本、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAllTextPageCountGteLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAllTextPageCountGteReleaseDateGte 根据全文本、页数大于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAllTextPageCountGteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAllTextPageCountGtReleaseDateGte 根据全文本、页数大于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAllTextPageCountGtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAllTextPageCountLtReleaseDateGte 根据全文本、页数小于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAllTextPageCountLtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAllTextPageCountLteReleaseDateGte 根据全文本、页数小于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAllTextPageCountLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAllTextPageCountGteLteReleaseDateGte 根据全文本、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAllTextPageCountGteLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAllTextPageCountGteReleaseDateGte 根据全文本、页数大于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAllTextPageCountGteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAllTextPageCountGtReleaseDateGte 根据全文本、页数大于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAllTextPageCountGtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAllTextPageCountLtReleaseDateGte 根据全文本、页数小于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAllTextPageCountLtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAllTextPageCountLteReleaseDateGte 根据全文本、页数小于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAllTextPageCountLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAllTextPageCountGteLteReleaseDateGte 根据全文本、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAllTextPageCountGteLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAllTextPriceGteReleaseDateGte 根据全文本、价格大于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAllTextPriceGteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAllTextPriceGtReleaseDateGte 根据全文本、价格大于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAllTextPriceGtReleaseDateGte(es *elasticsearch.Client, allText string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAllTextPriceLtReleaseDateGte 根据全文本、价格小于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAllTextPriceLtReleaseDateGte(es *elasticsearch.Client, allText string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAllTextPriceLteReleaseDateGte 根据全文本、价格小于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAllTextPriceLteReleaseDateGte(es *elasticsearch.Client, allText string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAllTextPriceGteLteReleaseDateGte 根据全文本、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAllTextPriceGteLteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAllTextPriceGteReleaseDateGte 根据全文本、价格大于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAllTextPriceGteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAllTextPriceGtReleaseDateGte 根据全文本、价格大于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAllTextPriceGtReleaseDateGte(es *elasticsearch.Client, allText string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAllTextPriceLtReleaseDateGte 根据全文本、价格小于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAllTextPriceLtReleaseDateGte(es *elasticsearch.Client, allText string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAllTextPriceLteReleaseDateGte 根据全文本、价格小于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAllTextPriceLteReleaseDateGte(es *elasticsearch.Client, allText string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAllTextPriceGteLteReleaseDateGte 根据全文本、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAllTextPriceGteLteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAllTextPriceGteReleaseDateGte 根据全文本、价格大于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAllTextPriceGteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAllTextPriceGtReleaseDateGte 根据全文本、价格大于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAllTextPriceGtReleaseDateGte(es *elasticsearch.Client, allText string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAllTextPriceLtReleaseDateGte 根据全文本、价格小于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAllTextPriceLtReleaseDateGte(es *elasticsearch.Client, allText string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAllTextPriceLteReleaseDateGte 根据全文本、价格小于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAllTextPriceLteReleaseDateGte(es *elasticsearch.Client, allText string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAllTextPriceGteLteReleaseDateGte 根据全文本、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAllTextPriceGteLteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几周检索books表并分桶统计每天页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几周检索books表并分桶统计每天价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几周检索books表并分桶统计每周页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几周检索books表并分桶统计每周价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// author string 作者
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// author string 作者
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几周检索books表并分桶统计每天页数的最小值
// author string 作者
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几周检索books表并分桶统计每天价格的最小值
// author string 作者
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几周检索books表并分桶统计每周页数的最小值
// author string 作者
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几周检索books表并分桶统计每周价格的最小值
// author string 作者
// class string 类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几周检索books表并分桶统计每天页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几周检索books表并分桶统计每天价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几周检索books表并分桶统计每周页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几周检索books表并分桶统计每周价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// author string 作者
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// author string 作者
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几周检索books表并分桶统计每天页数的最小值
// author string 作者
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几周检索books表并分桶统计每天价格的最小值
// author string 作者
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几周检索books表并分桶统计每周页数的最小值
// author string 作者
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几周检索books表并分桶统计每周价格的最小值
// author string 作者
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAuthorPageCountGteReleaseDateGte 根据作者、页数大于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAuthorPageCountGteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAuthorPageCountGtReleaseDateGte 根据作者、页数大于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAuthorPageCountGtReleaseDateGte(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAuthorPageCountLtReleaseDateGte 根据作者、页数小于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAuthorPageCountLtReleaseDateGte(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAuthorPageCountLteReleaseDateGte 根据作者、页数小于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAuthorPageCountLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAuthorPageCountGteLteReleaseDateGte 根据作者、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAuthorPageCountGteLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAuthorPageCountGteReleaseDateGte 根据作者、页数大于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAuthorPageCountGteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAuthorPageCountGtReleaseDateGte 根据作者、页数大于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAuthorPageCountGtReleaseDateGte(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAuthorPageCountLtReleaseDateGte 根据作者、页数小于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAuthorPageCountLtReleaseDateGte(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAuthorPageCountLteReleaseDateGte 根据作者、页数小于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAuthorPageCountLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAuthorPageCountGteLteReleaseDateGte 根据作者、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAuthorPageCountGteLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAuthorPageCountGteReleaseDateGte 根据作者、页数大于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAuthorPageCountGteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAuthorPageCountGtReleaseDateGte 根据作者、页数大于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAuthorPageCountGtReleaseDateGte(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAuthorPageCountLtReleaseDateGte 根据作者、页数小于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAuthorPageCountLtReleaseDateGte(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAuthorPageCountLteReleaseDateGte 根据作者、页数小于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAuthorPageCountLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAuthorPageCountGteLteReleaseDateGte 根据作者、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAuthorPageCountGteLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAuthorPriceGteReleaseDateGte 根据作者、价格大于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAuthorPriceGteReleaseDateGte(es *elasticsearch.Client, author string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAuthorPriceGtReleaseDateGte 根据作者、价格大于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// author string 作者
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAuthorPriceGtReleaseDateGte(es *elasticsearch.Client, author string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAuthorPriceLtReleaseDateGte 根据作者、价格小于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// author string 作者
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAuthorPriceLtReleaseDateGte(es *elasticsearch.Client, author string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAuthorPriceLteReleaseDateGte 根据作者、价格小于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAuthorPriceLteReleaseDateGte(es *elasticsearch.Client, author string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAuthorPriceGteLteReleaseDateGte 根据作者、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAuthorPriceGteLteReleaseDateGte(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAuthorPriceGteReleaseDateGte 根据作者、价格大于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAuthorPriceGteReleaseDateGte(es *elasticsearch.Client, author string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAuthorPriceGtReleaseDateGte 根据作者、价格大于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// author string 作者
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAuthorPriceGtReleaseDateGte(es *elasticsearch.Client, author string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAuthorPriceLtReleaseDateGte 根据作者、价格小于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// author string 作者
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAuthorPriceLtReleaseDateGte(es *elasticsearch.Client, author string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAuthorPriceLteReleaseDateGte 根据作者、价格小于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAuthorPriceLteReleaseDateGte(es *elasticsearch.Client, author string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAuthorPriceGteLteReleaseDateGte 根据作者、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAuthorPriceGteLteReleaseDateGte(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAuthorPriceGteReleaseDateGte 根据作者、价格大于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAuthorPriceGteReleaseDateGte(es *elasticsearch.Client, author string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAuthorPriceGtReleaseDateGte 根据作者、价格大于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// author string 作者
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAuthorPriceGtReleaseDateGte(es *elasticsearch.Client, author string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAuthorPriceLtReleaseDateGte 根据作者、价格小于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// author string 作者
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAuthorPriceLtReleaseDateGte(es *elasticsearch.Client, author string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAuthorPriceLteReleaseDateGte 根据作者、价格小于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAuthorPriceLteReleaseDateGte(es *elasticsearch.Client, author string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAuthorPriceGteLteReleaseDateGte 根据作者、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAuthorPriceGteLteReleaseDateGte(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// author string 作者
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// author string 作者
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几周检索books表并分桶统计每天页数的最小值
// author string 作者
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几周检索books表并分桶统计每天价格的最小值
// author string 作者
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几周检索books表并分桶统计每周页数的最小值
// author string 作者
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几周检索books表并分桶统计每周价格的最小值
// author string 作者
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class string 类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class string 类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class string 类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class string 类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class string 类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class string 类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClassPageCountGteReleaseDateGte 根据类别、页数大于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClassPageCountGteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClassPageCountGtReleaseDateGte 根据类别、页数大于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClassPageCountGtReleaseDateGte(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClassPageCountLtReleaseDateGte 根据类别、页数小于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClassPageCountLtReleaseDateGte(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClassPageCountLteReleaseDateGte 根据类别、页数小于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClassPageCountLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClassPageCountGteLteReleaseDateGte 根据类别、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClassPageCountGteLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClassPageCountGteReleaseDateGte 根据类别、页数大于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClassPageCountGteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClassPageCountGtReleaseDateGte 根据类别、页数大于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClassPageCountGtReleaseDateGte(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClassPageCountLtReleaseDateGte 根据类别、页数小于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClassPageCountLtReleaseDateGte(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClassPageCountLteReleaseDateGte 根据类别、页数小于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClassPageCountLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClassPageCountGteLteReleaseDateGte 根据类别、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClassPageCountGteLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClassPageCountGteReleaseDateGte 根据类别、页数大于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClassPageCountGteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClassPageCountGtReleaseDateGte 根据类别、页数大于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClassPageCountGtReleaseDateGte(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClassPageCountLtReleaseDateGte 根据类别、页数小于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClassPageCountLtReleaseDateGte(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClassPageCountLteReleaseDateGte 根据类别、页数小于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClassPageCountLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClassPageCountGteLteReleaseDateGte 根据类别、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClassPageCountGteLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClassPriceGteReleaseDateGte 根据类别、价格大于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClassPriceGteReleaseDateGte(es *elasticsearch.Client, class string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClassPriceGtReleaseDateGte 根据类别、价格大于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class string 类别
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClassPriceGtReleaseDateGte(es *elasticsearch.Client, class string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClassPriceLtReleaseDateGte 根据类别、价格小于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class string 类别
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClassPriceLtReleaseDateGte(es *elasticsearch.Client, class string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClassPriceLteReleaseDateGte 根据类别、价格小于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClassPriceLteReleaseDateGte(es *elasticsearch.Client, class string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClassPriceGteLteReleaseDateGte 根据类别、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClassPriceGteLteReleaseDateGte(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClassPriceGteReleaseDateGte 根据类别、价格大于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClassPriceGteReleaseDateGte(es *elasticsearch.Client, class string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClassPriceGtReleaseDateGte 根据类别、价格大于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class string 类别
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClassPriceGtReleaseDateGte(es *elasticsearch.Client, class string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClassPriceLtReleaseDateGte 根据类别、价格小于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class string 类别
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClassPriceLtReleaseDateGte(es *elasticsearch.Client, class string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClassPriceLteReleaseDateGte 根据类别、价格小于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClassPriceLteReleaseDateGte(es *elasticsearch.Client, class string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClassPriceGteLteReleaseDateGte 根据类别、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClassPriceGteLteReleaseDateGte(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClassPriceGteReleaseDateGte 根据类别、价格大于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClassPriceGteReleaseDateGte(es *elasticsearch.Client, class string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClassPriceGtReleaseDateGte 根据类别、价格大于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class string 类别
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClassPriceGtReleaseDateGte(es *elasticsearch.Client, class string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClassPriceLtReleaseDateGte 根据类别、价格小于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class string 类别
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClassPriceLtReleaseDateGte(es *elasticsearch.Client, class string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClassPriceLteReleaseDateGte 根据类别、价格小于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClassPriceLteReleaseDateGte(es *elasticsearch.Client, class string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClassPriceGteLteReleaseDateGte 根据类别、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClassPriceGteLteReleaseDateGte(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class string 类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class string 类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class string 类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class string 类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class string 类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class string 类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClass2PageCountGteReleaseDateGte 根据子类别、页数大于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClass2PageCountGteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClass2PageCountGtReleaseDateGte 根据子类别、页数大于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClass2PageCountGtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClass2PageCountLtReleaseDateGte 根据子类别、页数小于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClass2PageCountLtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClass2PageCountLteReleaseDateGte 根据子类别、页数小于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClass2PageCountLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClass2PageCountGteLteReleaseDateGte 根据子类别、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClass2PageCountGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClass2PageCountGteReleaseDateGte 根据子类别、页数大于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClass2PageCountGteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClass2PageCountGtReleaseDateGte 根据子类别、页数大于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClass2PageCountGtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClass2PageCountLtReleaseDateGte 根据子类别、页数小于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClass2PageCountLtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClass2PageCountLteReleaseDateGte 根据子类别、页数小于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClass2PageCountLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClass2PageCountGteLteReleaseDateGte 根据子类别、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClass2PageCountGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClass2PageCountGteReleaseDateGte 根据子类别、页数大于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClass2PageCountGteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClass2PageCountGtReleaseDateGte 根据子类别、页数大于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClass2PageCountGtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClass2PageCountLtReleaseDateGte 根据子类别、页数小于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClass2PageCountLtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClass2PageCountLteReleaseDateGte 根据子类别、页数小于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClass2PageCountLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClass2PageCountGteLteReleaseDateGte 根据子类别、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClass2PageCountGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClass2PriceGteReleaseDateGte 根据子类别、价格大于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClass2PriceGteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClass2PriceGtReleaseDateGte 根据子类别、价格大于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClass2PriceGtReleaseDateGte(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClass2PriceLtReleaseDateGte 根据子类别、价格小于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClass2PriceLtReleaseDateGte(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClass2PriceLteReleaseDateGte 根据子类别、价格小于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClass2PriceLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClass2PriceGteLteReleaseDateGte 根据子类别、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClass2PriceGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClass2PriceGteReleaseDateGte 根据子类别、价格大于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClass2PriceGteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClass2PriceGtReleaseDateGte 根据子类别、价格大于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClass2PriceGtReleaseDateGte(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClass2PriceLtReleaseDateGte 根据子类别、价格小于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClass2PriceLtReleaseDateGte(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClass2PriceLteReleaseDateGte 根据子类别、价格小于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClass2PriceLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClass2PriceGteLteReleaseDateGte 根据子类别、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClass2PriceGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClass2PriceGteReleaseDateGte 根据子类别、价格大于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClass2PriceGteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClass2PriceGtReleaseDateGte 根据子类别、价格大于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClass2PriceGtReleaseDateGte(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClass2PriceLtReleaseDateGte 根据子类别、价格小于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClass2PriceLtReleaseDateGte(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClass2PriceLteReleaseDateGte 根据子类别、价格小于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClass2PriceLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClass2PriceGteLteReleaseDateGte 根据子类别、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClass2PriceGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几周检索books表并分桶统计每天页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几周检索books表并分桶统计每天价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几周检索books表并分桶统计每周页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几周检索books表并分桶统计每周价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByNamePageCountGteReleaseDateGte 根据书名、页数大于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByNamePageCountGteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByNamePageCountGtReleaseDateGte 根据书名、页数大于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByNamePageCountGtReleaseDateGte(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByNamePageCountLtReleaseDateGte 根据书名、页数小于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByNamePageCountLtReleaseDateGte(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByNamePageCountLteReleaseDateGte 根据书名、页数小于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByNamePageCountLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByNamePageCountGteLteReleaseDateGte 根据书名、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByNamePageCountGteLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByNamePageCountGteReleaseDateGte 根据书名、页数大于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByNamePageCountGteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByNamePageCountGtReleaseDateGte 根据书名、页数大于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByNamePageCountGtReleaseDateGte(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByNamePageCountLtReleaseDateGte 根据书名、页数小于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByNamePageCountLtReleaseDateGte(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByNamePageCountLteReleaseDateGte 根据书名、页数小于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByNamePageCountLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByNamePageCountGteLteReleaseDateGte 根据书名、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByNamePageCountGteLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByNamePageCountGteReleaseDateGte 根据书名、页数大于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByNamePageCountGteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByNamePageCountGtReleaseDateGte 根据书名、页数大于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByNamePageCountGtReleaseDateGte(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByNamePageCountLtReleaseDateGte 根据书名、页数小于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByNamePageCountLtReleaseDateGte(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByNamePageCountLteReleaseDateGte 根据书名、页数小于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByNamePageCountLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByNamePageCountGteLteReleaseDateGte 根据书名、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByNamePageCountGteLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByNamePriceGteReleaseDateGte 根据书名、价格大于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByNamePriceGteReleaseDateGte(es *elasticsearch.Client, name string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByNamePriceGtReleaseDateGte 根据书名、价格大于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// name string 书名
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByNamePriceGtReleaseDateGte(es *elasticsearch.Client, name string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByNamePriceLtReleaseDateGte 根据书名、价格小于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// name string 书名
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByNamePriceLtReleaseDateGte(es *elasticsearch.Client, name string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByNamePriceLteReleaseDateGte 根据书名、价格小于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByNamePriceLteReleaseDateGte(es *elasticsearch.Client, name string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByNamePriceGteLteReleaseDateGte 根据书名、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByNamePriceGteLteReleaseDateGte(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByNamePriceGteReleaseDateGte 根据书名、价格大于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByNamePriceGteReleaseDateGte(es *elasticsearch.Client, name string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByNamePriceGtReleaseDateGte 根据书名、价格大于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// name string 书名
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByNamePriceGtReleaseDateGte(es *elasticsearch.Client, name string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByNamePriceLtReleaseDateGte 根据书名、价格小于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// name string 书名
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByNamePriceLtReleaseDateGte(es *elasticsearch.Client, name string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByNamePriceLteReleaseDateGte 根据书名、价格小于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByNamePriceLteReleaseDateGte(es *elasticsearch.Client, name string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByNamePriceGteLteReleaseDateGte 根据书名、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByNamePriceGteLteReleaseDateGte(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByNamePriceGteReleaseDateGte 根据书名、价格大于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByNamePriceGteReleaseDateGte(es *elasticsearch.Client, name string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByNamePriceGtReleaseDateGte 根据书名、价格大于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// name string 书名
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByNamePriceGtReleaseDateGte(es *elasticsearch.Client, name string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByNamePriceLtReleaseDateGte 根据书名、价格小于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// name string 书名
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByNamePriceLtReleaseDateGte(es *elasticsearch.Client, name string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByNamePriceLteReleaseDateGte 根据书名、价格小于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByNamePriceLteReleaseDateGte(es *elasticsearch.Client, name string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByNamePriceGteLteReleaseDateGte 根据书名、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByNamePriceGteLteReleaseDateGte(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// name string 书名
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// name string 书名
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几周检索books表并分桶统计每天页数的最小值
// name string 书名
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几周检索books表并分桶统计每天价格的最小值
// name string 书名
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几周检索books表并分桶统计每周页数的最小值
// name string 书名
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几周检索books表并分桶统计每周价格的最小值
// name string 书名
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksBySeqPageCountGteReleaseDateGte 根据编号、页数大于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksBySeqPageCountGteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksBySeqPageCountGtReleaseDateGte 根据编号、页数大于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksBySeqPageCountGtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksBySeqPageCountLtReleaseDateGte 根据编号、页数小于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksBySeqPageCountLtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksBySeqPageCountLteReleaseDateGte 根据编号、页数小于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksBySeqPageCountLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHourHistOfWeekBooksBySeqPageCountGteLteReleaseDateGte 根据编号、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每小时价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInHourHistOfWeekBooksBySeqPageCountGteLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksBySeqPageCountGteReleaseDateGte 根据编号、页数大于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksBySeqPageCountGteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksBySeqPageCountGtReleaseDateGte 根据编号、页数大于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksBySeqPageCountGtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksBySeqPageCountLtReleaseDateGte 根据编号、页数小于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksBySeqPageCountLtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksBySeqPageCountLteReleaseDateGte 根据编号、页数小于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksBySeqPageCountLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInDayHistOfWeekBooksBySeqPageCountGteLteReleaseDateGte 根据编号、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每天价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInDayHistOfWeekBooksBySeqPageCountGteLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksBySeqPageCountGteReleaseDateGte 根据编号、页数大于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksBySeqPageCountGteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksBySeqPageCountGtReleaseDateGte 根据编号、页数大于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksBySeqPageCountGtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksBySeqPageCountLtReleaseDateGte 根据编号、页数小于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksBySeqPageCountLtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksBySeqPageCountLteReleaseDateGte 根据编号、页数小于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksBySeqPageCountLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInWeekHistOfWeekBooksBySeqPageCountGteLteReleaseDateGte 根据编号、页数大于等于和小于等于、发布日期为近几周检索books表并分桶统计每周价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPriceInWeekHistOfWeekBooksBySeqPageCountGteLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksBySeqPriceGteReleaseDateGte 根据编号、价格大于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksBySeqPriceGteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksBySeqPriceGtReleaseDateGte 根据编号、价格大于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// seq string 编号
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksBySeqPriceGtReleaseDateGte(es *elasticsearch.Client, seq string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksBySeqPriceLtReleaseDateGte 根据编号、价格小于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// seq string 编号
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksBySeqPriceLtReleaseDateGte(es *elasticsearch.Client, seq string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksBySeqPriceLteReleaseDateGte 根据编号、价格小于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksBySeqPriceLteReleaseDateGte(es *elasticsearch.Client, seq string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHourHistOfWeekBooksBySeqPriceGteLteReleaseDateGte 根据编号、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每小时页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInHourHistOfWeekBooksBySeqPriceGteLteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("hour"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksBySeqPriceGteReleaseDateGte 根据编号、价格大于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksBySeqPriceGteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksBySeqPriceGtReleaseDateGte 根据编号、价格大于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// seq string 编号
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksBySeqPriceGtReleaseDateGte(es *elasticsearch.Client, seq string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksBySeqPriceLtReleaseDateGte 根据编号、价格小于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// seq string 编号
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksBySeqPriceLtReleaseDateGte(es *elasticsearch.Client, seq string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksBySeqPriceLteReleaseDateGte 根据编号、价格小于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksBySeqPriceLteReleaseDateGte(es *elasticsearch.Client, seq string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInDayHistOfWeekBooksBySeqPriceGteLteReleaseDateGte 根据编号、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每天页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInDayHistOfWeekBooksBySeqPriceGteLteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("day"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksBySeqPriceGteReleaseDateGte 根据编号、价格大于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksBySeqPriceGteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksBySeqPriceGtReleaseDateGte 根据编号、价格大于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// seq string 编号
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksBySeqPriceGtReleaseDateGte(es *elasticsearch.Client, seq string, priceGt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksBySeqPriceLtReleaseDateGte 根据编号、价格小于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// seq string 编号
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksBySeqPriceLtReleaseDateGte(es *elasticsearch.Client, seq string, priceLt float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksBySeqPriceLteReleaseDateGte 根据编号、价格小于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksBySeqPriceLteReleaseDateGte(es *elasticsearch.Client, seq string, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInWeekHistOfWeekBooksBySeqPriceGteLteReleaseDateGte 根据编号、价格大于等于和小于等于、发布日期为近几周检索books表并分桶统计每周页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
func MinPageCountInWeekHistOfWeekBooksBySeqPriceGteLteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateNWeek int) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.DateHistogramAgg("release_date", eq.WithCalendarInterval("week"))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}
