// Code generated by es2go. DO NOT EDIT.

package model

import (
	"time"

	"github.com/elastic/go-elasticsearch/v8"
	eq "github.com/kyle-hy/esquery"
)

// MaxPriceOfBooksByPageCountGte 根据页数大于等于检索books表并计算价格的最大值
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGte(es *elasticsearch.Client, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGt 根据页数大于检索books表并计算价格的最大值
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGt(es *elasticsearch.Client, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLt 根据页数小于检索books表并计算价格的最大值
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLt(es *elasticsearch.Client, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLte 根据页数小于等于检索books表并计算价格的最大值
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLte(es *elasticsearch.Client, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLte 根据页数大于等于和小于等于检索books表并计算价格的最大值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLte(es *elasticsearch.Client, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGte 根据价格大于等于检索books表并计算页数的最大值
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGte(es *elasticsearch.Client, priceGte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGt 根据价格大于检索books表并计算页数的最大值
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGt(es *elasticsearch.Client, priceGt float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLt 根据价格小于检索books表并计算页数的最大值
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLt(es *elasticsearch.Client, priceLt float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLte 根据价格小于等于检索books表并计算页数的最大值
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLte(es *elasticsearch.Client, priceLte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLte 根据价格大于等于和小于等于检索books表并计算页数的最大值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLte(es *elasticsearch.Client, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGte 根据发布日期大于等于检索books表并计算页数的最大值
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGt 根据发布日期大于检索books表并计算页数的最大值
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGt(es *elasticsearch.Client, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLt 根据发布日期小于检索books表并计算页数的最大值
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLt(es *elasticsearch.Client, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLte 根据发布日期小于等于检索books表并计算页数的最大值
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLte(es *elasticsearch.Client, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLte 根据发布日期大于等于和小于等于检索books表并计算页数的最大值
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLte(es *elasticsearch.Client, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGte 根据发布日期大于等于检索books表并计算价格的最大值
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGt 根据发布日期大于检索books表并计算价格的最大值
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGt(es *elasticsearch.Client, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLt 根据发布日期小于检索books表并计算价格的最大值
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLt(es *elasticsearch.Client, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLte 根据发布日期小于等于检索books表并计算价格的最大值
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLte(es *elasticsearch.Client, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLte 根据发布日期大于等于和小于等于检索books表并计算价格的最大值
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLte(es *elasticsearch.Client, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteAllText 根据全文本、页数大于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteAllText(es *elasticsearch.Client, allText string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtAllText 根据全文本、页数大于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtAllText(es *elasticsearch.Client, allText string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtAllText 根据全文本、页数小于检索books表并计算价格的最大值
// allText string 全文本
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtAllText(es *elasticsearch.Client, allText string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteAllText 根据全文本、页数小于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteAllText(es *elasticsearch.Client, allText string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteAllText 根据全文本、页数大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteAllText 根据全文本、价格大于等于检索books表并计算页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteAllText(es *elasticsearch.Client, allText string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtAllText 根据全文本、价格大于检索books表并计算页数的最大值
// allText string 全文本
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtAllText(es *elasticsearch.Client, allText string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtAllText 根据全文本、价格小于检索books表并计算页数的最大值
// allText string 全文本
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtAllText(es *elasticsearch.Client, allText string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteAllText 根据全文本、价格小于等于检索books表并计算页数的最大值
// allText string 全文本
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteAllText(es *elasticsearch.Client, allText string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteAllText 根据全文本、价格大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteAllText 根据全文本、发布日期大于等于检索books表并计算页数的最大值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteAllText(es *elasticsearch.Client, allText string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtAllText 根据全文本、发布日期大于检索books表并计算页数的最大值
// allText string 全文本
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtAllText(es *elasticsearch.Client, allText string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtAllText 根据全文本、发布日期小于检索books表并计算页数的最大值
// allText string 全文本
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtAllText(es *elasticsearch.Client, allText string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteAllText 根据全文本、发布日期小于等于检索books表并计算页数的最大值
// allText string 全文本
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteAllText(es *elasticsearch.Client, allText string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteAllText 根据全文本、发布日期大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteAllText 根据全文本、发布日期大于等于检索books表并计算价格的最大值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteAllText(es *elasticsearch.Client, allText string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtAllText 根据全文本、发布日期大于检索books表并计算价格的最大值
// allText string 全文本
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtAllText(es *elasticsearch.Client, allText string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtAllText 根据全文本、发布日期小于检索books表并计算价格的最大值
// allText string 全文本
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtAllText(es *elasticsearch.Client, allText string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteAllText 根据全文本、发布日期小于等于检索books表并计算价格的最大值
// allText string 全文本
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteAllText(es *elasticsearch.Client, allText string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteAllText 根据全文本、发布日期大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteAuthor 根据作者、页数大于等于检索books表并计算价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteAuthor(es *elasticsearch.Client, author string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtAuthor 根据作者、页数大于检索books表并计算价格的最大值
// author string 作者
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtAuthor(es *elasticsearch.Client, author string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtAuthor 根据作者、页数小于检索books表并计算价格的最大值
// author string 作者
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtAuthor(es *elasticsearch.Client, author string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteAuthor 根据作者、页数小于等于检索books表并计算价格的最大值
// author string 作者
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteAuthor(es *elasticsearch.Client, author string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteAuthor 根据作者、页数大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteAuthor 根据作者、价格大于等于检索books表并计算页数的最大值
// author string 作者
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteAuthor(es *elasticsearch.Client, author string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtAuthor 根据作者、价格大于检索books表并计算页数的最大值
// author string 作者
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtAuthor(es *elasticsearch.Client, author string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtAuthor 根据作者、价格小于检索books表并计算页数的最大值
// author string 作者
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtAuthor(es *elasticsearch.Client, author string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteAuthor 根据作者、价格小于等于检索books表并计算页数的最大值
// author string 作者
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteAuthor(es *elasticsearch.Client, author string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteAuthor 根据作者、价格大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteAuthor 根据作者、发布日期大于等于检索books表并计算页数的最大值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteAuthor(es *elasticsearch.Client, author string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtAuthor 根据作者、发布日期大于检索books表并计算页数的最大值
// author string 作者
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtAuthor(es *elasticsearch.Client, author string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtAuthor 根据作者、发布日期小于检索books表并计算页数的最大值
// author string 作者
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtAuthor(es *elasticsearch.Client, author string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteAuthor 根据作者、发布日期小于等于检索books表并计算页数的最大值
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteAuthor(es *elasticsearch.Client, author string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteAuthor 根据作者、发布日期大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteAuthor 根据作者、发布日期大于等于检索books表并计算价格的最大值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteAuthor(es *elasticsearch.Client, author string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtAuthor 根据作者、发布日期大于检索books表并计算价格的最大值
// author string 作者
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtAuthor(es *elasticsearch.Client, author string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtAuthor 根据作者、发布日期小于检索books表并计算价格的最大值
// author string 作者
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtAuthor(es *elasticsearch.Client, author string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteAuthor 根据作者、发布日期小于等于检索books表并计算价格的最大值
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteAuthor(es *elasticsearch.Client, author string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteAuthor 根据作者、发布日期大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteClass 根据类别、页数大于等于检索books表并计算价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteClass(es *elasticsearch.Client, class string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtClass 根据类别、页数大于检索books表并计算价格的最大值
// class string 类别
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtClass(es *elasticsearch.Client, class string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtClass 根据类别、页数小于检索books表并计算价格的最大值
// class string 类别
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtClass(es *elasticsearch.Client, class string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteClass 根据类别、页数小于等于检索books表并计算价格的最大值
// class string 类别
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteClass(es *elasticsearch.Client, class string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteClass 根据类别、页数大于等于和小于等于检索books表并计算价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteClass 根据类别、价格大于等于检索books表并计算页数的最大值
// class string 类别
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteClass(es *elasticsearch.Client, class string, priceGte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtClass 根据类别、价格大于检索books表并计算页数的最大值
// class string 类别
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtClass(es *elasticsearch.Client, class string, priceGt float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtClass 根据类别、价格小于检索books表并计算页数的最大值
// class string 类别
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtClass(es *elasticsearch.Client, class string, priceLt float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteClass 根据类别、价格小于等于检索books表并计算页数的最大值
// class string 类别
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteClass(es *elasticsearch.Client, class string, priceLte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteClass 根据类别、价格大于等于和小于等于检索books表并计算页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteClass(es *elasticsearch.Client, class string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteClass 根据类别、发布日期大于等于检索books表并计算页数的最大值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteClass(es *elasticsearch.Client, class string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtClass 根据类别、发布日期大于检索books表并计算页数的最大值
// class string 类别
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtClass(es *elasticsearch.Client, class string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtClass 根据类别、发布日期小于检索books表并计算页数的最大值
// class string 类别
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtClass(es *elasticsearch.Client, class string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteClass 根据类别、发布日期小于等于检索books表并计算页数的最大值
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteClass(es *elasticsearch.Client, class string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteClass 根据类别、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteClass(es *elasticsearch.Client, class string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteClass 根据类别、发布日期大于等于检索books表并计算价格的最大值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteClass(es *elasticsearch.Client, class string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtClass 根据类别、发布日期大于检索books表并计算价格的最大值
// class string 类别
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtClass(es *elasticsearch.Client, class string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtClass 根据类别、发布日期小于检索books表并计算价格的最大值
// class string 类别
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtClass(es *elasticsearch.Client, class string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteClass 根据类别、发布日期小于等于检索books表并计算价格的最大值
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteClass(es *elasticsearch.Client, class string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteClass 根据类别、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteClass(es *elasticsearch.Client, class string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteClass2 根据子类别、页数大于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteClass2(es *elasticsearch.Client, class2 string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtClass2 根据子类别、页数大于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtClass2(es *elasticsearch.Client, class2 string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtClass2 根据子类别、页数小于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtClass2(es *elasticsearch.Client, class2 string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteClass2 根据子类别、页数小于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteClass2(es *elasticsearch.Client, class2 string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteClass2 根据子类别、页数大于等于和小于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteClass2 根据子类别、价格大于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteClass2(es *elasticsearch.Client, class2 string, priceGte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtClass2 根据子类别、价格大于检索books表并计算页数的最大值
// class2 string 子类别
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtClass2(es *elasticsearch.Client, class2 string, priceGt float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtClass2 根据子类别、价格小于检索books表并计算页数的最大值
// class2 string 子类别
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtClass2(es *elasticsearch.Client, class2 string, priceLt float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteClass2 根据子类别、价格小于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteClass2(es *elasticsearch.Client, class2 string, priceLte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteClass2 根据子类别、价格大于等于和小于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteClass2 根据子类别、发布日期大于等于检索books表并计算页数的最大值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteClass2(es *elasticsearch.Client, class2 string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtClass2 根据子类别、发布日期大于检索books表并计算页数的最大值
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtClass2(es *elasticsearch.Client, class2 string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtClass2 根据子类别、发布日期小于检索books表并计算页数的最大值
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtClass2(es *elasticsearch.Client, class2 string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteClass2 根据子类别、发布日期小于等于检索books表并计算页数的最大值
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteClass2(es *elasticsearch.Client, class2 string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteClass2 根据子类别、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteClass2 根据子类别、发布日期大于等于检索books表并计算价格的最大值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteClass2(es *elasticsearch.Client, class2 string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtClass2 根据子类别、发布日期大于检索books表并计算价格的最大值
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtClass2(es *elasticsearch.Client, class2 string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtClass2 根据子类别、发布日期小于检索books表并计算价格的最大值
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtClass2(es *elasticsearch.Client, class2 string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteClass2 根据子类别、发布日期小于等于检索books表并计算价格的最大值
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteClass2(es *elasticsearch.Client, class2 string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteClass2 根据子类别、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteName 根据书名、页数大于等于检索books表并计算价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteName(es *elasticsearch.Client, name string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtName 根据书名、页数大于检索books表并计算价格的最大值
// name string 书名
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtName(es *elasticsearch.Client, name string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtName 根据书名、页数小于检索books表并计算价格的最大值
// name string 书名
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtName(es *elasticsearch.Client, name string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteName 根据书名、页数小于等于检索books表并计算价格的最大值
// name string 书名
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteName(es *elasticsearch.Client, name string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteName 根据书名、页数大于等于和小于等于检索books表并计算价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteName 根据书名、价格大于等于检索books表并计算页数的最大值
// name string 书名
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteName(es *elasticsearch.Client, name string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtName 根据书名、价格大于检索books表并计算页数的最大值
// name string 书名
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtName(es *elasticsearch.Client, name string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtName 根据书名、价格小于检索books表并计算页数的最大值
// name string 书名
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtName(es *elasticsearch.Client, name string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteName 根据书名、价格小于等于检索books表并计算页数的最大值
// name string 书名
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteName(es *elasticsearch.Client, name string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteName 根据书名、价格大于等于和小于等于检索books表并计算页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteName(es *elasticsearch.Client, name string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteName 根据书名、发布日期大于等于检索books表并计算页数的最大值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteName(es *elasticsearch.Client, name string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtName 根据书名、发布日期大于检索books表并计算页数的最大值
// name string 书名
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtName(es *elasticsearch.Client, name string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtName 根据书名、发布日期小于检索books表并计算页数的最大值
// name string 书名
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtName(es *elasticsearch.Client, name string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteName 根据书名、发布日期小于等于检索books表并计算页数的最大值
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteName(es *elasticsearch.Client, name string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteName 根据书名、发布日期大于等于和小于等于检索books表并计算页数的最大值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteName(es *elasticsearch.Client, name string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteName 根据书名、发布日期大于等于检索books表并计算价格的最大值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteName(es *elasticsearch.Client, name string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtName 根据书名、发布日期大于检索books表并计算价格的最大值
// name string 书名
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtName(es *elasticsearch.Client, name string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtName 根据书名、发布日期小于检索books表并计算价格的最大值
// name string 书名
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtName(es *elasticsearch.Client, name string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteName 根据书名、发布日期小于等于检索books表并计算价格的最大值
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteName(es *elasticsearch.Client, name string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteName 根据书名、发布日期大于等于和小于等于检索books表并计算价格的最大值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteName(es *elasticsearch.Client, name string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGte 根据页数大于等于、发布日期大于等于检索books表并计算价格的最大值
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGteReleaseDateGte(es *elasticsearch.Client, pageCountGte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGt 根据页数大于等于、发布日期大于检索books表并计算价格的最大值
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGteReleaseDateGt(es *elasticsearch.Client, pageCountGte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateLt 根据页数大于等于、发布日期小于检索books表并计算价格的最大值
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGteReleaseDateLt(es *elasticsearch.Client, pageCountGte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateLte 根据页数大于等于、发布日期小于等于检索books表并计算价格的最大值
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteReleaseDateLte(es *elasticsearch.Client, pageCountGte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGteLte 根据页数大于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteReleaseDateGteLte(es *elasticsearch.Client, pageCountGte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGte 根据页数大于、发布日期大于等于检索books表并计算价格的最大值
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGtReleaseDateGte(es *elasticsearch.Client, pageCountGt int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGt 根据页数大于、发布日期大于检索books表并计算价格的最大值
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGtReleaseDateGt(es *elasticsearch.Client, pageCountGt int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateLt 根据页数大于、发布日期小于检索books表并计算价格的最大值
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGtReleaseDateLt(es *elasticsearch.Client, pageCountGt int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateLte 根据页数大于、发布日期小于等于检索books表并计算价格的最大值
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGtReleaseDateLte(es *elasticsearch.Client, pageCountGt int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGteLte 根据页数大于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGtReleaseDateGteLte(es *elasticsearch.Client, pageCountGt int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGte 根据页数小于、发布日期大于等于检索books表并计算价格的最大值
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountLtReleaseDateGte(es *elasticsearch.Client, pageCountLt int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGt 根据页数小于、发布日期大于检索books表并计算价格的最大值
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountLtReleaseDateGt(es *elasticsearch.Client, pageCountLt int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateLt 根据页数小于、发布日期小于检索books表并计算价格的最大值
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountLtReleaseDateLt(es *elasticsearch.Client, pageCountLt int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateLte 根据页数小于、发布日期小于等于检索books表并计算价格的最大值
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLtReleaseDateLte(es *elasticsearch.Client, pageCountLt int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGteLte 根据页数小于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLtReleaseDateGteLte(es *elasticsearch.Client, pageCountLt int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGte 根据页数小于等于、发布日期大于等于检索books表并计算价格的最大值
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountLteReleaseDateGte(es *elasticsearch.Client, pageCountLte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGt 根据页数小于等于、发布日期大于检索books表并计算价格的最大值
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountLteReleaseDateGt(es *elasticsearch.Client, pageCountLte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateLt 根据页数小于等于、发布日期小于检索books表并计算价格的最大值
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountLteReleaseDateLt(es *elasticsearch.Client, pageCountLte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateLte 根据页数小于等于、发布日期小于等于检索books表并计算价格的最大值
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLteReleaseDateLte(es *elasticsearch.Client, pageCountLte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGteLte 根据页数小于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLteReleaseDateGteLte(es *elasticsearch.Client, pageCountLte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGte 根据页数大于等于和小于等于、发布日期大于等于检索books表并计算价格的最大值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGt 根据页数大于等于和小于等于、发布日期大于检索books表并计算价格的最大值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGt(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateLt 根据页数大于等于和小于等于、发布日期小于检索books表并计算价格的最大值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGteLteReleaseDateLt(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateLte 根据页数大于等于和小于等于、发布日期小于等于检索books表并计算价格的最大值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateLte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGteLte 根据页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGteLte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteSeq 根据编号、页数大于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteSeq(es *elasticsearch.Client, seq string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtSeq 根据编号、页数大于检索books表并计算价格的最大值
// seq string 编号
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtSeq(es *elasticsearch.Client, seq string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtSeq 根据编号、页数小于检索books表并计算价格的最大值
// seq string 编号
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtSeq(es *elasticsearch.Client, seq string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteSeq 根据编号、页数小于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteSeq(es *elasticsearch.Client, seq string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteSeq 根据编号、页数大于等于和小于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGte 根据价格大于等于、发布日期大于等于检索books表并计算页数的最大值
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGteReleaseDateGte(es *elasticsearch.Client, priceGte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGt 根据价格大于等于、发布日期大于检索books表并计算页数的最大值
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGteReleaseDateGt(es *elasticsearch.Client, priceGte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateLt 根据价格大于等于、发布日期小于检索books表并计算页数的最大值
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGteReleaseDateLt(es *elasticsearch.Client, priceGte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateLte 根据价格大于等于、发布日期小于等于检索books表并计算页数的最大值
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteReleaseDateLte(es *elasticsearch.Client, priceGte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGteLte 根据价格大于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteReleaseDateGteLte(es *elasticsearch.Client, priceGte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGte 根据价格大于、发布日期大于等于检索books表并计算页数的最大值
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGtReleaseDateGte(es *elasticsearch.Client, priceGt float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGt 根据价格大于、发布日期大于检索books表并计算页数的最大值
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGtReleaseDateGt(es *elasticsearch.Client, priceGt float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateLt 根据价格大于、发布日期小于检索books表并计算页数的最大值
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGtReleaseDateLt(es *elasticsearch.Client, priceGt float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateLte 根据价格大于、发布日期小于等于检索books表并计算页数的最大值
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGtReleaseDateLte(es *elasticsearch.Client, priceGt float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGteLte 根据价格大于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGtReleaseDateGteLte(es *elasticsearch.Client, priceGt float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGte 根据价格小于、发布日期大于等于检索books表并计算页数的最大值
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceLtReleaseDateGte(es *elasticsearch.Client, priceLt float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGt 根据价格小于、发布日期大于检索books表并计算页数的最大值
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceLtReleaseDateGt(es *elasticsearch.Client, priceLt float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateLt 根据价格小于、发布日期小于检索books表并计算页数的最大值
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceLtReleaseDateLt(es *elasticsearch.Client, priceLt float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateLte 根据价格小于、发布日期小于等于检索books表并计算页数的最大值
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLtReleaseDateLte(es *elasticsearch.Client, priceLt float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGteLte 根据价格小于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLtReleaseDateGteLte(es *elasticsearch.Client, priceLt float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGte 根据价格小于等于、发布日期大于等于检索books表并计算页数的最大值
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceLteReleaseDateGte(es *elasticsearch.Client, priceLte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGt 根据价格小于等于、发布日期大于检索books表并计算页数的最大值
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceLteReleaseDateGt(es *elasticsearch.Client, priceLte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateLt 根据价格小于等于、发布日期小于检索books表并计算页数的最大值
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceLteReleaseDateLt(es *elasticsearch.Client, priceLte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateLte 根据价格小于等于、发布日期小于等于检索books表并计算页数的最大值
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLteReleaseDateLte(es *elasticsearch.Client, priceLte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGteLte 根据价格小于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLteReleaseDateGteLte(es *elasticsearch.Client, priceLte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGte 根据价格大于等于和小于等于、发布日期大于等于检索books表并计算页数的最大值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGt 根据价格大于等于和小于等于、发布日期大于检索books表并计算页数的最大值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGt(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateLt 根据价格大于等于和小于等于、发布日期小于检索books表并计算页数的最大值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGteLteReleaseDateLt(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateLte 根据价格大于等于和小于等于、发布日期小于等于检索books表并计算页数的最大值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateLte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGteLte 根据价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGteLte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteSeq 根据编号、价格大于等于检索books表并计算页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteSeq(es *elasticsearch.Client, seq string, priceGte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtSeq 根据编号、价格大于检索books表并计算页数的最大值
// seq string 编号
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtSeq(es *elasticsearch.Client, seq string, priceGt float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtSeq 根据编号、价格小于检索books表并计算页数的最大值
// seq string 编号
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtSeq(es *elasticsearch.Client, seq string, priceLt float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteSeq 根据编号、价格小于等于检索books表并计算页数的最大值
// seq string 编号
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteSeq(es *elasticsearch.Client, seq string, priceLte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteSeq 根据编号、价格大于等于和小于等于检索books表并计算页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteSeq 根据编号、发布日期大于等于检索books表并计算页数的最大值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteSeq(es *elasticsearch.Client, seq string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtSeq 根据编号、发布日期大于检索books表并计算页数的最大值
// seq string 编号
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtSeq(es *elasticsearch.Client, seq string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtSeq 根据编号、发布日期小于检索books表并计算页数的最大值
// seq string 编号
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtSeq(es *elasticsearch.Client, seq string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteSeq 根据编号、发布日期小于等于检索books表并计算页数的最大值
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteSeq(es *elasticsearch.Client, seq string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteSeq 根据编号、发布日期大于等于和小于等于检索books表并计算页数的最大值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteSeq 根据编号、发布日期大于等于检索books表并计算价格的最大值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteSeq(es *elasticsearch.Client, seq string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtSeq 根据编号、发布日期大于检索books表并计算价格的最大值
// seq string 编号
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtSeq(es *elasticsearch.Client, seq string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtSeq 根据编号、发布日期小于检索books表并计算价格的最大值
// seq string 编号
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtSeq(es *elasticsearch.Client, seq string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteSeq 根据编号、发布日期小于等于检索books表并计算价格的最大值
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteSeq(es *elasticsearch.Client, seq string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteSeq 根据编号、发布日期大于等于和小于等于检索books表并计算价格的最大值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteAllTextAuthor 根据全文本、作者、页数大于等于检索books表并计算价格的最大值
// allText string 全文本
// author string 作者
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtAllTextAuthor 根据全文本、作者、页数大于检索books表并计算价格的最大值
// allText string 全文本
// author string 作者
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtAllTextAuthor 根据全文本、作者、页数小于检索books表并计算价格的最大值
// allText string 全文本
// author string 作者
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteAllTextAuthor 根据全文本、作者、页数小于等于检索books表并计算价格的最大值
// allText string 全文本
// author string 作者
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteAllTextAuthor 根据全文本、作者、页数大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteAllTextAuthor 根据全文本、作者、价格大于等于检索books表并计算页数的最大值
// allText string 全文本
// author string 作者
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteAllTextAuthor(es *elasticsearch.Client, allText, author string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtAllTextAuthor 根据全文本、作者、价格大于检索books表并计算页数的最大值
// allText string 全文本
// author string 作者
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtAllTextAuthor(es *elasticsearch.Client, allText, author string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtAllTextAuthor 根据全文本、作者、价格小于检索books表并计算页数的最大值
// allText string 全文本
// author string 作者
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtAllTextAuthor(es *elasticsearch.Client, allText, author string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteAllTextAuthor 根据全文本、作者、价格小于等于检索books表并计算页数的最大值
// allText string 全文本
// author string 作者
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteAllTextAuthor(es *elasticsearch.Client, allText, author string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteAllTextAuthor 根据全文本、作者、价格大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteAllTextAuthor 根据全文本、作者、发布日期大于等于检索books表并计算页数的最大值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtAllTextAuthor 根据全文本、作者、发布日期大于检索books表并计算页数的最大值
// allText string 全文本
// author string 作者
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtAllTextAuthor 根据全文本、作者、发布日期小于检索books表并计算页数的最大值
// allText string 全文本
// author string 作者
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteAllTextAuthor 根据全文本、作者、发布日期小于等于检索books表并计算页数的最大值
// allText string 全文本
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteAllTextAuthor 根据全文本、作者、发布日期大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteAllTextAuthor 根据全文本、作者、发布日期大于等于检索books表并计算价格的最大值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtAllTextAuthor 根据全文本、作者、发布日期大于检索books表并计算价格的最大值
// allText string 全文本
// author string 作者
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtAllTextAuthor 根据全文本、作者、发布日期小于检索books表并计算价格的最大值
// allText string 全文本
// author string 作者
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteAllTextAuthor 根据全文本、作者、发布日期小于等于检索books表并计算价格的最大值
// allText string 全文本
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteAllTextAuthor 根据全文本、作者、发布日期大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteAllTextClass 根据全文本、类别、页数大于等于检索books表并计算价格的最大值
// allText string 全文本
// class string 类别
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteAllTextClass(es *elasticsearch.Client, allText, class string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtAllTextClass 根据全文本、类别、页数大于检索books表并计算价格的最大值
// allText string 全文本
// class string 类别
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtAllTextClass(es *elasticsearch.Client, allText, class string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtAllTextClass 根据全文本、类别、页数小于检索books表并计算价格的最大值
// allText string 全文本
// class string 类别
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtAllTextClass(es *elasticsearch.Client, allText, class string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteAllTextClass 根据全文本、类别、页数小于等于检索books表并计算价格的最大值
// allText string 全文本
// class string 类别
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteAllTextClass(es *elasticsearch.Client, allText, class string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteAllTextClass 根据全文本、类别、页数大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteAllTextClass(es *elasticsearch.Client, allText, class string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteAllTextClass 根据全文本、类别、价格大于等于检索books表并计算页数的最大值
// allText string 全文本
// class string 类别
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteAllTextClass(es *elasticsearch.Client, allText, class string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtAllTextClass 根据全文本、类别、价格大于检索books表并计算页数的最大值
// allText string 全文本
// class string 类别
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtAllTextClass(es *elasticsearch.Client, allText, class string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtAllTextClass 根据全文本、类别、价格小于检索books表并计算页数的最大值
// allText string 全文本
// class string 类别
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtAllTextClass(es *elasticsearch.Client, allText, class string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteAllTextClass 根据全文本、类别、价格小于等于检索books表并计算页数的最大值
// allText string 全文本
// class string 类别
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteAllTextClass(es *elasticsearch.Client, allText, class string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteAllTextClass 根据全文本、类别、价格大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteAllTextClass(es *elasticsearch.Client, allText, class string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteAllTextClass 根据全文本、类别、发布日期大于等于检索books表并计算页数的最大值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtAllTextClass 根据全文本、类别、发布日期大于检索books表并计算页数的最大值
// allText string 全文本
// class string 类别
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtAllTextClass 根据全文本、类别、发布日期小于检索books表并计算页数的最大值
// allText string 全文本
// class string 类别
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteAllTextClass 根据全文本、类别、发布日期小于等于检索books表并计算页数的最大值
// allText string 全文本
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteAllTextClass 根据全文本、类别、发布日期大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteAllTextClass 根据全文本、类别、发布日期大于等于检索books表并计算价格的最大值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtAllTextClass 根据全文本、类别、发布日期大于检索books表并计算价格的最大值
// allText string 全文本
// class string 类别
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtAllTextClass 根据全文本、类别、发布日期小于检索books表并计算价格的最大值
// allText string 全文本
// class string 类别
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteAllTextClass 根据全文本、类别、发布日期小于等于检索books表并计算价格的最大值
// allText string 全文本
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteAllTextClass 根据全文本、类别、发布日期大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteAllTextClass2 根据全文本、子类别、页数大于等于检索books表并计算价格的最大值
// allText string 全文本
// class2 string 子类别
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtAllTextClass2 根据全文本、子类别、页数大于检索books表并计算价格的最大值
// allText string 全文本
// class2 string 子类别
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtAllTextClass2 根据全文本、子类别、页数小于检索books表并计算价格的最大值
// allText string 全文本
// class2 string 子类别
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteAllTextClass2 根据全文本、子类别、页数小于等于检索books表并计算价格的最大值
// allText string 全文本
// class2 string 子类别
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteAllTextClass2 根据全文本、子类别、页数大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteAllTextClass2 根据全文本、子类别、价格大于等于检索books表并计算页数的最大值
// allText string 全文本
// class2 string 子类别
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtAllTextClass2 根据全文本、子类别、价格大于检索books表并计算页数的最大值
// allText string 全文本
// class2 string 子类别
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtAllTextClass2 根据全文本、子类别、价格小于检索books表并计算页数的最大值
// allText string 全文本
// class2 string 子类别
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteAllTextClass2 根据全文本、子类别、价格小于等于检索books表并计算页数的最大值
// allText string 全文本
// class2 string 子类别
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteAllTextClass2 根据全文本、子类别、价格大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteAllTextClass2 根据全文本、子类别、发布日期大于等于检索books表并计算页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtAllTextClass2 根据全文本、子类别、发布日期大于检索books表并计算页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtAllTextClass2 根据全文本、子类别、发布日期小于检索books表并计算页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteAllTextClass2 根据全文本、子类别、发布日期小于等于检索books表并计算页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteAllTextClass2 根据全文本、子类别、发布日期大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteAllTextClass2 根据全文本、子类别、发布日期大于等于检索books表并计算价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtAllTextClass2 根据全文本、子类别、发布日期大于检索books表并计算价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtAllTextClass2 根据全文本、子类别、发布日期小于检索books表并计算价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteAllTextClass2 根据全文本、子类别、发布日期小于等于检索books表并计算价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteAllTextClass2 根据全文本、子类别、发布日期大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteAllTextName 根据全文本、书名、页数大于等于检索books表并计算价格的最大值
// allText string 全文本
// name string 书名
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteAllTextName(es *elasticsearch.Client, allText, name string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtAllTextName 根据全文本、书名、页数大于检索books表并计算价格的最大值
// allText string 全文本
// name string 书名
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtAllTextName(es *elasticsearch.Client, allText, name string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtAllTextName 根据全文本、书名、页数小于检索books表并计算价格的最大值
// allText string 全文本
// name string 书名
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtAllTextName(es *elasticsearch.Client, allText, name string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteAllTextName 根据全文本、书名、页数小于等于检索books表并计算价格的最大值
// allText string 全文本
// name string 书名
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteAllTextName(es *elasticsearch.Client, allText, name string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteAllTextName 根据全文本、书名、页数大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteAllTextName(es *elasticsearch.Client, allText, name string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteAllTextName 根据全文本、书名、价格大于等于检索books表并计算页数的最大值
// allText string 全文本
// name string 书名
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteAllTextName(es *elasticsearch.Client, allText, name string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtAllTextName 根据全文本、书名、价格大于检索books表并计算页数的最大值
// allText string 全文本
// name string 书名
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtAllTextName(es *elasticsearch.Client, allText, name string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtAllTextName 根据全文本、书名、价格小于检索books表并计算页数的最大值
// allText string 全文本
// name string 书名
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtAllTextName(es *elasticsearch.Client, allText, name string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteAllTextName 根据全文本、书名、价格小于等于检索books表并计算页数的最大值
// allText string 全文本
// name string 书名
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteAllTextName(es *elasticsearch.Client, allText, name string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteAllTextName 根据全文本、书名、价格大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteAllTextName(es *elasticsearch.Client, allText, name string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteAllTextName 根据全文本、书名、发布日期大于等于检索books表并计算页数的最大值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtAllTextName 根据全文本、书名、发布日期大于检索books表并计算页数的最大值
// allText string 全文本
// name string 书名
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtAllTextName 根据全文本、书名、发布日期小于检索books表并计算页数的最大值
// allText string 全文本
// name string 书名
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteAllTextName 根据全文本、书名、发布日期小于等于检索books表并计算页数的最大值
// allText string 全文本
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteAllTextName 根据全文本、书名、发布日期大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteAllTextName 根据全文本、书名、发布日期大于等于检索books表并计算价格的最大值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtAllTextName 根据全文本、书名、发布日期大于检索books表并计算价格的最大值
// allText string 全文本
// name string 书名
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtAllTextName 根据全文本、书名、发布日期小于检索books表并计算价格的最大值
// allText string 全文本
// name string 书名
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteAllTextName 根据全文本、书名、发布日期小于等于检索books表并计算价格的最大值
// allText string 全文本
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteAllTextName 根据全文本、书名、发布日期大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGteAllText 根据全文本、页数大于等于、发布日期大于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGteReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGtAllText 根据全文本、页数大于等于、发布日期大于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGteReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateLtAllText 根据全文本、页数大于等于、发布日期小于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGteReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateLteAllText 根据全文本、页数大于等于、发布日期小于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGteLteAllText 根据全文本、页数大于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGteAllText 根据全文本、页数大于、发布日期大于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGtReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGtAllText 根据全文本、页数大于、发布日期大于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGtReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateLtAllText 根据全文本、页数大于、发布日期小于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGtReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateLteAllText 根据全文本、页数大于、发布日期小于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGtReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGteLteAllText 根据全文本、页数大于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGtReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGteAllText 根据全文本、页数小于、发布日期大于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountLtReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGtAllText 根据全文本、页数小于、发布日期大于检索books表并计算价格的最大值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountLtReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateLtAllText 根据全文本、页数小于、发布日期小于检索books表并计算价格的最大值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountLtReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateLteAllText 根据全文本、页数小于、发布日期小于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLtReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGteLteAllText 根据全文本、页数小于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLtReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGteAllText 根据全文本、页数小于等于、发布日期大于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountLteReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGtAllText 根据全文本、页数小于等于、发布日期大于检索books表并计算价格的最大值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountLteReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateLtAllText 根据全文本、页数小于等于、发布日期小于检索books表并计算价格的最大值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountLteReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateLteAllText 根据全文本、页数小于等于、发布日期小于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLteReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGteLteAllText 根据全文本、页数小于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGteAllText 根据全文本、页数大于等于和小于等于、发布日期大于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGtAllText 根据全文本、页数大于等于和小于等于、发布日期大于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateLtAllText 根据全文本、页数大于等于和小于等于、发布日期小于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGteLteReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateLteAllText 根据全文本、页数大于等于和小于等于、发布日期小于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGteLteAllText 根据全文本、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteAllTextSeq 根据全文本、编号、页数大于等于检索books表并计算价格的最大值
// allText string 全文本
// seq string 编号
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtAllTextSeq 根据全文本、编号、页数大于检索books表并计算价格的最大值
// allText string 全文本
// seq string 编号
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtAllTextSeq 根据全文本、编号、页数小于检索books表并计算价格的最大值
// allText string 全文本
// seq string 编号
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteAllTextSeq 根据全文本、编号、页数小于等于检索books表并计算价格的最大值
// allText string 全文本
// seq string 编号
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteAllTextSeq 根据全文本、编号、页数大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGteAllText 根据全文本、价格大于等于、发布日期大于等于检索books表并计算页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGteReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGtAllText 根据全文本、价格大于等于、发布日期大于检索books表并计算页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGteReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateLtAllText 根据全文本、价格大于等于、发布日期小于检索books表并计算页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGteReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateLteAllText 根据全文本、价格大于等于、发布日期小于等于检索books表并计算页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGteLteAllText 根据全文本、价格大于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGteAllText 根据全文本、价格大于、发布日期大于等于检索books表并计算页数的最大值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGtReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGtAllText 根据全文本、价格大于、发布日期大于检索books表并计算页数的最大值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGtReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateLtAllText 根据全文本、价格大于、发布日期小于检索books表并计算页数的最大值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGtReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateLteAllText 根据全文本、价格大于、发布日期小于等于检索books表并计算页数的最大值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGtReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGteLteAllText 根据全文本、价格大于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGtReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGteAllText 根据全文本、价格小于、发布日期大于等于检索books表并计算页数的最大值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceLtReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGtAllText 根据全文本、价格小于、发布日期大于检索books表并计算页数的最大值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceLtReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateLtAllText 根据全文本、价格小于、发布日期小于检索books表并计算页数的最大值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceLtReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateLteAllText 根据全文本、价格小于、发布日期小于等于检索books表并计算页数的最大值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLtReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGteLteAllText 根据全文本、价格小于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLtReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGteAllText 根据全文本、价格小于等于、发布日期大于等于检索books表并计算页数的最大值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceLteReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGtAllText 根据全文本、价格小于等于、发布日期大于检索books表并计算页数的最大值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceLteReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateLtAllText 根据全文本、价格小于等于、发布日期小于检索books表并计算页数的最大值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceLteReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateLteAllText 根据全文本、价格小于等于、发布日期小于等于检索books表并计算页数的最大值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLteReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGteLteAllText 根据全文本、价格小于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGteAllText 根据全文本、价格大于等于和小于等于、发布日期大于等于检索books表并计算页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGtAllText 根据全文本、价格大于等于和小于等于、发布日期大于检索books表并计算页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateLtAllText 根据全文本、价格大于等于和小于等于、发布日期小于检索books表并计算页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGteLteReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateLteAllText 根据全文本、价格大于等于和小于等于、发布日期小于等于检索books表并计算页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGteLteAllText 根据全文本、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteAllTextSeq 根据全文本、编号、价格大于等于检索books表并计算页数的最大值
// allText string 全文本
// seq string 编号
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteAllTextSeq(es *elasticsearch.Client, allText, seq string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtAllTextSeq 根据全文本、编号、价格大于检索books表并计算页数的最大值
// allText string 全文本
// seq string 编号
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtAllTextSeq(es *elasticsearch.Client, allText, seq string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtAllTextSeq 根据全文本、编号、价格小于检索books表并计算页数的最大值
// allText string 全文本
// seq string 编号
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtAllTextSeq(es *elasticsearch.Client, allText, seq string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteAllTextSeq 根据全文本、编号、价格小于等于检索books表并计算页数的最大值
// allText string 全文本
// seq string 编号
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteAllTextSeq(es *elasticsearch.Client, allText, seq string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteAllTextSeq 根据全文本、编号、价格大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteAllTextSeq 根据全文本、编号、发布日期大于等于检索books表并计算页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtAllTextSeq 根据全文本、编号、发布日期大于检索books表并计算页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtAllTextSeq 根据全文本、编号、发布日期小于检索books表并计算页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteAllTextSeq 根据全文本、编号、发布日期小于等于检索books表并计算页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteAllTextSeq 根据全文本、编号、发布日期大于等于和小于等于检索books表并计算页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteAllTextSeq 根据全文本、编号、发布日期大于等于检索books表并计算价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtAllTextSeq 根据全文本、编号、发布日期大于检索books表并计算价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtAllTextSeq 根据全文本、编号、发布日期小于检索books表并计算价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteAllTextSeq 根据全文本、编号、发布日期小于等于检索books表并计算价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteAllTextSeq 根据全文本、编号、发布日期大于等于和小于等于检索books表并计算价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteAuthorClass 根据作者、类别、页数大于等于检索books表并计算价格的最大值
// author string 作者
// class string 类别
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteAuthorClass(es *elasticsearch.Client, author, class string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtAuthorClass 根据作者、类别、页数大于检索books表并计算价格的最大值
// author string 作者
// class string 类别
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtAuthorClass(es *elasticsearch.Client, author, class string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtAuthorClass 根据作者、类别、页数小于检索books表并计算价格的最大值
// author string 作者
// class string 类别
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtAuthorClass(es *elasticsearch.Client, author, class string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteAuthorClass 根据作者、类别、页数小于等于检索books表并计算价格的最大值
// author string 作者
// class string 类别
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteAuthorClass(es *elasticsearch.Client, author, class string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteAuthorClass 根据作者、类别、页数大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteAuthorClass(es *elasticsearch.Client, author, class string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteAuthorClass 根据作者、类别、价格大于等于检索books表并计算页数的最大值
// author string 作者
// class string 类别
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteAuthorClass(es *elasticsearch.Client, author, class string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtAuthorClass 根据作者、类别、价格大于检索books表并计算页数的最大值
// author string 作者
// class string 类别
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtAuthorClass(es *elasticsearch.Client, author, class string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtAuthorClass 根据作者、类别、价格小于检索books表并计算页数的最大值
// author string 作者
// class string 类别
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtAuthorClass(es *elasticsearch.Client, author, class string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteAuthorClass 根据作者、类别、价格小于等于检索books表并计算页数的最大值
// author string 作者
// class string 类别
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteAuthorClass(es *elasticsearch.Client, author, class string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteAuthorClass 根据作者、类别、价格大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteAuthorClass(es *elasticsearch.Client, author, class string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteAuthorClass 根据作者、类别、发布日期大于等于检索books表并计算页数的最大值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtAuthorClass 根据作者、类别、发布日期大于检索books表并计算页数的最大值
// author string 作者
// class string 类别
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtAuthorClass 根据作者、类别、发布日期小于检索books表并计算页数的最大值
// author string 作者
// class string 类别
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteAuthorClass 根据作者、类别、发布日期小于等于检索books表并计算页数的最大值
// author string 作者
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteAuthorClass 根据作者、类别、发布日期大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteAuthorClass 根据作者、类别、发布日期大于等于检索books表并计算价格的最大值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtAuthorClass 根据作者、类别、发布日期大于检索books表并计算价格的最大值
// author string 作者
// class string 类别
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtAuthorClass 根据作者、类别、发布日期小于检索books表并计算价格的最大值
// author string 作者
// class string 类别
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteAuthorClass 根据作者、类别、发布日期小于等于检索books表并计算价格的最大值
// author string 作者
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteAuthorClass 根据作者、类别、发布日期大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteAuthorClass2 根据作者、子类别、页数大于等于检索books表并计算价格的最大值
// author string 作者
// class2 string 子类别
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtAuthorClass2 根据作者、子类别、页数大于检索books表并计算价格的最大值
// author string 作者
// class2 string 子类别
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtAuthorClass2 根据作者、子类别、页数小于检索books表并计算价格的最大值
// author string 作者
// class2 string 子类别
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteAuthorClass2 根据作者、子类别、页数小于等于检索books表并计算价格的最大值
// author string 作者
// class2 string 子类别
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteAuthorClass2 根据作者、子类别、页数大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteAuthorClass2 根据作者、子类别、价格大于等于检索books表并计算页数的最大值
// author string 作者
// class2 string 子类别
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteAuthorClass2(es *elasticsearch.Client, author, class2 string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtAuthorClass2 根据作者、子类别、价格大于检索books表并计算页数的最大值
// author string 作者
// class2 string 子类别
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtAuthorClass2(es *elasticsearch.Client, author, class2 string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtAuthorClass2 根据作者、子类别、价格小于检索books表并计算页数的最大值
// author string 作者
// class2 string 子类别
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtAuthorClass2(es *elasticsearch.Client, author, class2 string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteAuthorClass2 根据作者、子类别、价格小于等于检索books表并计算页数的最大值
// author string 作者
// class2 string 子类别
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteAuthorClass2(es *elasticsearch.Client, author, class2 string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteAuthorClass2 根据作者、子类别、价格大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteAuthorClass2 根据作者、子类别、发布日期大于等于检索books表并计算页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtAuthorClass2 根据作者、子类别、发布日期大于检索books表并计算页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtAuthorClass2 根据作者、子类别、发布日期小于检索books表并计算页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteAuthorClass2 根据作者、子类别、发布日期小于等于检索books表并计算页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteAuthorClass2 根据作者、子类别、发布日期大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteAuthorClass2 根据作者、子类别、发布日期大于等于检索books表并计算价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtAuthorClass2 根据作者、子类别、发布日期大于检索books表并计算价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtAuthorClass2 根据作者、子类别、发布日期小于检索books表并计算价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteAuthorClass2 根据作者、子类别、发布日期小于等于检索books表并计算价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteAuthorClass2 根据作者、子类别、发布日期大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteAuthorName 根据作者、书名、页数大于等于检索books表并计算价格的最大值
// author string 作者
// name string 书名
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteAuthorName(es *elasticsearch.Client, author, name string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtAuthorName 根据作者、书名、页数大于检索books表并计算价格的最大值
// author string 作者
// name string 书名
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtAuthorName(es *elasticsearch.Client, author, name string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtAuthorName 根据作者、书名、页数小于检索books表并计算价格的最大值
// author string 作者
// name string 书名
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtAuthorName(es *elasticsearch.Client, author, name string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteAuthorName 根据作者、书名、页数小于等于检索books表并计算价格的最大值
// author string 作者
// name string 书名
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteAuthorName(es *elasticsearch.Client, author, name string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteAuthorName 根据作者、书名、页数大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteAuthorName(es *elasticsearch.Client, author, name string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteAuthorName 根据作者、书名、价格大于等于检索books表并计算页数的最大值
// author string 作者
// name string 书名
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteAuthorName(es *elasticsearch.Client, author, name string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtAuthorName 根据作者、书名、价格大于检索books表并计算页数的最大值
// author string 作者
// name string 书名
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtAuthorName(es *elasticsearch.Client, author, name string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtAuthorName 根据作者、书名、价格小于检索books表并计算页数的最大值
// author string 作者
// name string 书名
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtAuthorName(es *elasticsearch.Client, author, name string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteAuthorName 根据作者、书名、价格小于等于检索books表并计算页数的最大值
// author string 作者
// name string 书名
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteAuthorName(es *elasticsearch.Client, author, name string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteAuthorName 根据作者、书名、价格大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteAuthorName(es *elasticsearch.Client, author, name string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteAuthorName 根据作者、书名、发布日期大于等于检索books表并计算页数的最大值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtAuthorName 根据作者、书名、发布日期大于检索books表并计算页数的最大值
// author string 作者
// name string 书名
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtAuthorName(es *elasticsearch.Client, author, name string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtAuthorName 根据作者、书名、发布日期小于检索books表并计算页数的最大值
// author string 作者
// name string 书名
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtAuthorName(es *elasticsearch.Client, author, name string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteAuthorName 根据作者、书名、发布日期小于等于检索books表并计算页数的最大值
// author string 作者
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteAuthorName 根据作者、书名、发布日期大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteAuthorName 根据作者、书名、发布日期大于等于检索books表并计算价格的最大值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtAuthorName 根据作者、书名、发布日期大于检索books表并计算价格的最大值
// author string 作者
// name string 书名
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtAuthorName(es *elasticsearch.Client, author, name string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtAuthorName 根据作者、书名、发布日期小于检索books表并计算价格的最大值
// author string 作者
// name string 书名
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtAuthorName(es *elasticsearch.Client, author, name string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteAuthorName 根据作者、书名、发布日期小于等于检索books表并计算价格的最大值
// author string 作者
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteAuthorName 根据作者、书名、发布日期大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGteAuthor 根据作者、页数大于等于、发布日期大于等于检索books表并计算价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGteReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGtAuthor 根据作者、页数大于等于、发布日期大于检索books表并计算价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGteReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateLtAuthor 根据作者、页数大于等于、发布日期小于检索books表并计算价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGteReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateLteAuthor 根据作者、页数大于等于、发布日期小于等于检索books表并计算价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGteLteAuthor 根据作者、页数大于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGteAuthor 根据作者、页数大于、发布日期大于等于检索books表并计算价格的最大值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGtReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGtAuthor 根据作者、页数大于、发布日期大于检索books表并计算价格的最大值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGtReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateLtAuthor 根据作者、页数大于、发布日期小于检索books表并计算价格的最大值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGtReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateLteAuthor 根据作者、页数大于、发布日期小于等于检索books表并计算价格的最大值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGtReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGteLteAuthor 根据作者、页数大于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGtReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGteAuthor 根据作者、页数小于、发布日期大于等于检索books表并计算价格的最大值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountLtReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGtAuthor 根据作者、页数小于、发布日期大于检索books表并计算价格的最大值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountLtReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateLtAuthor 根据作者、页数小于、发布日期小于检索books表并计算价格的最大值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountLtReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateLteAuthor 根据作者、页数小于、发布日期小于等于检索books表并计算价格的最大值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLtReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGteLteAuthor 根据作者、页数小于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLtReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGteAuthor 根据作者、页数小于等于、发布日期大于等于检索books表并计算价格的最大值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountLteReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGtAuthor 根据作者、页数小于等于、发布日期大于检索books表并计算价格的最大值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountLteReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateLtAuthor 根据作者、页数小于等于、发布日期小于检索books表并计算价格的最大值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountLteReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateLteAuthor 根据作者、页数小于等于、发布日期小于等于检索books表并计算价格的最大值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLteReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGteLteAuthor 根据作者、页数小于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGteAuthor 根据作者、页数大于等于和小于等于、发布日期大于等于检索books表并计算价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGtAuthor 根据作者、页数大于等于和小于等于、发布日期大于检索books表并计算价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateLtAuthor 根据作者、页数大于等于和小于等于、发布日期小于检索books表并计算价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGteLteReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateLteAuthor 根据作者、页数大于等于和小于等于、发布日期小于等于检索books表并计算价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGteLteAuthor 根据作者、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteAuthorSeq 根据作者、编号、页数大于等于检索books表并计算价格的最大值
// author string 作者
// seq string 编号
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtAuthorSeq 根据作者、编号、页数大于检索books表并计算价格的最大值
// author string 作者
// seq string 编号
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtAuthorSeq 根据作者、编号、页数小于检索books表并计算价格的最大值
// author string 作者
// seq string 编号
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteAuthorSeq 根据作者、编号、页数小于等于检索books表并计算价格的最大值
// author string 作者
// seq string 编号
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteAuthorSeq 根据作者、编号、页数大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGteAuthor 根据作者、价格大于等于、发布日期大于等于检索books表并计算页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGteReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGtAuthor 根据作者、价格大于等于、发布日期大于检索books表并计算页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGteReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateLtAuthor 根据作者、价格大于等于、发布日期小于检索books表并计算页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGteReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateLteAuthor 根据作者、价格大于等于、发布日期小于等于检索books表并计算页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGteLteAuthor 根据作者、价格大于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGteAuthor 根据作者、价格大于、发布日期大于等于检索books表并计算页数的最大值
// author string 作者
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGtReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGtAuthor 根据作者、价格大于、发布日期大于检索books表并计算页数的最大值
// author string 作者
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGtReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateLtAuthor 根据作者、价格大于、发布日期小于检索books表并计算页数的最大值
// author string 作者
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGtReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateLteAuthor 根据作者、价格大于、发布日期小于等于检索books表并计算页数的最大值
// author string 作者
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGtReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGteLteAuthor 根据作者、价格大于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGtReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGteAuthor 根据作者、价格小于、发布日期大于等于检索books表并计算页数的最大值
// author string 作者
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceLtReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGtAuthor 根据作者、价格小于、发布日期大于检索books表并计算页数的最大值
// author string 作者
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceLtReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateLtAuthor 根据作者、价格小于、发布日期小于检索books表并计算页数的最大值
// author string 作者
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceLtReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateLteAuthor 根据作者、价格小于、发布日期小于等于检索books表并计算页数的最大值
// author string 作者
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLtReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGteLteAuthor 根据作者、价格小于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLtReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGteAuthor 根据作者、价格小于等于、发布日期大于等于检索books表并计算页数的最大值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceLteReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGtAuthor 根据作者、价格小于等于、发布日期大于检索books表并计算页数的最大值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceLteReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateLtAuthor 根据作者、价格小于等于、发布日期小于检索books表并计算页数的最大值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceLteReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateLteAuthor 根据作者、价格小于等于、发布日期小于等于检索books表并计算页数的最大值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLteReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGteLteAuthor 根据作者、价格小于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGteAuthor 根据作者、价格大于等于和小于等于、发布日期大于等于检索books表并计算页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGtAuthor 根据作者、价格大于等于和小于等于、发布日期大于检索books表并计算页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateLtAuthor 根据作者、价格大于等于和小于等于、发布日期小于检索books表并计算页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGteLteReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateLteAuthor 根据作者、价格大于等于和小于等于、发布日期小于等于检索books表并计算页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGteLteAuthor 根据作者、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteAuthorSeq 根据作者、编号、价格大于等于检索books表并计算页数的最大值
// author string 作者
// seq string 编号
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteAuthorSeq(es *elasticsearch.Client, author, seq string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtAuthorSeq 根据作者、编号、价格大于检索books表并计算页数的最大值
// author string 作者
// seq string 编号
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtAuthorSeq(es *elasticsearch.Client, author, seq string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtAuthorSeq 根据作者、编号、价格小于检索books表并计算页数的最大值
// author string 作者
// seq string 编号
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtAuthorSeq(es *elasticsearch.Client, author, seq string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteAuthorSeq 根据作者、编号、价格小于等于检索books表并计算页数的最大值
// author string 作者
// seq string 编号
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteAuthorSeq(es *elasticsearch.Client, author, seq string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteAuthorSeq 根据作者、编号、价格大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteAuthorSeq 根据作者、编号、发布日期大于等于检索books表并计算页数的最大值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtAuthorSeq 根据作者、编号、发布日期大于检索books表并计算页数的最大值
// author string 作者
// seq string 编号
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtAuthorSeq 根据作者、编号、发布日期小于检索books表并计算页数的最大值
// author string 作者
// seq string 编号
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteAuthorSeq 根据作者、编号、发布日期小于等于检索books表并计算页数的最大值
// author string 作者
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteAuthorSeq 根据作者、编号、发布日期大于等于和小于等于检索books表并计算页数的最大值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteAuthorSeq 根据作者、编号、发布日期大于等于检索books表并计算价格的最大值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtAuthorSeq 根据作者、编号、发布日期大于检索books表并计算价格的最大值
// author string 作者
// seq string 编号
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtAuthorSeq 根据作者、编号、发布日期小于检索books表并计算价格的最大值
// author string 作者
// seq string 编号
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteAuthorSeq 根据作者、编号、发布日期小于等于检索books表并计算价格的最大值
// author string 作者
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteAuthorSeq 根据作者、编号、发布日期大于等于和小于等于检索books表并计算价格的最大值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteClassClass2 根据类别、子类别、页数大于等于检索books表并计算价格的最大值
// class string 类别
// class2 string 子类别
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteClassClass2(es *elasticsearch.Client, class, class2 string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtClassClass2 根据类别、子类别、页数大于检索books表并计算价格的最大值
// class string 类别
// class2 string 子类别
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtClassClass2(es *elasticsearch.Client, class, class2 string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtClassClass2 根据类别、子类别、页数小于检索books表并计算价格的最大值
// class string 类别
// class2 string 子类别
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtClassClass2(es *elasticsearch.Client, class, class2 string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteClassClass2 根据类别、子类别、页数小于等于检索books表并计算价格的最大值
// class string 类别
// class2 string 子类别
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteClassClass2(es *elasticsearch.Client, class, class2 string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteClassClass2 根据类别、子类别、页数大于等于和小于等于检索books表并计算价格的最大值
// class string 类别
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteClassClass2(es *elasticsearch.Client, class, class2 string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteClassClass2 根据类别、子类别、价格大于等于检索books表并计算页数的最大值
// class string 类别
// class2 string 子类别
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteClassClass2(es *elasticsearch.Client, class, class2 string, priceGte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtClassClass2 根据类别、子类别、价格大于检索books表并计算页数的最大值
// class string 类别
// class2 string 子类别
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtClassClass2(es *elasticsearch.Client, class, class2 string, priceGt float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtClassClass2 根据类别、子类别、价格小于检索books表并计算页数的最大值
// class string 类别
// class2 string 子类别
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtClassClass2(es *elasticsearch.Client, class, class2 string, priceLt float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteClassClass2 根据类别、子类别、价格小于等于检索books表并计算页数的最大值
// class string 类别
// class2 string 子类别
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteClassClass2(es *elasticsearch.Client, class, class2 string, priceLte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteClassClass2 根据类别、子类别、价格大于等于和小于等于检索books表并计算页数的最大值
// class string 类别
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteClassClass2(es *elasticsearch.Client, class, class2 string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteClassClass2 根据类别、子类别、发布日期大于等于检索books表并计算页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtClassClass2 根据类别、子类别、发布日期大于检索books表并计算页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtClassClass2 根据类别、子类别、发布日期小于检索books表并计算页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteClassClass2 根据类别、子类别、发布日期小于等于检索books表并计算页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteClassClass2 根据类别、子类别、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteClassClass2 根据类别、子类别、发布日期大于等于检索books表并计算价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtClassClass2 根据类别、子类别、发布日期大于检索books表并计算价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtClassClass2 根据类别、子类别、发布日期小于检索books表并计算价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteClassClass2 根据类别、子类别、发布日期小于等于检索books表并计算价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteClassClass2 根据类别、子类别、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteClassName 根据类别、书名、页数大于等于检索books表并计算价格的最大值
// class string 类别
// name string 书名
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteClassName(es *elasticsearch.Client, class, name string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtClassName 根据类别、书名、页数大于检索books表并计算价格的最大值
// class string 类别
// name string 书名
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtClassName(es *elasticsearch.Client, class, name string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtClassName 根据类别、书名、页数小于检索books表并计算价格的最大值
// class string 类别
// name string 书名
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtClassName(es *elasticsearch.Client, class, name string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteClassName 根据类别、书名、页数小于等于检索books表并计算价格的最大值
// class string 类别
// name string 书名
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteClassName(es *elasticsearch.Client, class, name string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteClassName 根据类别、书名、页数大于等于和小于等于检索books表并计算价格的最大值
// class string 类别
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteClassName(es *elasticsearch.Client, class, name string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteClassName 根据类别、书名、价格大于等于检索books表并计算页数的最大值
// class string 类别
// name string 书名
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteClassName(es *elasticsearch.Client, class, name string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtClassName 根据类别、书名、价格大于检索books表并计算页数的最大值
// class string 类别
// name string 书名
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtClassName(es *elasticsearch.Client, class, name string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtClassName 根据类别、书名、价格小于检索books表并计算页数的最大值
// class string 类别
// name string 书名
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtClassName(es *elasticsearch.Client, class, name string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteClassName 根据类别、书名、价格小于等于检索books表并计算页数的最大值
// class string 类别
// name string 书名
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteClassName(es *elasticsearch.Client, class, name string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteClassName 根据类别、书名、价格大于等于和小于等于检索books表并计算页数的最大值
// class string 类别
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteClassName(es *elasticsearch.Client, class, name string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteClassName 根据类别、书名、发布日期大于等于检索books表并计算页数的最大值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteClassName(es *elasticsearch.Client, class, name string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtClassName 根据类别、书名、发布日期大于检索books表并计算页数的最大值
// class string 类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtClassName(es *elasticsearch.Client, class, name string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtClassName 根据类别、书名、发布日期小于检索books表并计算页数的最大值
// class string 类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtClassName(es *elasticsearch.Client, class, name string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteClassName 根据类别、书名、发布日期小于等于检索books表并计算页数的最大值
// class string 类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteClassName(es *elasticsearch.Client, class, name string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteClassName 根据类别、书名、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteClassName(es *elasticsearch.Client, class, name string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteClassName 根据类别、书名、发布日期大于等于检索books表并计算价格的最大值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteClassName(es *elasticsearch.Client, class, name string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtClassName 根据类别、书名、发布日期大于检索books表并计算价格的最大值
// class string 类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtClassName(es *elasticsearch.Client, class, name string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtClassName 根据类别、书名、发布日期小于检索books表并计算价格的最大值
// class string 类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtClassName(es *elasticsearch.Client, class, name string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteClassName 根据类别、书名、发布日期小于等于检索books表并计算价格的最大值
// class string 类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteClassName(es *elasticsearch.Client, class, name string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteClassName 根据类别、书名、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteClassName(es *elasticsearch.Client, class, name string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGteClass 根据类别、页数大于等于、发布日期大于等于检索books表并计算价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGteReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGtClass 根据类别、页数大于等于、发布日期大于检索books表并计算价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGteReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateLtClass 根据类别、页数大于等于、发布日期小于检索books表并计算价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGteReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateLteClass 根据类别、页数大于等于、发布日期小于等于检索books表并计算价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGteLteClass 根据类别、页数大于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGteClass 根据类别、页数大于、发布日期大于等于检索books表并计算价格的最大值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGtReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGtClass 根据类别、页数大于、发布日期大于检索books表并计算价格的最大值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGtReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateLtClass 根据类别、页数大于、发布日期小于检索books表并计算价格的最大值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGtReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateLteClass 根据类别、页数大于、发布日期小于等于检索books表并计算价格的最大值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGtReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGteLteClass 根据类别、页数大于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGtReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGteClass 根据类别、页数小于、发布日期大于等于检索books表并计算价格的最大值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountLtReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGtClass 根据类别、页数小于、发布日期大于检索books表并计算价格的最大值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountLtReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateLtClass 根据类别、页数小于、发布日期小于检索books表并计算价格的最大值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountLtReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateLteClass 根据类别、页数小于、发布日期小于等于检索books表并计算价格的最大值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLtReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGteLteClass 根据类别、页数小于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLtReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGteClass 根据类别、页数小于等于、发布日期大于等于检索books表并计算价格的最大值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountLteReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGtClass 根据类别、页数小于等于、发布日期大于检索books表并计算价格的最大值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountLteReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateLtClass 根据类别、页数小于等于、发布日期小于检索books表并计算价格的最大值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountLteReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateLteClass 根据类别、页数小于等于、发布日期小于等于检索books表并计算价格的最大值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLteReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGteLteClass 根据类别、页数小于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLteReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGteClass 根据类别、页数大于等于和小于等于、发布日期大于等于检索books表并计算价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGtClass 根据类别、页数大于等于和小于等于、发布日期大于检索books表并计算价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateLtClass 根据类别、页数大于等于和小于等于、发布日期小于检索books表并计算价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGteLteReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateLteClass 根据类别、页数大于等于和小于等于、发布日期小于等于检索books表并计算价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGteLteClass 根据类别、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteClassSeq 根据类别、编号、页数大于等于检索books表并计算价格的最大值
// class string 类别
// seq string 编号
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteClassSeq(es *elasticsearch.Client, class, seq string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtClassSeq 根据类别、编号、页数大于检索books表并计算价格的最大值
// class string 类别
// seq string 编号
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtClassSeq(es *elasticsearch.Client, class, seq string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtClassSeq 根据类别、编号、页数小于检索books表并计算价格的最大值
// class string 类别
// seq string 编号
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtClassSeq(es *elasticsearch.Client, class, seq string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteClassSeq 根据类别、编号、页数小于等于检索books表并计算价格的最大值
// class string 类别
// seq string 编号
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteClassSeq(es *elasticsearch.Client, class, seq string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteClassSeq 根据类别、编号、页数大于等于和小于等于检索books表并计算价格的最大值
// class string 类别
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteClassSeq(es *elasticsearch.Client, class, seq string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGteClass 根据类别、价格大于等于、发布日期大于等于检索books表并计算页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGteReleaseDateGteClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGtClass 根据类别、价格大于等于、发布日期大于检索books表并计算页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGteReleaseDateGtClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateLtClass 根据类别、价格大于等于、发布日期小于检索books表并计算页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGteReleaseDateLtClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateLteClass 根据类别、价格大于等于、发布日期小于等于检索books表并计算页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteReleaseDateLteClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGteLteClass 根据类别、价格大于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGteClass 根据类别、价格大于、发布日期大于等于检索books表并计算页数的最大值
// class string 类别
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGtReleaseDateGteClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGtClass 根据类别、价格大于、发布日期大于检索books表并计算页数的最大值
// class string 类别
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGtReleaseDateGtClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateLtClass 根据类别、价格大于、发布日期小于检索books表并计算页数的最大值
// class string 类别
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGtReleaseDateLtClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateLteClass 根据类别、价格大于、发布日期小于等于检索books表并计算页数的最大值
// class string 类别
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGtReleaseDateLteClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGteLteClass 根据类别、价格大于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class string 类别
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGtReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGteClass 根据类别、价格小于、发布日期大于等于检索books表并计算页数的最大值
// class string 类别
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceLtReleaseDateGteClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGtClass 根据类别、价格小于、发布日期大于检索books表并计算页数的最大值
// class string 类别
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceLtReleaseDateGtClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateLtClass 根据类别、价格小于、发布日期小于检索books表并计算页数的最大值
// class string 类别
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceLtReleaseDateLtClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateLteClass 根据类别、价格小于、发布日期小于等于检索books表并计算页数的最大值
// class string 类别
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLtReleaseDateLteClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGteLteClass 根据类别、价格小于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class string 类别
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLtReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGteClass 根据类别、价格小于等于、发布日期大于等于检索books表并计算页数的最大值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceLteReleaseDateGteClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGtClass 根据类别、价格小于等于、发布日期大于检索books表并计算页数的最大值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceLteReleaseDateGtClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateLtClass 根据类别、价格小于等于、发布日期小于检索books表并计算页数的最大值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceLteReleaseDateLtClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateLteClass 根据类别、价格小于等于、发布日期小于等于检索books表并计算页数的最大值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLteReleaseDateLteClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGteLteClass 根据类别、价格小于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLteReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGteClass 根据类别、价格大于等于和小于等于、发布日期大于等于检索books表并计算页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGteClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGtClass 根据类别、价格大于等于和小于等于、发布日期大于检索books表并计算页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGtClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateLtClass 根据类别、价格大于等于和小于等于、发布日期小于检索books表并计算页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGteLteReleaseDateLtClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateLteClass 根据类别、价格大于等于和小于等于、发布日期小于等于检索books表并计算页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateLteClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGteLteClass 根据类别、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteClassSeq 根据类别、编号、价格大于等于检索books表并计算页数的最大值
// class string 类别
// seq string 编号
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteClassSeq(es *elasticsearch.Client, class, seq string, priceGte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtClassSeq 根据类别、编号、价格大于检索books表并计算页数的最大值
// class string 类别
// seq string 编号
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtClassSeq(es *elasticsearch.Client, class, seq string, priceGt float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtClassSeq 根据类别、编号、价格小于检索books表并计算页数的最大值
// class string 类别
// seq string 编号
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtClassSeq(es *elasticsearch.Client, class, seq string, priceLt float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteClassSeq 根据类别、编号、价格小于等于检索books表并计算页数的最大值
// class string 类别
// seq string 编号
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteClassSeq(es *elasticsearch.Client, class, seq string, priceLte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteClassSeq 根据类别、编号、价格大于等于和小于等于检索books表并计算页数的最大值
// class string 类别
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteClassSeq(es *elasticsearch.Client, class, seq string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteClassSeq 根据类别、编号、发布日期大于等于检索books表并计算页数的最大值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtClassSeq 根据类别、编号、发布日期大于检索books表并计算页数的最大值
// class string 类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtClassSeq 根据类别、编号、发布日期小于检索books表并计算页数的最大值
// class string 类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteClassSeq 根据类别、编号、发布日期小于等于检索books表并计算页数的最大值
// class string 类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteClassSeq 根据类别、编号、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteClassSeq 根据类别、编号、发布日期大于等于检索books表并计算价格的最大值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtClassSeq 根据类别、编号、发布日期大于检索books表并计算价格的最大值
// class string 类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtClassSeq 根据类别、编号、发布日期小于检索books表并计算价格的最大值
// class string 类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteClassSeq 根据类别、编号、发布日期小于等于检索books表并计算价格的最大值
// class string 类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteClassSeq 根据类别、编号、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteClass2Name 根据子类别、书名、页数大于等于检索books表并计算价格的最大值
// class2 string 子类别
// name string 书名
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteClass2Name(es *elasticsearch.Client, class2, name string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtClass2Name 根据子类别、书名、页数大于检索books表并计算价格的最大值
// class2 string 子类别
// name string 书名
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtClass2Name(es *elasticsearch.Client, class2, name string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtClass2Name 根据子类别、书名、页数小于检索books表并计算价格的最大值
// class2 string 子类别
// name string 书名
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtClass2Name(es *elasticsearch.Client, class2, name string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteClass2Name 根据子类别、书名、页数小于等于检索books表并计算价格的最大值
// class2 string 子类别
// name string 书名
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteClass2Name(es *elasticsearch.Client, class2, name string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteClass2Name 根据子类别、书名、页数大于等于和小于等于检索books表并计算价格的最大值
// class2 string 子类别
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteClass2Name(es *elasticsearch.Client, class2, name string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteClass2Name 根据子类别、书名、价格大于等于检索books表并计算页数的最大值
// class2 string 子类别
// name string 书名
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteClass2Name(es *elasticsearch.Client, class2, name string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtClass2Name 根据子类别、书名、价格大于检索books表并计算页数的最大值
// class2 string 子类别
// name string 书名
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtClass2Name(es *elasticsearch.Client, class2, name string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtClass2Name 根据子类别、书名、价格小于检索books表并计算页数的最大值
// class2 string 子类别
// name string 书名
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtClass2Name(es *elasticsearch.Client, class2, name string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteClass2Name 根据子类别、书名、价格小于等于检索books表并计算页数的最大值
// class2 string 子类别
// name string 书名
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteClass2Name(es *elasticsearch.Client, class2, name string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteClass2Name 根据子类别、书名、价格大于等于和小于等于检索books表并计算页数的最大值
// class2 string 子类别
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteClass2Name(es *elasticsearch.Client, class2, name string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteClass2Name 根据子类别、书名、发布日期大于等于检索books表并计算页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtClass2Name 根据子类别、书名、发布日期大于检索books表并计算页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtClass2Name 根据子类别、书名、发布日期小于检索books表并计算页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteClass2Name 根据子类别、书名、发布日期小于等于检索books表并计算页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteClass2Name 根据子类别、书名、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteClass2Name 根据子类别、书名、发布日期大于等于检索books表并计算价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtClass2Name 根据子类别、书名、发布日期大于检索books表并计算价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtClass2Name 根据子类别、书名、发布日期小于检索books表并计算价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteClass2Name 根据子类别、书名、发布日期小于等于检索books表并计算价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteClass2Name 根据子类别、书名、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGteClass2 根据子类别、页数大于等于、发布日期大于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGtClass2 根据子类别、页数大于等于、发布日期大于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateLtClass2 根据子类别、页数大于等于、发布日期小于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateLteClass2 根据子类别、页数大于等于、发布日期小于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGteLteClass2 根据子类别、页数大于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGteClass2 根据子类别、页数大于、发布日期大于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGtReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGtClass2 根据子类别、页数大于、发布日期大于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGtReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateLtClass2 根据子类别、页数大于、发布日期小于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGtReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateLteClass2 根据子类别、页数大于、发布日期小于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGtReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGteLteClass2 根据子类别、页数大于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGtReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGteClass2 根据子类别、页数小于、发布日期大于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountLtReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGtClass2 根据子类别、页数小于、发布日期大于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountLtReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateLtClass2 根据子类别、页数小于、发布日期小于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountLtReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateLteClass2 根据子类别、页数小于、发布日期小于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLtReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGteLteClass2 根据子类别、页数小于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLtReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGteClass2 根据子类别、页数小于等于、发布日期大于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountLteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGtClass2 根据子类别、页数小于等于、发布日期大于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountLteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateLtClass2 根据子类别、页数小于等于、发布日期小于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountLteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateLteClass2 根据子类别、页数小于等于、发布日期小于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGteLteClass2 根据子类别、页数小于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGteClass2 根据子类别、页数大于等于和小于等于、发布日期大于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGtClass2 根据子类别、页数大于等于和小于等于、发布日期大于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateLtClass2 根据子类别、页数大于等于和小于等于、发布日期小于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGteLteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateLteClass2 根据子类别、页数大于等于和小于等于、发布日期小于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGteLteClass2 根据子类别、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteClass2Seq 根据子类别、编号、页数大于等于检索books表并计算价格的最大值
// class2 string 子类别
// seq string 编号
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtClass2Seq 根据子类别、编号、页数大于检索books表并计算价格的最大值
// class2 string 子类别
// seq string 编号
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtClass2Seq 根据子类别、编号、页数小于检索books表并计算价格的最大值
// class2 string 子类别
// seq string 编号
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteClass2Seq 根据子类别、编号、页数小于等于检索books表并计算价格的最大值
// class2 string 子类别
// seq string 编号
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteClass2Seq 根据子类别、编号、页数大于等于和小于等于检索books表并计算价格的最大值
// class2 string 子类别
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGteClass2 根据子类别、价格大于等于、发布日期大于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGtClass2 根据子类别、价格大于等于、发布日期大于检索books表并计算页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateLtClass2 根据子类别、价格大于等于、发布日期小于检索books表并计算页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateLteClass2 根据子类别、价格大于等于、发布日期小于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGteLteClass2 根据子类别、价格大于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGteClass2 根据子类别、价格大于、发布日期大于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGtReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGtClass2 根据子类别、价格大于、发布日期大于检索books表并计算页数的最大值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGtReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateLtClass2 根据子类别、价格大于、发布日期小于检索books表并计算页数的最大值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGtReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateLteClass2 根据子类别、价格大于、发布日期小于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGtReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGteLteClass2 根据子类别、价格大于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGtReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGteClass2 根据子类别、价格小于、发布日期大于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceLtReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGtClass2 根据子类别、价格小于、发布日期大于检索books表并计算页数的最大值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceLtReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateLtClass2 根据子类别、价格小于、发布日期小于检索books表并计算页数的最大值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceLtReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateLteClass2 根据子类别、价格小于、发布日期小于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLtReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGteLteClass2 根据子类别、价格小于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLtReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGteClass2 根据子类别、价格小于等于、发布日期大于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceLteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGtClass2 根据子类别、价格小于等于、发布日期大于检索books表并计算页数的最大值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceLteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateLtClass2 根据子类别、价格小于等于、发布日期小于检索books表并计算页数的最大值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceLteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateLteClass2 根据子类别、价格小于等于、发布日期小于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGteLteClass2 根据子类别、价格小于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGteClass2 根据子类别、价格大于等于和小于等于、发布日期大于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGtClass2 根据子类别、价格大于等于和小于等于、发布日期大于检索books表并计算页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateLtClass2 根据子类别、价格大于等于和小于等于、发布日期小于检索books表并计算页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGteLteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateLteClass2 根据子类别、价格大于等于和小于等于、发布日期小于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGteLteClass2 根据子类别、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteClass2Seq 根据子类别、编号、价格大于等于检索books表并计算页数的最大值
// class2 string 子类别
// seq string 编号
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteClass2Seq(es *elasticsearch.Client, class2, seq string, priceGte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtClass2Seq 根据子类别、编号、价格大于检索books表并计算页数的最大值
// class2 string 子类别
// seq string 编号
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtClass2Seq(es *elasticsearch.Client, class2, seq string, priceGt float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtClass2Seq 根据子类别、编号、价格小于检索books表并计算页数的最大值
// class2 string 子类别
// seq string 编号
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtClass2Seq(es *elasticsearch.Client, class2, seq string, priceLt float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteClass2Seq 根据子类别、编号、价格小于等于检索books表并计算页数的最大值
// class2 string 子类别
// seq string 编号
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteClass2Seq(es *elasticsearch.Client, class2, seq string, priceLte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteClass2Seq 根据子类别、编号、价格大于等于和小于等于检索books表并计算页数的最大值
// class2 string 子类别
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteClass2Seq 根据子类别、编号、发布日期大于等于检索books表并计算页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtClass2Seq 根据子类别、编号、发布日期大于检索books表并计算页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtClass2Seq 根据子类别、编号、发布日期小于检索books表并计算页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteClass2Seq 根据子类别、编号、发布日期小于等于检索books表并计算页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteClass2Seq 根据子类别、编号、发布日期大于等于和小于等于检索books表并计算页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteClass2Seq 根据子类别、编号、发布日期大于等于检索books表并计算价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtClass2Seq 根据子类别、编号、发布日期大于检索books表并计算价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtClass2Seq 根据子类别、编号、发布日期小于检索books表并计算价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteClass2Seq 根据子类别、编号、发布日期小于等于检索books表并计算价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteClass2Seq 根据子类别、编号、发布日期大于等于和小于等于检索books表并计算价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGteName 根据书名、页数大于等于、发布日期大于等于检索books表并计算价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGteReleaseDateGteName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGtName 根据书名、页数大于等于、发布日期大于检索books表并计算价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGteReleaseDateGtName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateLtName 根据书名、页数大于等于、发布日期小于检索books表并计算价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGteReleaseDateLtName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateLteName 根据书名、页数大于等于、发布日期小于等于检索books表并计算价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteReleaseDateLteName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGteLteName 根据书名、页数大于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGteName 根据书名、页数大于、发布日期大于等于检索books表并计算价格的最大值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGtReleaseDateGteName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGtName 根据书名、页数大于、发布日期大于检索books表并计算价格的最大值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGtReleaseDateGtName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateLtName 根据书名、页数大于、发布日期小于检索books表并计算价格的最大值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGtReleaseDateLtName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateLteName 根据书名、页数大于、发布日期小于等于检索books表并计算价格的最大值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGtReleaseDateLteName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGteLteName 根据书名、页数大于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGtReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGteName 根据书名、页数小于、发布日期大于等于检索books表并计算价格的最大值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountLtReleaseDateGteName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGtName 根据书名、页数小于、发布日期大于检索books表并计算价格的最大值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountLtReleaseDateGtName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateLtName 根据书名、页数小于、发布日期小于检索books表并计算价格的最大值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountLtReleaseDateLtName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateLteName 根据书名、页数小于、发布日期小于等于检索books表并计算价格的最大值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLtReleaseDateLteName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGteLteName 根据书名、页数小于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLtReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGteName 根据书名、页数小于等于、发布日期大于等于检索books表并计算价格的最大值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountLteReleaseDateGteName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGtName 根据书名、页数小于等于、发布日期大于检索books表并计算价格的最大值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountLteReleaseDateGtName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateLtName 根据书名、页数小于等于、发布日期小于检索books表并计算价格的最大值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountLteReleaseDateLtName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateLteName 根据书名、页数小于等于、发布日期小于等于检索books表并计算价格的最大值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLteReleaseDateLteName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGteLteName 根据书名、页数小于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLteReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGteName 根据书名、页数大于等于和小于等于、发布日期大于等于检索books表并计算价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGteName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGtName 根据书名、页数大于等于和小于等于、发布日期大于检索books表并计算价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGtName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateLtName 根据书名、页数大于等于和小于等于、发布日期小于检索books表并计算价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGteLteReleaseDateLtName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateLteName 根据书名、页数大于等于和小于等于、发布日期小于等于检索books表并计算价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateLteName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGteLteName 根据书名、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteNameSeq 根据书名、编号、页数大于等于检索books表并计算价格的最大值
// name string 书名
// seq string 编号
// pageCountGte int64 页数大于等于
func MaxPriceOfBooksByPageCountGteNameSeq(es *elasticsearch.Client, name, seq string, pageCountGte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtNameSeq 根据书名、编号、页数大于检索books表并计算价格的最大值
// name string 书名
// seq string 编号
// pageCountGt int64 页数大于
func MaxPriceOfBooksByPageCountGtNameSeq(es *elasticsearch.Client, name, seq string, pageCountGt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtNameSeq 根据书名、编号、页数小于检索books表并计算价格的最大值
// name string 书名
// seq string 编号
// pageCountLt int64 页数小于
func MaxPriceOfBooksByPageCountLtNameSeq(es *elasticsearch.Client, name, seq string, pageCountLt int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteNameSeq 根据书名、编号、页数小于等于检索books表并计算价格的最大值
// name string 书名
// seq string 编号
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountLteNameSeq(es *elasticsearch.Client, name, seq string, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteNameSeq 根据书名、编号、页数大于等于和小于等于检索books表并计算价格的最大值
// name string 书名
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
func MaxPriceOfBooksByPageCountGteLteNameSeq(es *elasticsearch.Client, name, seq string, pageCountGte, pageCountLte int64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGteName 根据书名、价格大于等于、发布日期大于等于检索books表并计算页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGteReleaseDateGteName(es *elasticsearch.Client, name string, priceGte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGtName 根据书名、价格大于等于、发布日期大于检索books表并计算页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGteReleaseDateGtName(es *elasticsearch.Client, name string, priceGte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateLtName 根据书名、价格大于等于、发布日期小于检索books表并计算页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGteReleaseDateLtName(es *elasticsearch.Client, name string, priceGte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateLteName 根据书名、价格大于等于、发布日期小于等于检索books表并计算页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteReleaseDateLteName(es *elasticsearch.Client, name string, priceGte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGteLteName 根据书名、价格大于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteReleaseDateGteLteName(es *elasticsearch.Client, name string, priceGte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGteName 根据书名、价格大于、发布日期大于等于检索books表并计算页数的最大值
// name string 书名
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGtReleaseDateGteName(es *elasticsearch.Client, name string, priceGt float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGtName 根据书名、价格大于、发布日期大于检索books表并计算页数的最大值
// name string 书名
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGtReleaseDateGtName(es *elasticsearch.Client, name string, priceGt float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateLtName 根据书名、价格大于、发布日期小于检索books表并计算页数的最大值
// name string 书名
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGtReleaseDateLtName(es *elasticsearch.Client, name string, priceGt float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateLteName 根据书名、价格大于、发布日期小于等于检索books表并计算页数的最大值
// name string 书名
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGtReleaseDateLteName(es *elasticsearch.Client, name string, priceGt float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGteLteName 根据书名、价格大于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// name string 书名
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGtReleaseDateGteLteName(es *elasticsearch.Client, name string, priceGt float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGteName 根据书名、价格小于、发布日期大于等于检索books表并计算页数的最大值
// name string 书名
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceLtReleaseDateGteName(es *elasticsearch.Client, name string, priceLt float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGtName 根据书名、价格小于、发布日期大于检索books表并计算页数的最大值
// name string 书名
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceLtReleaseDateGtName(es *elasticsearch.Client, name string, priceLt float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateLtName 根据书名、价格小于、发布日期小于检索books表并计算页数的最大值
// name string 书名
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceLtReleaseDateLtName(es *elasticsearch.Client, name string, priceLt float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateLteName 根据书名、价格小于、发布日期小于等于检索books表并计算页数的最大值
// name string 书名
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLtReleaseDateLteName(es *elasticsearch.Client, name string, priceLt float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGteLteName 根据书名、价格小于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// name string 书名
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLtReleaseDateGteLteName(es *elasticsearch.Client, name string, priceLt float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGteName 根据书名、价格小于等于、发布日期大于等于检索books表并计算页数的最大值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceLteReleaseDateGteName(es *elasticsearch.Client, name string, priceLte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGtName 根据书名、价格小于等于、发布日期大于检索books表并计算页数的最大值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceLteReleaseDateGtName(es *elasticsearch.Client, name string, priceLte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateLtName 根据书名、价格小于等于、发布日期小于检索books表并计算页数的最大值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceLteReleaseDateLtName(es *elasticsearch.Client, name string, priceLte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateLteName 根据书名、价格小于等于、发布日期小于等于检索books表并计算页数的最大值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLteReleaseDateLteName(es *elasticsearch.Client, name string, priceLte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGteLteName 根据书名、价格小于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLteReleaseDateGteLteName(es *elasticsearch.Client, name string, priceLte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGteName 根据书名、价格大于等于和小于等于、发布日期大于等于检索books表并计算页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGteName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGtName 根据书名、价格大于等于和小于等于、发布日期大于检索books表并计算页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGtName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateLtName 根据书名、价格大于等于和小于等于、发布日期小于检索books表并计算页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGteLteReleaseDateLtName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateLteName 根据书名、价格大于等于和小于等于、发布日期小于等于检索books表并计算页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateLteName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGteLteName 根据书名、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGteLteName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteNameSeq 根据书名、编号、价格大于等于检索books表并计算页数的最大值
// name string 书名
// seq string 编号
// priceGte float64 价格大于等于
func MaxPageCountOfBooksByPriceGteNameSeq(es *elasticsearch.Client, name, seq string, priceGte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtNameSeq 根据书名、编号、价格大于检索books表并计算页数的最大值
// name string 书名
// seq string 编号
// priceGt float64 价格大于
func MaxPageCountOfBooksByPriceGtNameSeq(es *elasticsearch.Client, name, seq string, priceGt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtNameSeq 根据书名、编号、价格小于检索books表并计算页数的最大值
// name string 书名
// seq string 编号
// priceLt float64 价格小于
func MaxPageCountOfBooksByPriceLtNameSeq(es *elasticsearch.Client, name, seq string, priceLt float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteNameSeq 根据书名、编号、价格小于等于检索books表并计算页数的最大值
// name string 书名
// seq string 编号
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceLteNameSeq(es *elasticsearch.Client, name, seq string, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteNameSeq 根据书名、编号、价格大于等于和小于等于检索books表并计算页数的最大值
// name string 书名
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
func MaxPageCountOfBooksByPriceGteLteNameSeq(es *elasticsearch.Client, name, seq string, priceGte, priceLte float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteNameSeq 根据书名、编号、发布日期大于等于检索books表并计算页数的最大值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByReleaseDateGteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGtNameSeq 根据书名、编号、发布日期大于检索books表并计算页数的最大值
// name string 书名
// seq string 编号
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByReleaseDateGtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLtNameSeq 根据书名、编号、发布日期小于检索books表并计算页数的最大值
// name string 书名
// seq string 编号
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByReleaseDateLtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateLteNameSeq 根据书名、编号、发布日期小于等于检索books表并计算页数的最大值
// name string 书名
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByReleaseDateGteLteNameSeq 根据书名、编号、发布日期大于等于和小于等于检索books表并计算页数的最大值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByReleaseDateGteLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteNameSeq 根据书名、编号、发布日期大于等于检索books表并计算价格的最大值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByReleaseDateGteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGtNameSeq 根据书名、编号、发布日期大于检索books表并计算价格的最大值
// name string 书名
// seq string 编号
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByReleaseDateGtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLtNameSeq 根据书名、编号、发布日期小于检索books表并计算价格的最大值
// name string 书名
// seq string 编号
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByReleaseDateLtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateLteNameSeq 根据书名、编号、发布日期小于等于检索books表并计算价格的最大值
// name string 书名
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByReleaseDateGteLteNameSeq 根据书名、编号、发布日期大于等于和小于等于检索books表并计算价格的最大值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByReleaseDateGteLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGteSeq 根据编号、页数大于等于、发布日期大于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGteReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGtSeq 根据编号、页数大于等于、发布日期大于检索books表并计算价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGteReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateLtSeq 根据编号、页数大于等于、发布日期小于检索books表并计算价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGteReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateLteSeq 根据编号、页数大于等于、发布日期小于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteReleaseDateGteLteSeq 根据编号、页数大于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGteSeq 根据编号、页数大于、发布日期大于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGtReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGtSeq 根据编号、页数大于、发布日期大于检索books表并计算价格的最大值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGtReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateLtSeq 根据编号、页数大于、发布日期小于检索books表并计算价格的最大值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGtReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateLteSeq 根据编号、页数大于、发布日期小于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGtReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGtReleaseDateGteLteSeq 根据编号、页数大于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGtReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGteSeq 根据编号、页数小于、发布日期大于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountLtReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGtSeq 根据编号、页数小于、发布日期大于检索books表并计算价格的最大值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountLtReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateLtSeq 根据编号、页数小于、发布日期小于检索books表并计算价格的最大值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountLtReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateLteSeq 根据编号、页数小于、发布日期小于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLtReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLtReleaseDateGteLteSeq 根据编号、页数小于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLtReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGteSeq 根据编号、页数小于等于、发布日期大于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountLteReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGtSeq 根据编号、页数小于等于、发布日期大于检索books表并计算价格的最大值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountLteReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateLtSeq 根据编号、页数小于等于、发布日期小于检索books表并计算价格的最大值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountLteReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateLteSeq 根据编号、页数小于等于、发布日期小于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLteReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountLteReleaseDateGteLteSeq 根据编号、页数小于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountLteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGteSeq 根据编号、页数大于等于和小于等于、发布日期大于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGtSeq 根据编号、页数大于等于和小于等于、发布日期大于检索books表并计算价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateLtSeq 根据编号、页数大于等于和小于等于、发布日期小于检索books表并计算价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPriceOfBooksByPageCountGteLteReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateLteSeq 根据编号、页数大于等于和小于等于、发布日期小于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceOfBooksByPageCountGteLteReleaseDateGteLteSeq 根据编号、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并计算价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPriceOfBooksByPageCountGteLteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("price")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGteSeq 根据编号、价格大于等于、发布日期大于等于检索books表并计算页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGteReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGtSeq 根据编号、价格大于等于、发布日期大于检索books表并计算页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGteReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateLtSeq 根据编号、价格大于等于、发布日期小于检索books表并计算页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGteReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateLteSeq 根据编号、价格大于等于、发布日期小于等于检索books表并计算页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteReleaseDateGteLteSeq 根据编号、价格大于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGteSeq 根据编号、价格大于、发布日期大于等于检索books表并计算页数的最大值
// seq string 编号
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGtReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGtSeq 根据编号、价格大于、发布日期大于检索books表并计算页数的最大值
// seq string 编号
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGtReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateLtSeq 根据编号、价格大于、发布日期小于检索books表并计算页数的最大值
// seq string 编号
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGtReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateLteSeq 根据编号、价格大于、发布日期小于等于检索books表并计算页数的最大值
// seq string 编号
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGtReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGtReleaseDateGteLteSeq 根据编号、价格大于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// seq string 编号
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGtReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGteSeq 根据编号、价格小于、发布日期大于等于检索books表并计算页数的最大值
// seq string 编号
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceLtReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGtSeq 根据编号、价格小于、发布日期大于检索books表并计算页数的最大值
// seq string 编号
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceLtReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateLtSeq 根据编号、价格小于、发布日期小于检索books表并计算页数的最大值
// seq string 编号
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceLtReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateLteSeq 根据编号、价格小于、发布日期小于等于检索books表并计算页数的最大值
// seq string 编号
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLtReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLtReleaseDateGteLteSeq 根据编号、价格小于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// seq string 编号
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLtReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGteSeq 根据编号、价格小于等于、发布日期大于等于检索books表并计算页数的最大值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceLteReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGtSeq 根据编号、价格小于等于、发布日期大于检索books表并计算页数的最大值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceLteReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateLtSeq 根据编号、价格小于等于、发布日期小于检索books表并计算页数的最大值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceLteReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateLteSeq 根据编号、价格小于等于、发布日期小于等于检索books表并计算页数的最大值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLteReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceLteReleaseDateGteLteSeq 根据编号、价格小于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceLteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGteSeq 根据编号、价格大于等于和小于等于、发布日期大于等于检索books表并计算页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateGte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGtSeq 根据编号、价格大于等于和小于等于、发布日期大于检索books表并计算页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateGt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateLtSeq 根据编号、价格大于等于和小于等于、发布日期小于检索books表并计算页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
func MaxPageCountOfBooksByPriceGteLteReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateLt time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateLteSeq 根据编号、价格大于等于和小于等于、发布日期小于等于检索books表并计算页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountOfBooksByPriceGteLteReleaseDateGteLteSeq 根据编号、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并计算页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
func MaxPageCountOfBooksByPriceGteLteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.MaxAgg("pageCount")
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}
