// Code generated by es2go. DO NOT EDIT.

package model

import (
	"fmt"

	"github.com/elastic/go-elasticsearch/v8"
	eq "github.com/kyle-hy/esquery"
)

// MinPageCountInHistPageCountOfWeekBooksByReleaseDateGte 根据发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByReleaseDateGte 根据发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByReleaseDateGte 根据发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByReleaseDateGte 根据发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAllTextReleaseDateGte 根据全文本、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAllTextReleaseDateGte(es *elasticsearch.Client, allText string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAuthorReleaseDateGte 根据作者、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByAuthorReleaseDateGte 根据作者、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByAuthorReleaseDateGte 根据作者、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAuthorReleaseDateGte 根据作者、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAuthorReleaseDateGte(es *elasticsearch.Client, author string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClassReleaseDateGte 根据类别、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByClassReleaseDateGte 根据类别、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// class string 类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByClassReleaseDateGte 根据类别、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// class string 类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClassReleaseDateGte 根据类别、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClassReleaseDateGte(es *elasticsearch.Client, class string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClass2ReleaseDateGte 根据子类别、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClass2ReleaseDateGte(es *elasticsearch.Client, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByNameReleaseDateGte 根据书名、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByNameReleaseDateGte 根据书名、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByNameReleaseDateGte 根据书名、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByNameReleaseDateGte 根据书名、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByNameReleaseDateGte(es *elasticsearch.Client, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByPageCountGteReleaseDateGte 根据页数大于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByPageCountGteReleaseDateGte(es *elasticsearch.Client, pageCountGte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByPageCountGtReleaseDateGte 根据页数大于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByPageCountGtReleaseDateGte(es *elasticsearch.Client, pageCountGt int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByPageCountLtReleaseDateGte 根据页数小于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByPageCountLtReleaseDateGte(es *elasticsearch.Client, pageCountLt int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByPageCountLteReleaseDateGte 根据页数小于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByPageCountLteReleaseDateGte(es *elasticsearch.Client, pageCountLte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByPageCountGteLteReleaseDateGte 根据页数大于等于和小于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByPageCountGteLteReleaseDateGte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByPriceGteReleaseDateGte 根据价格大于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByPriceGteReleaseDateGte(es *elasticsearch.Client, priceGte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByPriceGtReleaseDateGte 根据价格大于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByPriceGtReleaseDateGte(es *elasticsearch.Client, priceGt float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByPriceLtReleaseDateGte 根据价格小于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByPriceLtReleaseDateGte(es *elasticsearch.Client, priceLt float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByPriceLteReleaseDateGte 根据价格小于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByPriceLteReleaseDateGte(es *elasticsearch.Client, priceLte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByPriceGteLteReleaseDateGte 根据价格大于等于和小于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByPriceGteLteReleaseDateGte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksBySeqReleaseDateGte 根据编号、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksBySeqReleaseDateGte 根据编号、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksBySeqReleaseDateGte 根据编号、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksBySeqReleaseDateGte 根据编号、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksBySeqReleaseDateGte(es *elasticsearch.Client, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// author string 作者
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAllTextAuthorReleaseDateGte 根据全文本、作者、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// author string 作者
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAllTextAuthorReleaseDateGte(es *elasticsearch.Client, allText, author string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// class string 类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAllTextClassReleaseDateGte 根据全文本、类别、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// class string 类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAllTextClassReleaseDateGte(es *elasticsearch.Client, allText, class string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAllTextClass2ReleaseDateGte 根据全文本、子类别、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAllTextClass2ReleaseDateGte(es *elasticsearch.Client, allText, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAllTextNameReleaseDateGte 根据全文本、书名、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAllTextNameReleaseDateGte(es *elasticsearch.Client, allText, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAllTextPageCountGteReleaseDateGte 根据全文本、页数大于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAllTextPageCountGteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAllTextPageCountGtReleaseDateGte 根据全文本、页数大于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAllTextPageCountGtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAllTextPageCountLtReleaseDateGte 根据全文本、页数小于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAllTextPageCountLtReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAllTextPageCountLteReleaseDateGte 根据全文本、页数小于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAllTextPageCountLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAllTextPageCountGteLteReleaseDateGte 根据全文本、页数大于等于和小于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAllTextPageCountGteLteReleaseDateGte(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAllTextPriceGteReleaseDateGte 根据全文本、价格大于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAllTextPriceGteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAllTextPriceGtReleaseDateGte 根据全文本、价格大于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAllTextPriceGtReleaseDateGte(es *elasticsearch.Client, allText string, priceGt float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAllTextPriceLtReleaseDateGte 根据全文本、价格小于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAllTextPriceLtReleaseDateGte(es *elasticsearch.Client, allText string, priceLt float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAllTextPriceLteReleaseDateGte 根据全文本、价格小于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAllTextPriceLteReleaseDateGte(es *elasticsearch.Client, allText string, priceLte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAllTextPriceGteLteReleaseDateGte 根据全文本、价格大于等于和小于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAllTextPriceGteLteReleaseDateGte(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// allText string 全文本
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAllTextSeqReleaseDateGte 根据全文本、编号、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// allText string 全文本
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAllTextSeqReleaseDateGte(es *elasticsearch.Client, allText, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// class string 类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAuthorClassReleaseDateGte 根据作者、类别、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// class string 类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAuthorClassReleaseDateGte(es *elasticsearch.Client, author, class string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAuthorClass2ReleaseDateGte 根据作者、子类别、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAuthorClass2ReleaseDateGte(es *elasticsearch.Client, author, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAuthorNameReleaseDateGte 根据作者、书名、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAuthorNameReleaseDateGte(es *elasticsearch.Client, author, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAuthorPageCountGteReleaseDateGte 根据作者、页数大于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAuthorPageCountGteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAuthorPageCountGtReleaseDateGte 根据作者、页数大于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAuthorPageCountGtReleaseDateGte(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAuthorPageCountLtReleaseDateGte 根据作者、页数小于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAuthorPageCountLtReleaseDateGte(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAuthorPageCountLteReleaseDateGte 根据作者、页数小于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAuthorPageCountLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAuthorPageCountGteLteReleaseDateGte 根据作者、页数大于等于和小于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAuthorPageCountGteLteReleaseDateGte(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAuthorPriceGteReleaseDateGte 根据作者、价格大于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAuthorPriceGteReleaseDateGte(es *elasticsearch.Client, author string, priceGte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAuthorPriceGtReleaseDateGte 根据作者、价格大于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAuthorPriceGtReleaseDateGte(es *elasticsearch.Client, author string, priceGt float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAuthorPriceLtReleaseDateGte 根据作者、价格小于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAuthorPriceLtReleaseDateGte(es *elasticsearch.Client, author string, priceLt float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAuthorPriceLteReleaseDateGte 根据作者、价格小于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAuthorPriceLteReleaseDateGte(es *elasticsearch.Client, author string, priceLte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAuthorPriceGteLteReleaseDateGte 根据作者、价格大于等于和小于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAuthorPriceGteLteReleaseDateGte(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// author string 作者
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByAuthorSeqReleaseDateGte 根据作者、编号、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// author string 作者
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByAuthorSeqReleaseDateGte(es *elasticsearch.Client, author, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// class string 类别
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClassClass2ReleaseDateGte 根据类别、子类别、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// class2 string 子类别
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClassClass2ReleaseDateGte(es *elasticsearch.Client, class, class2 string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// class string 类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClassNameReleaseDateGte 根据类别、书名、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClassNameReleaseDateGte(es *elasticsearch.Client, class, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClassPageCountGteReleaseDateGte 根据类别、页数大于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClassPageCountGteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClassPageCountGtReleaseDateGte 根据类别、页数大于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClassPageCountGtReleaseDateGte(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClassPageCountLtReleaseDateGte 根据类别、页数小于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClassPageCountLtReleaseDateGte(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClassPageCountLteReleaseDateGte 根据类别、页数小于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClassPageCountLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClassPageCountGteLteReleaseDateGte 根据类别、页数大于等于和小于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClassPageCountGteLteReleaseDateGte(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClassPriceGteReleaseDateGte 根据类别、价格大于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClassPriceGteReleaseDateGte(es *elasticsearch.Client, class string, priceGte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClassPriceGtReleaseDateGte 根据类别、价格大于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClassPriceGtReleaseDateGte(es *elasticsearch.Client, class string, priceGt float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClassPriceLtReleaseDateGte 根据类别、价格小于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClassPriceLtReleaseDateGte(es *elasticsearch.Client, class string, priceLt float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClassPriceLteReleaseDateGte 根据类别、价格小于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClassPriceLteReleaseDateGte(es *elasticsearch.Client, class string, priceLte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClassPriceGteLteReleaseDateGte 根据类别、价格大于等于和小于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClassPriceGteLteReleaseDateGte(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// class string 类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClassSeqReleaseDateGte 根据类别、编号、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class string 类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClassSeqReleaseDateGte(es *elasticsearch.Client, class, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// class2 string 子类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClass2NameReleaseDateGte 根据子类别、书名、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// name string 书名
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClass2NameReleaseDateGte(es *elasticsearch.Client, class2, name string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClass2PageCountGteReleaseDateGte 根据子类别、页数大于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClass2PageCountGteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClass2PageCountGtReleaseDateGte 根据子类别、页数大于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClass2PageCountGtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClass2PageCountLtReleaseDateGte 根据子类别、页数小于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClass2PageCountLtReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClass2PageCountLteReleaseDateGte 根据子类别、页数小于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClass2PageCountLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClass2PageCountGteLteReleaseDateGte 根据子类别、页数大于等于和小于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClass2PageCountGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClass2PriceGteReleaseDateGte 根据子类别、价格大于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClass2PriceGteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClass2PriceGtReleaseDateGte 根据子类别、价格大于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClass2PriceGtReleaseDateGte(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClass2PriceLtReleaseDateGte 根据子类别、价格小于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClass2PriceLtReleaseDateGte(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClass2PriceLteReleaseDateGte 根据子类别、价格小于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClass2PriceLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClass2PriceGteLteReleaseDateGte 根据子类别、价格大于等于和小于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClass2PriceGteLteReleaseDateGte(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByClass2SeqReleaseDateGte 根据子类别、编号、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// class2 string 子类别
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByClass2SeqReleaseDateGte(es *elasticsearch.Client, class2, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByNamePageCountGteReleaseDateGte 根据书名、页数大于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByNamePageCountGteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByNamePageCountGtReleaseDateGte 根据书名、页数大于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByNamePageCountGtReleaseDateGte(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByNamePageCountLtReleaseDateGte 根据书名、页数小于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByNamePageCountLtReleaseDateGte(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByNamePageCountLteReleaseDateGte 根据书名、页数小于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByNamePageCountLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByNamePageCountGteLteReleaseDateGte 根据书名、页数大于等于和小于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByNamePageCountGteLteReleaseDateGte(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByNamePriceGteReleaseDateGte 根据书名、价格大于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByNamePriceGteReleaseDateGte(es *elasticsearch.Client, name string, priceGte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByNamePriceGtReleaseDateGte 根据书名、价格大于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByNamePriceGtReleaseDateGte(es *elasticsearch.Client, name string, priceGt float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByNamePriceLtReleaseDateGte 根据书名、价格小于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByNamePriceLtReleaseDateGte(es *elasticsearch.Client, name string, priceLt float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByNamePriceLteReleaseDateGte 根据书名、价格小于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByNamePriceLteReleaseDateGte(es *elasticsearch.Client, name string, priceLte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByNamePriceGteLteReleaseDateGte 根据书名、价格大于等于和小于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByNamePriceGteLteReleaseDateGte(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPageCountOfWeekBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几周检索books表，并按页数区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPriceInHistPageCountOfWeekBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPriceOfWeekBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几周检索books表，并按价格区间分桶统计页数的最小值
// name string 书名
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPageCountInHistPriceOfWeekBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksByNameSeqReleaseDateGte 根据书名、编号、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// name string 书名
// seq string 编号
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksByNameSeqReleaseDateGte(es *elasticsearch.Client, name, seq string, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksBySeqPageCountGteReleaseDateGte 根据编号、页数大于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksBySeqPageCountGteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksBySeqPageCountGtReleaseDateGte 根据编号、页数大于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksBySeqPageCountGtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksBySeqPageCountLtReleaseDateGte 根据编号、页数小于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksBySeqPageCountLtReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksBySeqPageCountLteReleaseDateGte 根据编号、页数小于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksBySeqPageCountLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPriceInHistPriceOfWeekBooksBySeqPageCountGteLteReleaseDateGte 根据编号、页数大于等于和小于等于、发布日期为近几周检索books表，并按价格区间分桶统计价格的最小值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的价格区间间隔
func MinPriceInHistPriceOfWeekBooksBySeqPageCountGteLteReleaseDateGte(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksBySeqPriceGteReleaseDateGte 根据编号、价格大于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksBySeqPriceGteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksBySeqPriceGtReleaseDateGte 根据编号、价格大于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGt float64 价格大于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksBySeqPriceGtReleaseDateGte(es *elasticsearch.Client, seq string, priceGt float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksBySeqPriceLtReleaseDateGte 根据编号、价格小于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLt float64 价格小于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksBySeqPriceLtReleaseDateGte(es *elasticsearch.Client, seq string, priceLt float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksBySeqPriceLteReleaseDateGte 根据编号、价格小于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksBySeqPriceLteReleaseDateGte(es *elasticsearch.Client, seq string, priceLte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MinPageCountInHistPageCountOfWeekBooksBySeqPriceGteLteReleaseDateGte 根据编号、价格大于等于和小于等于、发布日期为近几周检索books表，并按页数区间分桶统计页数的最小值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateNWeek int 发布日期为近几周
// histInterval float64 分桶聚合的页数区间间隔
func MinPageCountInHistPageCountOfWeekBooksBySeqPriceGteLteReleaseDateGte(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateNWeek int, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", fmt.Sprintf("now-%dw/w", releaseDateNWeek), nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MinAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}
