// Code generated by es2go. DO NOT EDIT.

package model

import (
	"time"

	"github.com/elastic/go-elasticsearch/v8"
	eq "github.com/kyle-hy/esquery"
)

// MaxPriceInHistPriceOfBooksByPageCountGte 根据页数大于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGte(es *elasticsearch.Client, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGt 根据页数大于检索books表并按价格区间分桶统计价格的最大值
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGt(es *elasticsearch.Client, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLt 根据页数小于检索books表并按价格区间分桶统计价格的最大值
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLt(es *elasticsearch.Client, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLte 根据页数小于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLte(es *elasticsearch.Client, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLte 根据页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGte 根据价格大于等于检索books表并按页数区间分桶统计页数的最大值
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGte(es *elasticsearch.Client, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGt 根据价格大于检索books表并按页数区间分桶统计页数的最大值
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGt(es *elasticsearch.Client, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLt 根据价格小于检索books表并按页数区间分桶统计页数的最大值
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLt(es *elasticsearch.Client, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLte 根据价格小于等于检索books表并按页数区间分桶统计页数的最大值
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLte(es *elasticsearch.Client, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLte 根据价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLte(es *elasticsearch.Client, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGte 根据发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGt 根据发布日期大于检索books表并按页数区间分桶统计页数的最大值
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGt(es *elasticsearch.Client, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLt 根据发布日期小于检索books表并按页数区间分桶统计页数的最大值
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLt(es *elasticsearch.Client, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLte 根据发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLte(es *elasticsearch.Client, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLte 根据发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLte(es *elasticsearch.Client, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGte 根据发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGt 根据发布日期大于检索books表并按页数区间分桶统计价格的最大值
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGt(es *elasticsearch.Client, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLt 根据发布日期小于检索books表并按页数区间分桶统计价格的最大值
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLt(es *elasticsearch.Client, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLte 根据发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLte(es *elasticsearch.Client, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLte 根据发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLte(es *elasticsearch.Client, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGte 根据发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGt 根据发布日期大于检索books表并按价格区间分桶统计页数的最大值
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGt(es *elasticsearch.Client, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLt 根据发布日期小于检索books表并按价格区间分桶统计页数的最大值
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLt(es *elasticsearch.Client, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLte 根据发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLte(es *elasticsearch.Client, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLte 根据发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLte(es *elasticsearch.Client, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGte 根据发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGte(es *elasticsearch.Client, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGt 根据发布日期大于检索books表并按价格区间分桶统计价格的最大值
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGt(es *elasticsearch.Client, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLt 根据发布日期小于检索books表并按价格区间分桶统计价格的最大值
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLt(es *elasticsearch.Client, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLte 根据发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLte(es *elasticsearch.Client, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLte 根据发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLte(es *elasticsearch.Client, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteAllText 根据全文本、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteAllText(es *elasticsearch.Client, allText string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtAllText 根据全文本、页数大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtAllText(es *elasticsearch.Client, allText string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtAllText 根据全文本、页数小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtAllText(es *elasticsearch.Client, allText string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteAllText 根据全文本、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteAllText(es *elasticsearch.Client, allText string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteAllText 根据全文本、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteAllText 根据全文本、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteAllText(es *elasticsearch.Client, allText string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtAllText 根据全文本、价格大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtAllText(es *elasticsearch.Client, allText string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtAllText 根据全文本、价格小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtAllText(es *elasticsearch.Client, allText string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteAllText 根据全文本、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteAllText(es *elasticsearch.Client, allText string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteAllText 根据全文本、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteAllText(es *elasticsearch.Client, allText string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteAllText 根据全文本、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteAllText(es *elasticsearch.Client, allText string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtAllText 根据全文本、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtAllText(es *elasticsearch.Client, allText string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtAllText 根据全文本、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtAllText(es *elasticsearch.Client, allText string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteAllText 根据全文本、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteAllText(es *elasticsearch.Client, allText string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAllText 根据全文本、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteAllText 根据全文本、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteAllText(es *elasticsearch.Client, allText string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtAllText 根据全文本、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtAllText(es *elasticsearch.Client, allText string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtAllText 根据全文本、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtAllText(es *elasticsearch.Client, allText string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteAllText 根据全文本、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteAllText(es *elasticsearch.Client, allText string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAllText 根据全文本、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteAllText 根据全文本、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteAllText(es *elasticsearch.Client, allText string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtAllText 根据全文本、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtAllText(es *elasticsearch.Client, allText string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtAllText 根据全文本、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtAllText(es *elasticsearch.Client, allText string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteAllText 根据全文本、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteAllText(es *elasticsearch.Client, allText string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAllText 根据全文本、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteAllText 根据全文本、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteAllText(es *elasticsearch.Client, allText string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtAllText 根据全文本、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtAllText(es *elasticsearch.Client, allText string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtAllText 根据全文本、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtAllText(es *elasticsearch.Client, allText string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteAllText 根据全文本、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteAllText(es *elasticsearch.Client, allText string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteAllText 根据全文本、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteAuthor 根据作者、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteAuthor(es *elasticsearch.Client, author string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtAuthor 根据作者、页数大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtAuthor(es *elasticsearch.Client, author string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtAuthor 根据作者、页数小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtAuthor(es *elasticsearch.Client, author string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteAuthor 根据作者、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteAuthor(es *elasticsearch.Client, author string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteAuthor 根据作者、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteAuthor 根据作者、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteAuthor(es *elasticsearch.Client, author string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtAuthor 根据作者、价格大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtAuthor(es *elasticsearch.Client, author string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtAuthor 根据作者、价格小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtAuthor(es *elasticsearch.Client, author string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteAuthor 根据作者、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteAuthor(es *elasticsearch.Client, author string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteAuthor 根据作者、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteAuthor(es *elasticsearch.Client, author string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteAuthor 根据作者、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteAuthor(es *elasticsearch.Client, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtAuthor 根据作者、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtAuthor(es *elasticsearch.Client, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtAuthor 根据作者、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtAuthor(es *elasticsearch.Client, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteAuthor 根据作者、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteAuthor(es *elasticsearch.Client, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthor 根据作者、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteAuthor 根据作者、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteAuthor(es *elasticsearch.Client, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtAuthor 根据作者、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtAuthor(es *elasticsearch.Client, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtAuthor 根据作者、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtAuthor(es *elasticsearch.Client, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteAuthor 根据作者、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteAuthor(es *elasticsearch.Client, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAuthor 根据作者、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteAuthor 根据作者、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteAuthor(es *elasticsearch.Client, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtAuthor 根据作者、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtAuthor(es *elasticsearch.Client, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtAuthor 根据作者、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtAuthor(es *elasticsearch.Client, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteAuthor 根据作者、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteAuthor(es *elasticsearch.Client, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAuthor 根据作者、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteAuthor 根据作者、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteAuthor(es *elasticsearch.Client, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtAuthor 根据作者、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtAuthor(es *elasticsearch.Client, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtAuthor 根据作者、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtAuthor(es *elasticsearch.Client, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteAuthor 根据作者、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteAuthor(es *elasticsearch.Client, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteAuthor 根据作者、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteClass 根据类别、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteClass(es *elasticsearch.Client, class string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtClass 根据类别、页数大于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtClass(es *elasticsearch.Client, class string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtClass 根据类别、页数小于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtClass(es *elasticsearch.Client, class string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteClass 根据类别、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteClass(es *elasticsearch.Client, class string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteClass 根据类别、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteClass 根据类别、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteClass(es *elasticsearch.Client, class string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtClass 根据类别、价格大于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtClass(es *elasticsearch.Client, class string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtClass 根据类别、价格小于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtClass(es *elasticsearch.Client, class string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteClass 根据类别、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteClass(es *elasticsearch.Client, class string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteClass 根据类别、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteClass(es *elasticsearch.Client, class string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteClass 根据类别、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteClass(es *elasticsearch.Client, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtClass 根据类别、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtClass(es *elasticsearch.Client, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtClass 根据类别、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtClass(es *elasticsearch.Client, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteClass 根据类别、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteClass(es *elasticsearch.Client, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteClass 根据类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteClass(es *elasticsearch.Client, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteClass 根据类别、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteClass(es *elasticsearch.Client, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtClass 根据类别、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtClass(es *elasticsearch.Client, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtClass 根据类别、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtClass(es *elasticsearch.Client, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteClass 根据类别、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteClass(es *elasticsearch.Client, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteClass 根据类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteClass(es *elasticsearch.Client, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteClass 根据类别、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteClass(es *elasticsearch.Client, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtClass 根据类别、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtClass(es *elasticsearch.Client, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtClass 根据类别、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtClass(es *elasticsearch.Client, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteClass 根据类别、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteClass(es *elasticsearch.Client, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteClass 根据类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteClass(es *elasticsearch.Client, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteClass 根据类别、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteClass(es *elasticsearch.Client, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtClass 根据类别、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtClass(es *elasticsearch.Client, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtClass 根据类别、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtClass(es *elasticsearch.Client, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteClass 根据类别、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteClass(es *elasticsearch.Client, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteClass 根据类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteClass(es *elasticsearch.Client, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteClass2 根据子类别、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtClass2 根据子类别、页数大于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtClass2 根据子类别、页数小于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteClass2 根据子类别、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteClass2 根据子类别、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteClass2 根据子类别、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteClass2(es *elasticsearch.Client, class2 string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtClass2 根据子类别、价格大于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtClass2(es *elasticsearch.Client, class2 string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtClass2 根据子类别、价格小于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtClass2(es *elasticsearch.Client, class2 string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteClass2 根据子类别、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteClass2(es *elasticsearch.Client, class2 string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteClass2 根据子类别、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteClass2 根据子类别、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteClass2(es *elasticsearch.Client, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtClass2 根据子类别、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtClass2(es *elasticsearch.Client, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtClass2 根据子类别、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtClass2(es *elasticsearch.Client, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteClass2 根据子类别、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteClass2(es *elasticsearch.Client, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteClass2 根据子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteClass2 根据子类别、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteClass2(es *elasticsearch.Client, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtClass2 根据子类别、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtClass2(es *elasticsearch.Client, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtClass2 根据子类别、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtClass2(es *elasticsearch.Client, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteClass2 根据子类别、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteClass2(es *elasticsearch.Client, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteClass2 根据子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteClass2 根据子类别、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteClass2(es *elasticsearch.Client, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtClass2 根据子类别、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtClass2(es *elasticsearch.Client, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtClass2 根据子类别、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtClass2(es *elasticsearch.Client, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteClass2 根据子类别、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteClass2(es *elasticsearch.Client, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteClass2 根据子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteClass2 根据子类别、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteClass2(es *elasticsearch.Client, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtClass2 根据子类别、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtClass2(es *elasticsearch.Client, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtClass2 根据子类别、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtClass2(es *elasticsearch.Client, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteClass2 根据子类别、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteClass2(es *elasticsearch.Client, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteClass2 根据子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteName 根据书名、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteName(es *elasticsearch.Client, name string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtName 根据书名、页数大于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtName(es *elasticsearch.Client, name string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtName 根据书名、页数小于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtName(es *elasticsearch.Client, name string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteName 根据书名、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteName(es *elasticsearch.Client, name string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteName 根据书名、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteName 根据书名、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteName(es *elasticsearch.Client, name string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtName 根据书名、价格大于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtName(es *elasticsearch.Client, name string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtName 根据书名、价格小于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtName(es *elasticsearch.Client, name string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteName 根据书名、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteName(es *elasticsearch.Client, name string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteName 根据书名、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteName(es *elasticsearch.Client, name string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteName 根据书名、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteName(es *elasticsearch.Client, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtName 根据书名、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtName(es *elasticsearch.Client, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtName 根据书名、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtName(es *elasticsearch.Client, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteName 根据书名、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteName(es *elasticsearch.Client, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteName 根据书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteName(es *elasticsearch.Client, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteName 根据书名、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteName(es *elasticsearch.Client, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtName 根据书名、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtName(es *elasticsearch.Client, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtName 根据书名、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtName(es *elasticsearch.Client, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteName 根据书名、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteName(es *elasticsearch.Client, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteName 根据书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteName(es *elasticsearch.Client, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteName 根据书名、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteName(es *elasticsearch.Client, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtName 根据书名、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtName(es *elasticsearch.Client, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtName 根据书名、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtName(es *elasticsearch.Client, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteName 根据书名、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteName(es *elasticsearch.Client, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteName 根据书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteName(es *elasticsearch.Client, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteName 根据书名、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteName(es *elasticsearch.Client, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtName 根据书名、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtName(es *elasticsearch.Client, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtName 根据书名、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtName(es *elasticsearch.Client, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteName 根据书名、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteName(es *elasticsearch.Client, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteName 根据书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteName(es *elasticsearch.Client, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGte 根据页数大于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGte(es *elasticsearch.Client, pageCountGte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGt 根据页数大于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGt(es *elasticsearch.Client, pageCountGte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLt 根据页数大于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLt(es *elasticsearch.Client, pageCountGte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLte 根据页数大于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLte(es *elasticsearch.Client, pageCountGte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLte 根据页数大于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLte(es *elasticsearch.Client, pageCountGte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGte 根据页数大于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGte(es *elasticsearch.Client, pageCountGt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGt 根据页数大于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGt(es *elasticsearch.Client, pageCountGt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLt 根据页数大于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLt(es *elasticsearch.Client, pageCountGt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLte 根据页数大于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLte(es *elasticsearch.Client, pageCountGt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLte 根据页数大于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLte(es *elasticsearch.Client, pageCountGt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGte 根据页数小于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGte(es *elasticsearch.Client, pageCountLt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGt 根据页数小于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGt(es *elasticsearch.Client, pageCountLt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLt 根据页数小于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLt(es *elasticsearch.Client, pageCountLt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLte 根据页数小于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLte(es *elasticsearch.Client, pageCountLt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLte 根据页数小于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLte(es *elasticsearch.Client, pageCountLt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGte 根据页数小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGte(es *elasticsearch.Client, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGt 根据页数小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGt(es *elasticsearch.Client, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLt 根据页数小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLt(es *elasticsearch.Client, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLte 根据页数小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLte(es *elasticsearch.Client, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLte 根据页数小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLte(es *elasticsearch.Client, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGte 根据页数大于等于和小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGt 根据页数大于等于和小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGt(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLt 根据页数大于等于和小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLt(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLte 根据页数大于等于和小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLte 根据页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLte(es *elasticsearch.Client, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteSeq 根据编号、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteSeq(es *elasticsearch.Client, seq string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtSeq 根据编号、页数大于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtSeq(es *elasticsearch.Client, seq string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtSeq 根据编号、页数小于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtSeq(es *elasticsearch.Client, seq string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteSeq 根据编号、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteSeq(es *elasticsearch.Client, seq string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteSeq 根据编号、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGte 根据价格大于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGte(es *elasticsearch.Client, priceGte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGt 根据价格大于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGt(es *elasticsearch.Client, priceGte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLt 根据价格大于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLt(es *elasticsearch.Client, priceGte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLte 根据价格大于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLte(es *elasticsearch.Client, priceGte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLte 根据价格大于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLte(es *elasticsearch.Client, priceGte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGte 根据价格大于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGte(es *elasticsearch.Client, priceGt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGt 根据价格大于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGt(es *elasticsearch.Client, priceGt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLt 根据价格大于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLt(es *elasticsearch.Client, priceGt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLte 根据价格大于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLte(es *elasticsearch.Client, priceGt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLte 根据价格大于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLte(es *elasticsearch.Client, priceGt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGte 根据价格小于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGte(es *elasticsearch.Client, priceLt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGt 根据价格小于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGt(es *elasticsearch.Client, priceLt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLt 根据价格小于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLt(es *elasticsearch.Client, priceLt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLte 根据价格小于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLte(es *elasticsearch.Client, priceLt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLte 根据价格小于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLte(es *elasticsearch.Client, priceLt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGte 根据价格小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGte(es *elasticsearch.Client, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGt 根据价格小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGt(es *elasticsearch.Client, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLt 根据价格小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLt(es *elasticsearch.Client, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLte 根据价格小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLte(es *elasticsearch.Client, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLte 根据价格小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLte(es *elasticsearch.Client, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGte 根据价格大于等于和小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGt 根据价格大于等于和小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGt(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLt 根据价格大于等于和小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLt(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLte 根据价格大于等于和小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLte 根据价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLte(es *elasticsearch.Client, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteSeq 根据编号、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteSeq(es *elasticsearch.Client, seq string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtSeq 根据编号、价格大于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtSeq(es *elasticsearch.Client, seq string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtSeq 根据编号、价格小于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtSeq(es *elasticsearch.Client, seq string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteSeq 根据编号、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteSeq(es *elasticsearch.Client, seq string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteSeq 根据编号、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteSeq(es *elasticsearch.Client, seq string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteSeq 根据编号、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteSeq(es *elasticsearch.Client, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtSeq 根据编号、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtSeq(es *elasticsearch.Client, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtSeq 根据编号、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtSeq(es *elasticsearch.Client, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteSeq 根据编号、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteSeq(es *elasticsearch.Client, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteSeq 根据编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteSeq 根据编号、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteSeq(es *elasticsearch.Client, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtSeq 根据编号、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtSeq(es *elasticsearch.Client, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtSeq 根据编号、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtSeq(es *elasticsearch.Client, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteSeq 根据编号、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteSeq(es *elasticsearch.Client, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteSeq 根据编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteSeq 根据编号、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteSeq(es *elasticsearch.Client, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtSeq 根据编号、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtSeq(es *elasticsearch.Client, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtSeq 根据编号、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtSeq(es *elasticsearch.Client, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteSeq 根据编号、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteSeq(es *elasticsearch.Client, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteSeq 根据编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteSeq 根据编号、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteSeq(es *elasticsearch.Client, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtSeq 根据编号、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtSeq(es *elasticsearch.Client, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtSeq 根据编号、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtSeq(es *elasticsearch.Client, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteSeq 根据编号、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteSeq(es *elasticsearch.Client, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteSeq 根据编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteAllTextAuthor 根据全文本、作者、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtAllTextAuthor 根据全文本、作者、页数大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtAllTextAuthor 根据全文本、作者、页数小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteAllTextAuthor 根据全文本、作者、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteAllTextAuthor 根据全文本、作者、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteAllTextAuthor 根据全文本、作者、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteAllTextAuthor(es *elasticsearch.Client, allText, author string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtAllTextAuthor 根据全文本、作者、价格大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtAllTextAuthor(es *elasticsearch.Client, allText, author string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtAllTextAuthor 根据全文本、作者、价格小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtAllTextAuthor(es *elasticsearch.Client, allText, author string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteAllTextAuthor 根据全文本、作者、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteAllTextAuthor(es *elasticsearch.Client, allText, author string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteAllTextAuthor 根据全文本、作者、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteAllTextAuthor 根据全文本、作者、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtAllTextAuthor 根据全文本、作者、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtAllTextAuthor 根据全文本、作者、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteAllTextAuthor 根据全文本、作者、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextAuthor 根据全文本、作者、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteAllTextAuthor 根据全文本、作者、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtAllTextAuthor 根据全文本、作者、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtAllTextAuthor 根据全文本、作者、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteAllTextAuthor 根据全文本、作者、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextAuthor 根据全文本、作者、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteAllTextAuthor 根据全文本、作者、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtAllTextAuthor 根据全文本、作者、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtAllTextAuthor 根据全文本、作者、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteAllTextAuthor 根据全文本、作者、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextAuthor 根据全文本、作者、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteAllTextAuthor 根据全文本、作者、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtAllTextAuthor 根据全文本、作者、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtAllTextAuthor 根据全文本、作者、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteAllTextAuthor 根据全文本、作者、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteAllTextAuthor 根据全文本、作者、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// author string 作者
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteAllTextAuthor(es *elasticsearch.Client, allText, author string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteAllTextClass 根据全文本、类别、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteAllTextClass(es *elasticsearch.Client, allText, class string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtAllTextClass 根据全文本、类别、页数大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtAllTextClass(es *elasticsearch.Client, allText, class string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtAllTextClass 根据全文本、类别、页数小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtAllTextClass(es *elasticsearch.Client, allText, class string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteAllTextClass 根据全文本、类别、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteAllTextClass(es *elasticsearch.Client, allText, class string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteAllTextClass 根据全文本、类别、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteAllTextClass(es *elasticsearch.Client, allText, class string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteAllTextClass 根据全文本、类别、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteAllTextClass(es *elasticsearch.Client, allText, class string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtAllTextClass 根据全文本、类别、价格大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtAllTextClass(es *elasticsearch.Client, allText, class string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtAllTextClass 根据全文本、类别、价格小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtAllTextClass(es *elasticsearch.Client, allText, class string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteAllTextClass 根据全文本、类别、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteAllTextClass(es *elasticsearch.Client, allText, class string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteAllTextClass 根据全文本、类别、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteAllTextClass(es *elasticsearch.Client, allText, class string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteAllTextClass 根据全文本、类别、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtAllTextClass 根据全文本、类别、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtAllTextClass 根据全文本、类别、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteAllTextClass 根据全文本、类别、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextClass 根据全文本、类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteAllTextClass 根据全文本、类别、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtAllTextClass 根据全文本、类别、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtAllTextClass 根据全文本、类别、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteAllTextClass 根据全文本、类别、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextClass 根据全文本、类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteAllTextClass 根据全文本、类别、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtAllTextClass 根据全文本、类别、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtAllTextClass 根据全文本、类别、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteAllTextClass 根据全文本、类别、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextClass 根据全文本、类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteAllTextClass 根据全文本、类别、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtAllTextClass 根据全文本、类别、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtAllTextClass 根据全文本、类别、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteAllTextClass 根据全文本、类别、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteAllTextClass 根据全文本、类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteAllTextClass(es *elasticsearch.Client, allText, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteAllTextClass2 根据全文本、子类别、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtAllTextClass2 根据全文本、子类别、页数大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtAllTextClass2 根据全文本、子类别、页数小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteAllTextClass2 根据全文本、子类别、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteAllTextClass2 根据全文本、子类别、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteAllTextClass2 根据全文本、子类别、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtAllTextClass2 根据全文本、子类别、价格大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtAllTextClass2 根据全文本、子类别、价格小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteAllTextClass2 根据全文本、子类别、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteAllTextClass2 根据全文本、子类别、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteAllTextClass2 根据全文本、子类别、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtAllTextClass2 根据全文本、子类别、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtAllTextClass2 根据全文本、子类别、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteAllTextClass2 根据全文本、子类别、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextClass2 根据全文本、子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteAllTextClass2 根据全文本、子类别、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtAllTextClass2 根据全文本、子类别、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtAllTextClass2 根据全文本、子类别、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteAllTextClass2 根据全文本、子类别、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextClass2 根据全文本、子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteAllTextClass2 根据全文本、子类别、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtAllTextClass2 根据全文本、子类别、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtAllTextClass2 根据全文本、子类别、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteAllTextClass2 根据全文本、子类别、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextClass2 根据全文本、子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteAllTextClass2 根据全文本、子类别、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtAllTextClass2 根据全文本、子类别、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtAllTextClass2 根据全文本、子类别、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteAllTextClass2 根据全文本、子类别、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteAllTextClass2 根据全文本、子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteAllTextClass2(es *elasticsearch.Client, allText, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteAllTextName 根据全文本、书名、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteAllTextName(es *elasticsearch.Client, allText, name string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtAllTextName 根据全文本、书名、页数大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtAllTextName(es *elasticsearch.Client, allText, name string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtAllTextName 根据全文本、书名、页数小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtAllTextName(es *elasticsearch.Client, allText, name string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteAllTextName 根据全文本、书名、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteAllTextName(es *elasticsearch.Client, allText, name string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteAllTextName 根据全文本、书名、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteAllTextName(es *elasticsearch.Client, allText, name string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteAllTextName 根据全文本、书名、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteAllTextName(es *elasticsearch.Client, allText, name string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtAllTextName 根据全文本、书名、价格大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtAllTextName(es *elasticsearch.Client, allText, name string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtAllTextName 根据全文本、书名、价格小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtAllTextName(es *elasticsearch.Client, allText, name string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteAllTextName 根据全文本、书名、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteAllTextName(es *elasticsearch.Client, allText, name string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteAllTextName 根据全文本、书名、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteAllTextName(es *elasticsearch.Client, allText, name string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteAllTextName 根据全文本、书名、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtAllTextName 根据全文本、书名、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtAllTextName 根据全文本、书名、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteAllTextName 根据全文本、书名、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextName 根据全文本、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteAllTextName 根据全文本、书名、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtAllTextName 根据全文本、书名、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtAllTextName 根据全文本、书名、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteAllTextName 根据全文本、书名、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextName 根据全文本、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteAllTextName 根据全文本、书名、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtAllTextName 根据全文本、书名、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtAllTextName 根据全文本、书名、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteAllTextName 根据全文本、书名、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextName 根据全文本、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteAllTextName 根据全文本、书名、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtAllTextName 根据全文本、书名、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtAllTextName 根据全文本、书名、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteAllTextName 根据全文本、书名、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteAllTextName 根据全文本、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteAllTextName(es *elasticsearch.Client, allText, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteAllText 根据全文本、页数大于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGtAllText 根据全文本、页数大于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLtAllText 根据全文本、页数大于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLteAllText 根据全文本、页数大于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteAllText 根据全文本、页数大于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteAllText 根据全文本、页数大于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGtAllText 根据全文本、页数大于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLtAllText 根据全文本、页数大于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLteAllText 根据全文本、页数大于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteAllText 根据全文本、页数大于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteAllText 根据全文本、页数小于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGtAllText 根据全文本、页数小于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLtAllText 根据全文本、页数小于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLteAllText 根据全文本、页数小于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteAllText 根据全文本、页数小于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteAllText 根据全文本、页数小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGtAllText 根据全文本、页数小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLtAllText 根据全文本、页数小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLteAllText 根据全文本、页数小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteAllText 根据全文本、页数小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteAllText 根据全文本、页数大于等于和小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtAllText 根据全文本、页数大于等于和小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtAllText 根据全文本、页数大于等于和小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteAllText 根据全文本、页数大于等于和小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteAllText 根据全文本、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteAllTextSeq 根据全文本、编号、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtAllTextSeq 根据全文本、编号、页数大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtAllTextSeq 根据全文本、编号、页数小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteAllTextSeq 根据全文本、编号、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteAllTextSeq 根据全文本、编号、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteAllText 根据全文本、价格大于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtAllText 根据全文本、价格大于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtAllText 根据全文本、价格大于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteAllText 根据全文本、价格大于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteAllText 根据全文本、价格大于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceGte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteAllText 根据全文本、价格大于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtAllText 根据全文本、价格大于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtAllText 根据全文本、价格大于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteAllText 根据全文本、价格大于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteAllText 根据全文本、价格大于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceGt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteAllText 根据全文本、价格小于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtAllText 根据全文本、价格小于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtAllText 根据全文本、价格小于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteAllText 根据全文本、价格小于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteAllText 根据全文本、价格小于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceLt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteAllText 根据全文本、价格小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtAllText 根据全文本、价格小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtAllText 根据全文本、价格小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteAllText 根据全文本、价格小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteAllText 根据全文本、价格小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteAllText 根据全文本、价格大于等于和小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtAllText 根据全文本、价格大于等于和小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtAllText 根据全文本、价格大于等于和小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteAllText 根据全文本、价格大于等于和小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteAllText 根据全文本、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteAllText(es *elasticsearch.Client, allText string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteAllTextSeq 根据全文本、编号、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteAllTextSeq(es *elasticsearch.Client, allText, seq string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtAllTextSeq 根据全文本、编号、价格大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtAllTextSeq(es *elasticsearch.Client, allText, seq string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtAllTextSeq 根据全文本、编号、价格小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtAllTextSeq(es *elasticsearch.Client, allText, seq string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteAllTextSeq 根据全文本、编号、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteAllTextSeq(es *elasticsearch.Client, allText, seq string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteAllTextSeq 根据全文本、编号、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteAllTextSeq 根据全文本、编号、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtAllTextSeq 根据全文本、编号、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtAllTextSeq 根据全文本、编号、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteAllTextSeq 根据全文本、编号、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextSeq 根据全文本、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteAllTextSeq 根据全文本、编号、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtAllTextSeq 根据全文本、编号、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtAllTextSeq 根据全文本、编号、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteAllTextSeq 根据全文本、编号、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextSeq 根据全文本、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteAllTextSeq 根据全文本、编号、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtAllTextSeq 根据全文本、编号、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtAllTextSeq 根据全文本、编号、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteAllTextSeq 根据全文本、编号、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextSeq 根据全文本、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteAllTextSeq 根据全文本、编号、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtAllTextSeq 根据全文本、编号、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtAllTextSeq 根据全文本、编号、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteAllTextSeq 根据全文本、编号、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteAllTextSeq 根据全文本、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// allText string 全文本
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteAllTextSeq(es *elasticsearch.Client, allText, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("all_text", allText),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteAuthorClass 根据作者、类别、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class string 类别
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteAuthorClass(es *elasticsearch.Client, author, class string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtAuthorClass 根据作者、类别、页数大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class string 类别
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtAuthorClass(es *elasticsearch.Client, author, class string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtAuthorClass 根据作者、类别、页数小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class string 类别
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtAuthorClass(es *elasticsearch.Client, author, class string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteAuthorClass 根据作者、类别、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class string 类别
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteAuthorClass(es *elasticsearch.Client, author, class string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteAuthorClass 根据作者、类别、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteAuthorClass(es *elasticsearch.Client, author, class string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteAuthorClass 根据作者、类别、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class string 类别
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteAuthorClass(es *elasticsearch.Client, author, class string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtAuthorClass 根据作者、类别、价格大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class string 类别
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtAuthorClass(es *elasticsearch.Client, author, class string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtAuthorClass 根据作者、类别、价格小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class string 类别
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtAuthorClass(es *elasticsearch.Client, author, class string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteAuthorClass 根据作者、类别、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class string 类别
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteAuthorClass(es *elasticsearch.Client, author, class string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteAuthorClass 根据作者、类别、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteAuthorClass(es *elasticsearch.Client, author, class string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteAuthorClass 根据作者、类别、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtAuthorClass 根据作者、类别、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtAuthorClass 根据作者、类别、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteAuthorClass 根据作者、类别、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorClass 根据作者、类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteAuthorClass 根据作者、类别、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtAuthorClass 根据作者、类别、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtAuthorClass 根据作者、类别、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteAuthorClass 根据作者、类别、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorClass 根据作者、类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteAuthorClass 根据作者、类别、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtAuthorClass 根据作者、类别、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtAuthorClass 根据作者、类别、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteAuthorClass 根据作者、类别、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorClass 根据作者、类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteAuthorClass 根据作者、类别、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtAuthorClass 根据作者、类别、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class string 类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtAuthorClass 根据作者、类别、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class string 类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteAuthorClass 根据作者、类别、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class string 类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteAuthorClass 根据作者、类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class string 类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteAuthorClass(es *elasticsearch.Client, author, class string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteAuthorClass2 根据作者、子类别、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtAuthorClass2 根据作者、子类别、页数大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtAuthorClass2 根据作者、子类别、页数小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteAuthorClass2 根据作者、子类别、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteAuthorClass2 根据作者、子类别、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteAuthorClass2 根据作者、子类别、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteAuthorClass2(es *elasticsearch.Client, author, class2 string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtAuthorClass2 根据作者、子类别、价格大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtAuthorClass2(es *elasticsearch.Client, author, class2 string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtAuthorClass2 根据作者、子类别、价格小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtAuthorClass2(es *elasticsearch.Client, author, class2 string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteAuthorClass2 根据作者、子类别、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteAuthorClass2(es *elasticsearch.Client, author, class2 string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteAuthorClass2 根据作者、子类别、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteAuthorClass2 根据作者、子类别、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtAuthorClass2 根据作者、子类别、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtAuthorClass2 根据作者、子类别、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteAuthorClass2 根据作者、子类别、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorClass2 根据作者、子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteAuthorClass2 根据作者、子类别、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtAuthorClass2 根据作者、子类别、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtAuthorClass2 根据作者、子类别、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteAuthorClass2 根据作者、子类别、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorClass2 根据作者、子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteAuthorClass2 根据作者、子类别、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtAuthorClass2 根据作者、子类别、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtAuthorClass2 根据作者、子类别、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteAuthorClass2 根据作者、子类别、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorClass2 根据作者、子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteAuthorClass2 根据作者、子类别、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtAuthorClass2 根据作者、子类别、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtAuthorClass2 根据作者、子类别、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteAuthorClass2 根据作者、子类别、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteAuthorClass2 根据作者、子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteAuthorClass2(es *elasticsearch.Client, author, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteAuthorName 根据作者、书名、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// name string 书名
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteAuthorName(es *elasticsearch.Client, author, name string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtAuthorName 根据作者、书名、页数大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// name string 书名
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtAuthorName(es *elasticsearch.Client, author, name string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtAuthorName 根据作者、书名、页数小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// name string 书名
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtAuthorName(es *elasticsearch.Client, author, name string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteAuthorName 根据作者、书名、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// name string 书名
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteAuthorName(es *elasticsearch.Client, author, name string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteAuthorName 根据作者、书名、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteAuthorName(es *elasticsearch.Client, author, name string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteAuthorName 根据作者、书名、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// name string 书名
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteAuthorName(es *elasticsearch.Client, author, name string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtAuthorName 根据作者、书名、价格大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// name string 书名
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtAuthorName(es *elasticsearch.Client, author, name string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtAuthorName 根据作者、书名、价格小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// name string 书名
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtAuthorName(es *elasticsearch.Client, author, name string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteAuthorName 根据作者、书名、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// name string 书名
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteAuthorName(es *elasticsearch.Client, author, name string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteAuthorName 根据作者、书名、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteAuthorName(es *elasticsearch.Client, author, name string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteAuthorName 根据作者、书名、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtAuthorName 根据作者、书名、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtAuthorName(es *elasticsearch.Client, author, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtAuthorName 根据作者、书名、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtAuthorName(es *elasticsearch.Client, author, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteAuthorName 根据作者、书名、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorName 根据作者、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteAuthorName 根据作者、书名、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtAuthorName 根据作者、书名、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtAuthorName(es *elasticsearch.Client, author, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtAuthorName 根据作者、书名、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtAuthorName(es *elasticsearch.Client, author, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteAuthorName 根据作者、书名、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorName 根据作者、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteAuthorName 根据作者、书名、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtAuthorName 根据作者、书名、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtAuthorName(es *elasticsearch.Client, author, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtAuthorName 根据作者、书名、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtAuthorName(es *elasticsearch.Client, author, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteAuthorName 根据作者、书名、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorName 根据作者、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteAuthorName 根据作者、书名、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtAuthorName 根据作者、书名、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtAuthorName(es *elasticsearch.Client, author, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtAuthorName 根据作者、书名、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtAuthorName(es *elasticsearch.Client, author, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteAuthorName 根据作者、书名、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteAuthorName 根据作者、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteAuthorName(es *elasticsearch.Client, author, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteAuthor 根据作者、页数大于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGtAuthor 根据作者、页数大于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLtAuthor 根据作者、页数大于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLteAuthor 根据作者、页数大于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteAuthor 根据作者、页数大于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteAuthor 根据作者、页数大于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGtAuthor 根据作者、页数大于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLtAuthor 根据作者、页数大于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLteAuthor 根据作者、页数大于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteAuthor 根据作者、页数大于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteAuthor 根据作者、页数小于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGtAuthor 根据作者、页数小于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLtAuthor 根据作者、页数小于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLteAuthor 根据作者、页数小于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteAuthor 根据作者、页数小于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteAuthor 根据作者、页数小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGtAuthor 根据作者、页数小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLtAuthor 根据作者、页数小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLteAuthor 根据作者、页数小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteAuthor 根据作者、页数小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteAuthor 根据作者、页数大于等于和小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtAuthor 根据作者、页数大于等于和小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtAuthor 根据作者、页数大于等于和小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteAuthor 根据作者、页数大于等于和小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteAuthor 根据作者、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteAuthorSeq 根据作者、编号、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtAuthorSeq 根据作者、编号、页数大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtAuthorSeq 根据作者、编号、页数小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteAuthorSeq 根据作者、编号、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteAuthorSeq 根据作者、编号、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteAuthor 根据作者、价格大于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtAuthor 根据作者、价格大于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtAuthor 根据作者、价格大于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteAuthor 根据作者、价格大于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteAuthor 根据作者、价格大于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceGte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteAuthor 根据作者、价格大于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtAuthor 根据作者、价格大于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtAuthor 根据作者、价格大于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteAuthor 根据作者、价格大于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteAuthor 根据作者、价格大于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceGt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteAuthor 根据作者、价格小于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtAuthor 根据作者、价格小于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtAuthor 根据作者、价格小于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteAuthor 根据作者、价格小于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteAuthor 根据作者、价格小于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceLt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteAuthor 根据作者、价格小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtAuthor 根据作者、价格小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtAuthor 根据作者、价格小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteAuthor 根据作者、价格小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteAuthor 根据作者、价格小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteAuthor 根据作者、价格大于等于和小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtAuthor 根据作者、价格大于等于和小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtAuthor 根据作者、价格大于等于和小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteAuthor 根据作者、价格大于等于和小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteAuthor 根据作者、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteAuthor(es *elasticsearch.Client, author string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteAuthorSeq 根据作者、编号、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteAuthorSeq(es *elasticsearch.Client, author, seq string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtAuthorSeq 根据作者、编号、价格大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtAuthorSeq(es *elasticsearch.Client, author, seq string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtAuthorSeq 根据作者、编号、价格小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtAuthorSeq(es *elasticsearch.Client, author, seq string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteAuthorSeq 根据作者、编号、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteAuthorSeq(es *elasticsearch.Client, author, seq string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteAuthorSeq 根据作者、编号、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteAuthorSeq 根据作者、编号、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtAuthorSeq 根据作者、编号、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtAuthorSeq 根据作者、编号、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteAuthorSeq 根据作者、编号、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorSeq 根据作者、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteAuthorSeq 根据作者、编号、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtAuthorSeq 根据作者、编号、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtAuthorSeq 根据作者、编号、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteAuthorSeq 根据作者、编号、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorSeq 根据作者、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteAuthorSeq 根据作者、编号、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtAuthorSeq 根据作者、编号、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtAuthorSeq 根据作者、编号、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteAuthorSeq 根据作者、编号、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorSeq 根据作者、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteAuthorSeq 根据作者、编号、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtAuthorSeq 根据作者、编号、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtAuthorSeq 根据作者、编号、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteAuthorSeq 根据作者、编号、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteAuthorSeq 根据作者、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// author string 作者
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteAuthorSeq(es *elasticsearch.Client, author, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("author", author),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteClassClass2 根据类别、子类别、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteClassClass2(es *elasticsearch.Client, class, class2 string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtClassClass2 根据类别、子类别、页数大于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtClassClass2(es *elasticsearch.Client, class, class2 string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtClassClass2 根据类别、子类别、页数小于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtClassClass2(es *elasticsearch.Client, class, class2 string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteClassClass2 根据类别、子类别、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteClassClass2(es *elasticsearch.Client, class, class2 string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteClassClass2 根据类别、子类别、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteClassClass2(es *elasticsearch.Client, class, class2 string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteClassClass2 根据类别、子类别、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteClassClass2(es *elasticsearch.Client, class, class2 string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtClassClass2 根据类别、子类别、价格大于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtClassClass2(es *elasticsearch.Client, class, class2 string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtClassClass2 根据类别、子类别、价格小于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtClassClass2(es *elasticsearch.Client, class, class2 string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteClassClass2 根据类别、子类别、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteClassClass2(es *elasticsearch.Client, class, class2 string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteClassClass2 根据类别、子类别、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteClassClass2(es *elasticsearch.Client, class, class2 string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteClassClass2 根据类别、子类别、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtClassClass2 根据类别、子类别、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtClassClass2 根据类别、子类别、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteClassClass2 根据类别、子类别、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteClassClass2 根据类别、子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteClassClass2 根据类别、子类别、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtClassClass2 根据类别、子类别、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtClassClass2 根据类别、子类别、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteClassClass2 根据类别、子类别、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteClassClass2 根据类别、子类别、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteClassClass2 根据类别、子类别、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtClassClass2 根据类别、子类别、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtClassClass2 根据类别、子类别、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteClassClass2 根据类别、子类别、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteClassClass2 根据类别、子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteClassClass2 根据类别、子类别、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtClassClass2 根据类别、子类别、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtClassClass2 根据类别、子类别、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteClassClass2 根据类别、子类别、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteClassClass2 根据类别、子类别、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// class2 string 子类别
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteClassClass2(es *elasticsearch.Client, class, class2 string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteClassName 根据类别、书名、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// name string 书名
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteClassName(es *elasticsearch.Client, class, name string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtClassName 根据类别、书名、页数大于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// name string 书名
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtClassName(es *elasticsearch.Client, class, name string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtClassName 根据类别、书名、页数小于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// name string 书名
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtClassName(es *elasticsearch.Client, class, name string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteClassName 根据类别、书名、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// name string 书名
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteClassName(es *elasticsearch.Client, class, name string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteClassName 根据类别、书名、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteClassName(es *elasticsearch.Client, class, name string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteClassName 根据类别、书名、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// name string 书名
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteClassName(es *elasticsearch.Client, class, name string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtClassName 根据类别、书名、价格大于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// name string 书名
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtClassName(es *elasticsearch.Client, class, name string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtClassName 根据类别、书名、价格小于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// name string 书名
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtClassName(es *elasticsearch.Client, class, name string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteClassName 根据类别、书名、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// name string 书名
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteClassName(es *elasticsearch.Client, class, name string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteClassName 根据类别、书名、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteClassName(es *elasticsearch.Client, class, name string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteClassName 根据类别、书名、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteClassName(es *elasticsearch.Client, class, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtClassName 根据类别、书名、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtClassName(es *elasticsearch.Client, class, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtClassName 根据类别、书名、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtClassName(es *elasticsearch.Client, class, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteClassName 根据类别、书名、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteClassName(es *elasticsearch.Client, class, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteClassName 根据类别、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteClassName(es *elasticsearch.Client, class, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteClassName 根据类别、书名、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteClassName(es *elasticsearch.Client, class, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtClassName 根据类别、书名、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtClassName(es *elasticsearch.Client, class, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtClassName 根据类别、书名、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtClassName(es *elasticsearch.Client, class, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteClassName 根据类别、书名、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteClassName(es *elasticsearch.Client, class, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteClassName 根据类别、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteClassName(es *elasticsearch.Client, class, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteClassName 根据类别、书名、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteClassName(es *elasticsearch.Client, class, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtClassName 根据类别、书名、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtClassName(es *elasticsearch.Client, class, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtClassName 根据类别、书名、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtClassName(es *elasticsearch.Client, class, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteClassName 根据类别、书名、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteClassName(es *elasticsearch.Client, class, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteClassName 根据类别、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteClassName(es *elasticsearch.Client, class, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteClassName 根据类别、书名、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteClassName(es *elasticsearch.Client, class, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtClassName 根据类别、书名、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtClassName(es *elasticsearch.Client, class, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtClassName 根据类别、书名、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtClassName(es *elasticsearch.Client, class, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteClassName 根据类别、书名、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteClassName(es *elasticsearch.Client, class, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteClassName 根据类别、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteClassName(es *elasticsearch.Client, class, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteClass 根据类别、页数大于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGtClass 根据类别、页数大于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLtClass 根据类别、页数大于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLteClass 根据类别、页数大于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteClass 根据类别、页数大于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteClass 根据类别、页数大于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGtClass 根据类别、页数大于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLtClass 根据类别、页数大于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLteClass 根据类别、页数大于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteClass 根据类别、页数大于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteClass 根据类别、页数小于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGtClass 根据类别、页数小于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLtClass 根据类别、页数小于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLteClass 根据类别、页数小于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteClass 根据类别、页数小于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteClass 根据类别、页数小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGtClass 根据类别、页数小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLtClass 根据类别、页数小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLteClass 根据类别、页数小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteClass 根据类别、页数小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteClass 根据类别、页数大于等于和小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtClass 根据类别、页数大于等于和小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtClass 根据类别、页数大于等于和小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteClass 根据类别、页数大于等于和小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteClass 根据类别、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteClass(es *elasticsearch.Client, class string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteClassSeq 根据类别、编号、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteClassSeq(es *elasticsearch.Client, class, seq string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtClassSeq 根据类别、编号、页数大于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtClassSeq(es *elasticsearch.Client, class, seq string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtClassSeq 根据类别、编号、页数小于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtClassSeq(es *elasticsearch.Client, class, seq string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteClassSeq 根据类别、编号、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteClassSeq(es *elasticsearch.Client, class, seq string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteClassSeq 根据类别、编号、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteClassSeq(es *elasticsearch.Client, class, seq string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteClass 根据类别、价格大于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtClass 根据类别、价格大于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtClass 根据类别、价格大于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteClass 根据类别、价格大于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteClass 根据类别、价格大于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceGte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteClass 根据类别、价格大于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtClass 根据类别、价格大于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtClass 根据类别、价格大于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteClass 根据类别、价格大于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteClass 根据类别、价格大于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceGt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteClass 根据类别、价格小于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtClass 根据类别、价格小于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtClass 根据类别、价格小于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteClass 根据类别、价格小于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteClass 根据类别、价格小于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceLt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteClass 根据类别、价格小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtClass 根据类别、价格小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtClass 根据类别、价格小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteClass 根据类别、价格小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteClass 根据类别、价格小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteClass 根据类别、价格大于等于和小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtClass 根据类别、价格大于等于和小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtClass 根据类别、价格大于等于和小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteClass 根据类别、价格大于等于和小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteClass 根据类别、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteClass(es *elasticsearch.Client, class string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteClassSeq 根据类别、编号、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteClassSeq(es *elasticsearch.Client, class, seq string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtClassSeq 根据类别、编号、价格大于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtClassSeq(es *elasticsearch.Client, class, seq string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtClassSeq 根据类别、编号、价格小于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtClassSeq(es *elasticsearch.Client, class, seq string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteClassSeq 根据类别、编号、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteClassSeq(es *elasticsearch.Client, class, seq string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteClassSeq 根据类别、编号、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteClassSeq(es *elasticsearch.Client, class, seq string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteClassSeq 根据类别、编号、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtClassSeq 根据类别、编号、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtClassSeq 根据类别、编号、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteClassSeq 根据类别、编号、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteClassSeq 根据类别、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteClassSeq 根据类别、编号、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtClassSeq 根据类别、编号、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtClassSeq 根据类别、编号、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteClassSeq 根据类别、编号、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteClassSeq 根据类别、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteClassSeq 根据类别、编号、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtClassSeq 根据类别、编号、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtClassSeq 根据类别、编号、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteClassSeq 根据类别、编号、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteClassSeq 根据类别、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteClassSeq 根据类别、编号、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtClassSeq 根据类别、编号、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtClassSeq 根据类别、编号、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteClassSeq 根据类别、编号、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteClassSeq 根据类别、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class string 类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteClassSeq(es *elasticsearch.Client, class, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class", class),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteClass2Name 根据子类别、书名、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteClass2Name(es *elasticsearch.Client, class2, name string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtClass2Name 根据子类别、书名、页数大于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtClass2Name(es *elasticsearch.Client, class2, name string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtClass2Name 根据子类别、书名、页数小于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtClass2Name(es *elasticsearch.Client, class2, name string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteClass2Name 根据子类别、书名、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteClass2Name(es *elasticsearch.Client, class2, name string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteClass2Name 根据子类别、书名、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteClass2Name(es *elasticsearch.Client, class2, name string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteClass2Name 根据子类别、书名、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteClass2Name(es *elasticsearch.Client, class2, name string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtClass2Name 根据子类别、书名、价格大于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtClass2Name(es *elasticsearch.Client, class2, name string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtClass2Name 根据子类别、书名、价格小于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtClass2Name(es *elasticsearch.Client, class2, name string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteClass2Name 根据子类别、书名、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteClass2Name(es *elasticsearch.Client, class2, name string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteClass2Name 根据子类别、书名、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteClass2Name(es *elasticsearch.Client, class2, name string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteClass2Name 根据子类别、书名、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtClass2Name 根据子类别、书名、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtClass2Name 根据子类别、书名、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteClass2Name 根据子类别、书名、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteClass2Name 根据子类别、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteClass2Name 根据子类别、书名、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtClass2Name 根据子类别、书名、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtClass2Name 根据子类别、书名、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteClass2Name 根据子类别、书名、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteClass2Name 根据子类别、书名、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteClass2Name 根据子类别、书名、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtClass2Name 根据子类别、书名、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtClass2Name 根据子类别、书名、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteClass2Name 根据子类别、书名、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteClass2Name 根据子类别、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteClass2Name 根据子类别、书名、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtClass2Name 根据子类别、书名、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtClass2Name 根据子类别、书名、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteClass2Name 根据子类别、书名、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteClass2Name 根据子类别、书名、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// name string 书名
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteClass2Name(es *elasticsearch.Client, class2, name string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteClass2 根据子类别、页数大于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGtClass2 根据子类别、页数大于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLtClass2 根据子类别、页数大于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLteClass2 根据子类别、页数大于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteClass2 根据子类别、页数大于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteClass2 根据子类别、页数大于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGtClass2 根据子类别、页数大于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLtClass2 根据子类别、页数大于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLteClass2 根据子类别、页数大于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteClass2 根据子类别、页数大于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteClass2 根据子类别、页数小于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGtClass2 根据子类别、页数小于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLtClass2 根据子类别、页数小于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLteClass2 根据子类别、页数小于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteClass2 根据子类别、页数小于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteClass2 根据子类别、页数小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGtClass2 根据子类别、页数小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLtClass2 根据子类别、页数小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLteClass2 根据子类别、页数小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteClass2 根据子类别、页数小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteClass2 根据子类别、页数大于等于和小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtClass2 根据子类别、页数大于等于和小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtClass2 根据子类别、页数大于等于和小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteClass2 根据子类别、页数大于等于和小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteClass2 根据子类别、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteClass2Seq 根据子类别、编号、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtClass2Seq 根据子类别、编号、页数大于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtClass2Seq 根据子类别、编号、页数小于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteClass2Seq 根据子类别、编号、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteClass2Seq 根据子类别、编号、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteClass2 根据子类别、价格大于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtClass2 根据子类别、价格大于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtClass2 根据子类别、价格大于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteClass2 根据子类别、价格大于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteClass2 根据子类别、价格大于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceGte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteClass2 根据子类别、价格大于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtClass2 根据子类别、价格大于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtClass2 根据子类别、价格大于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteClass2 根据子类别、价格大于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteClass2 根据子类别、价格大于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceGt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteClass2 根据子类别、价格小于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtClass2 根据子类别、价格小于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtClass2 根据子类别、价格小于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteClass2 根据子类别、价格小于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteClass2 根据子类别、价格小于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceLt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteClass2 根据子类别、价格小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtClass2 根据子类别、价格小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtClass2 根据子类别、价格小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteClass2 根据子类别、价格小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteClass2 根据子类别、价格小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteClass2 根据子类别、价格大于等于和小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtClass2 根据子类别、价格大于等于和小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtClass2 根据子类别、价格大于等于和小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteClass2 根据子类别、价格大于等于和小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteClass2 根据子类别、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteClass2(es *elasticsearch.Client, class2 string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteClass2Seq 根据子类别、编号、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteClass2Seq(es *elasticsearch.Client, class2, seq string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtClass2Seq 根据子类别、编号、价格大于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtClass2Seq(es *elasticsearch.Client, class2, seq string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtClass2Seq 根据子类别、编号、价格小于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtClass2Seq(es *elasticsearch.Client, class2, seq string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteClass2Seq 根据子类别、编号、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteClass2Seq(es *elasticsearch.Client, class2, seq string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteClass2Seq 根据子类别、编号、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteClass2Seq 根据子类别、编号、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtClass2Seq 根据子类别、编号、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtClass2Seq 根据子类别、编号、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteClass2Seq 根据子类别、编号、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteClass2Seq 根据子类别、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteClass2Seq 根据子类别、编号、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtClass2Seq 根据子类别、编号、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtClass2Seq 根据子类别、编号、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteClass2Seq 根据子类别、编号、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteClass2Seq 根据子类别、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteClass2Seq 根据子类别、编号、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtClass2Seq 根据子类别、编号、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtClass2Seq 根据子类别、编号、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteClass2Seq 根据子类别、编号、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteClass2Seq 根据子类别、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteClass2Seq 根据子类别、编号、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtClass2Seq 根据子类别、编号、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtClass2Seq 根据子类别、编号、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteClass2Seq 根据子类别、编号、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteClass2Seq 根据子类别、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// class2 string 子类别
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteClass2Seq(es *elasticsearch.Client, class2, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("class2", class2),
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteName 根据书名、页数大于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGtName 根据书名、页数大于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGtName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLtName 根据书名、页数大于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLtName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLteName 根据书名、页数大于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLteName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteName 根据书名、页数大于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteName 根据书名、页数大于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGtName 根据书名、页数大于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGtName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLtName 根据书名、页数大于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLtName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLteName 根据书名、页数大于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLteName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteName 根据书名、页数大于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteName 根据书名、页数小于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGtName 根据书名、页数小于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGtName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLtName 根据书名、页数小于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLtName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLteName 根据书名、页数小于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLteName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteName 根据书名、页数小于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteName 根据书名、页数小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGtName 根据书名、页数小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGtName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLtName 根据书名、页数小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLtName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLteName 根据书名、页数小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLteName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteName 根据书名、页数小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteName 根据书名、页数大于等于和小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtName 根据书名、页数大于等于和小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtName 根据书名、页数大于等于和小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteName 根据书名、页数大于等于和小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteName 根据书名、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteName(es *elasticsearch.Client, name string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteNameSeq 根据书名、编号、页数大于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// pageCountGte int64 页数大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteNameSeq(es *elasticsearch.Client, name, seq string, pageCountGte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtNameSeq 根据书名、编号、页数大于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// pageCountGt int64 页数大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtNameSeq(es *elasticsearch.Client, name, seq string, pageCountGt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtNameSeq 根据书名、编号、页数小于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// pageCountLt int64 页数小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtNameSeq(es *elasticsearch.Client, name, seq string, pageCountLt int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteNameSeq 根据书名、编号、页数小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteNameSeq(es *elasticsearch.Client, name, seq string, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteNameSeq 根据书名、编号、页数大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteNameSeq(es *elasticsearch.Client, name, seq string, pageCountGte, pageCountLte int64, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteName 根据书名、价格大于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteName(es *elasticsearch.Client, name string, priceGte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtName 根据书名、价格大于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtName(es *elasticsearch.Client, name string, priceGte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtName 根据书名、价格大于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtName(es *elasticsearch.Client, name string, priceGte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteName 根据书名、价格大于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteName(es *elasticsearch.Client, name string, priceGte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteName 根据书名、价格大于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteName(es *elasticsearch.Client, name string, priceGte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteName 根据书名、价格大于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteName(es *elasticsearch.Client, name string, priceGt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtName 根据书名、价格大于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtName(es *elasticsearch.Client, name string, priceGt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtName 根据书名、价格大于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtName(es *elasticsearch.Client, name string, priceGt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteName 根据书名、价格大于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteName(es *elasticsearch.Client, name string, priceGt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteName 根据书名、价格大于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteName(es *elasticsearch.Client, name string, priceGt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteName 根据书名、价格小于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteName(es *elasticsearch.Client, name string, priceLt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtName 根据书名、价格小于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtName(es *elasticsearch.Client, name string, priceLt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtName 根据书名、价格小于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtName(es *elasticsearch.Client, name string, priceLt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteName 根据书名、价格小于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteName(es *elasticsearch.Client, name string, priceLt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteName 根据书名、价格小于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteName(es *elasticsearch.Client, name string, priceLt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteName 根据书名、价格小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteName(es *elasticsearch.Client, name string, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtName 根据书名、价格小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtName(es *elasticsearch.Client, name string, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtName 根据书名、价格小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtName(es *elasticsearch.Client, name string, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteName 根据书名、价格小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteName(es *elasticsearch.Client, name string, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteName 根据书名、价格小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteName(es *elasticsearch.Client, name string, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteName 根据书名、价格大于等于和小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtName 根据书名、价格大于等于和小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtName 根据书名、价格大于等于和小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteName 根据书名、价格大于等于和小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteName 根据书名、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteName(es *elasticsearch.Client, name string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteNameSeq 根据书名、编号、价格大于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// priceGte float64 价格大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteNameSeq(es *elasticsearch.Client, name, seq string, priceGte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtNameSeq 根据书名、编号、价格大于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// priceGt float64 价格大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtNameSeq(es *elasticsearch.Client, name, seq string, priceGt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtNameSeq 根据书名、编号、价格小于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// priceLt float64 价格小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtNameSeq(es *elasticsearch.Client, name, seq string, priceLt, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteNameSeq 根据书名、编号、价格小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteNameSeq(es *elasticsearch.Client, name, seq string, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteNameSeq 根据书名、编号、价格大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteNameSeq(es *elasticsearch.Client, name, seq string, priceGte, priceLte, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteNameSeq 根据书名、编号、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGtNameSeq 根据书名、编号、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLtNameSeq 根据书名、编号、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateLteNameSeq 根据书名、编号、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteNameSeq 根据书名、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByReleaseDateGteLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteNameSeq 根据书名、编号、发布日期大于等于检索books表并按页数区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGtNameSeq 根据书名、编号、发布日期大于检索books表并按页数区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLtNameSeq 根据书名、编号、发布日期小于检索books表并按页数区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateLteNameSeq 根据书名、编号、发布日期小于等于检索books表并按页数区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPageCountOfBooksByReleaseDateGteLteNameSeq 根据书名、编号、发布日期大于等于和小于等于检索books表并按页数区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPriceInHistPageCountOfBooksByReleaseDateGteLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteNameSeq 根据书名、编号、发布日期大于等于检索books表并按价格区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGtNameSeq 根据书名、编号、发布日期大于检索books表并按价格区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLtNameSeq 根据书名、编号、发布日期小于检索books表并按价格区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateLteNameSeq 根据书名、编号、发布日期小于等于检索books表并按价格区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPriceOfBooksByReleaseDateGteLteNameSeq 根据书名、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计页数的最大值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPageCountInHistPriceOfBooksByReleaseDateGteLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteNameSeq 根据书名、编号、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGtNameSeq 根据书名、编号、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLtNameSeq 根据书名、编号、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLtNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateLteNameSeq 根据书名、编号、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByReleaseDateGteLteNameSeq 根据书名、编号、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// name string 书名
// seq string 编号
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByReleaseDateGteLteNameSeq(es *elasticsearch.Client, name, seq string, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	matches := []eq.Map{
		eq.Match("name", name),
	}
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithMust(matches), eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteSeq 根据编号、页数大于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGtSeq 根据编号、页数大于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLtSeq 根据编号、页数大于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLteSeq 根据编号、页数大于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteSeq 根据编号、页数大于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountGte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteSeq 根据编号、页数大于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGtSeq 根据编号、页数大于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLtSeq 根据编号、页数大于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLteSeq 根据编号、页数大于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteSeq 根据编号、页数大于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGt int64 页数大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGtReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountGt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, pageCountGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteSeq 根据编号、页数小于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGtSeq 根据编号、页数小于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLtSeq 根据编号、页数小于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLteSeq 根据编号、页数小于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteSeq 根据编号、页数小于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountLt int64 页数小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLtReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountLt int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, pageCountLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteSeq 根据编号、页数小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGtSeq 根据编号、页数小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLtSeq 根据编号、页数小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLteSeq 根据编号、页数小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteSeq 根据编号、页数小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountLteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", nil, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteSeq 根据编号、页数大于等于和小于等于、发布日期大于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtSeq 根据编号、页数大于等于和小于等于、发布日期大于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGtSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtSeq 根据编号、页数大于等于和小于等于、发布日期小于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLtSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteSeq 根据编号、页数大于等于和小于等于、发布日期小于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateLteSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteSeq 根据编号、页数大于等于和小于等于、发布日期大于等于和小于等于检索books表并按价格区间分桶统计价格的最大值
// seq string 编号
// pageCountGte int64 页数大于等于
// pageCountLte int64 页数小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的价格区间间隔
func MaxPriceInHistPriceOfBooksByPageCountGteLteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, pageCountGte, pageCountLte int64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("page_count", pageCountGte, nil, nil, pageCountLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("price", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("price"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteSeq 根据编号、价格大于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtSeq 根据编号、价格大于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtSeq 根据编号、价格大于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteSeq 根据编号、价格大于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteSeq 根据编号、价格大于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceGte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteSeq 根据编号、价格大于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtSeq 根据编号、价格大于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGt float64 价格大于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtSeq 根据编号、价格大于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGt float64 价格大于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteSeq 根据编号、价格大于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGt float64 价格大于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteSeq 根据编号、价格大于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGt float64 价格大于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGtReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceGt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, priceGt, nil, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteSeq 根据编号、价格小于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtSeq 根据编号、价格小于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceLt float64 价格小于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtSeq 根据编号、价格小于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceLt float64 价格小于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteSeq 根据编号、价格小于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceLt float64 价格小于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteSeq 根据编号、价格小于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceLt float64 价格小于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLtReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceLt float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, priceLt, nil),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteSeq 根据编号、价格小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtSeq 根据编号、价格小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtSeq 根据编号、价格小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteSeq 根据编号、价格小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteSeq 根据编号、价格小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceLteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", nil, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteSeq 根据编号、价格大于等于和小于等于、发布日期大于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateGte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtSeq 根据编号、价格大于等于和小于等于、发布日期大于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGt time.Time 发布日期大于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGtSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateGt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, releaseDateGt, nil, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtSeq 根据编号、价格大于等于和小于等于、发布日期小于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLt time.Time 发布日期小于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLtSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateLt time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, releaseDateLt, nil),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteSeq 根据编号、价格大于等于和小于等于、发布日期小于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateLteSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", nil, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}

// MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteSeq 根据编号、价格大于等于和小于等于、发布日期大于等于和小于等于检索books表并按页数区间分桶统计页数的最大值
// seq string 编号
// priceGte float64 价格大于等于
// priceLte float64 价格小于等于
// releaseDateGte time.Time 发布日期大于等于
// releaseDateLte time.Time 发布日期小于等于
// histInterval float64 分桶聚合的页数区间间隔
func MaxPageCountInHistPageCountOfBooksByPriceGteLteReleaseDateGteLteSeq(es *elasticsearch.Client, seq string, priceGte, priceLte float64, releaseDateGte, releaseDateLte time.Time, histInterval float64) (*eq.Data, *eq.Query, error) {
	terms := []eq.Map{
		eq.Term("seq", seq),
		eq.Range("price", priceGte, nil, nil, priceLte),
		eq.Range("release_date", releaseDateGte, nil, nil, releaseDateLte),
	}
	aggs := eq.HistogramAgg("page_count", eq.WithInterval(histInterval))
	aggs = aggs.Nested(eq.MaxAgg("page_count"))
	esQuery := &eq.ESQuery{Query: eq.Bool(eq.WithFilter(terms)), Agg: aggs}
	return queryBooksList(es, esQuery)
}
